classla_tokens
ovde konacno resenje
start funkcije za pocetak igre
cistim konzolu
reset vremena vreme sistema za RND
3 unesi za prekid igre
pune se zastavice za odgovarajuce polje
"a koji su na nuli ostaju imena polja npr. A1 , A2 ."
zapocinje se igra
a = fniz [ 0 ]
funkcija koja kao rezultat vraca duzinu stringa
pomeranje u desno
ovo se menja pritiskom na dugme c
cistimo bafere
za sada koristim ovo ali svejedno je ime promenljive bitno je da je okej velicina : TODO
podesili smo funkciju on_timer da sama sebe poziva
Podesava se vidna tacka
"koordinatni sistem , ako je false ne iscrtava se ako je true iscrtava se"
"Skaliramo sve za koeficijent , po svim osama"
"u ovom slucaju ne skaliramo , ali ipak cu ostaviti da mi bude lakse kasnije da ne razmisjljam"
Iscrtavamo igraca
drawPlayerModel2D ( ) ;
iz keyboard . h
biramo da li zelimo 3 D ili 2 D
Radimo switch za nasu dugmad
predefinisane promenljive za dirke na tastaturi
Inicijalizujemo GLUT
promenljiva koja ce nam pomeriti malko iscrtavanje ispod y jer ne zelimo da vidimo prostor izmedju kada se renderuje
"sprintf ( string , "" % d ! "" , score ) ;"
Ispisujemo score
Iscrtavamo red plane
"Podesavamo prvobitnu plocu , i poziciju igraca u odnosu na nju"
promenljive koje cuvaju poziciju igraca
Parametar za x osu crvene ravni
animation parametar
promenljiva koja ce mi reci da li sam u 3 D prikazu ili 2 D prikazu
koristimo ga u on_timer pozivu za kontrolu frejmova po sekundi
Moje promenljive
duzina ploce
bool promenljive za kretanje
Cisto ogranicenje za visinu
Dodatno skracivanje
Mogao sam da stavim i if else konstrukciju ali je svejedno jer ce se svakako pozivati za jedno od ova dva i nije bitan redosled provere
"Ukoliko je visina na koju treba da skocimo manja od nekog dela visine naseg igraca onda necemo da skacemo , samo da predjemo preko toga"
Podesavamo vektore
Inicijalizujemo osobine svetlosti koje zelimo i poziciju osvetljenja
z osa
Program ilustruje globalne i lokalne promenljive
if ( b > 0 )
Program ilustruje grananje ( switch ) - ispituje se vrsta karaktera
Program ilustruje petlju ( for )
Prekid petlje
Program ilustruje definisanje funkcija - funkcija koja sabira dva broja
Program ilustruje rad sa ( staticki alociranim ) nizovima - pronalazenje maksimalnog elementa niza
"Ovo ne moze : int a [ ] ; Ovo moze : int a [ 10 ] ; Cak i ovo : int a [ 100 ] = { 3 , 4 } ;"
Kvadrat broja - ispravljena verzija
Program ilustruje C pretrpocesor - direktiva #define
Rasponi
"Aritmeticki operatori imaju veci prioritet u odnosu na relacijske , a ovi u odnosu na logicke pa zagrade u prethodnim izrazima kao ni u narednom izrazu nisu neophodne"
"Ipak , negacija ( kao unarni operator ) ima prioritet u odnosu na sve binarne operatore pa je zagrada u izrazu ! ( 3 > 5 ) neophodna"
petlja sa dva brojaca
ugnjezdjene petlje - tablica mnozenja
Proveravamo obicne cifre
btoi - konverzija iz datog brojnog sistema u dekadni
Proveravamo slovne cifre za mala slova
"Kolicnik i ostatak su takvi brojevi q i r za koje vazi : x = q*y + r , 0 < = r < y"
Euklidov algoritam za odredjivanje NZD - preko deljenja - rekurzivna definicija
Demonstrira zivotni vek i oblasti vazenja promenjivih ( scope )
Staticke promenjive cuvaju vrednosti kroz pozive funkcije . Inicijalizacija se odvija samo u okviru prvog poziva .
"printf ( "" % d "" , sum ( 3 )) ;"
Deklaracije i definicije - sum - verzija sa definicijom
Neispravan poziv ne prijavljuje gresku
Obratite paznju na ovo :
"Funkcija ucitava rec sa standardnog ulaza i smesta je u niz karaktera s. Ovo uspeva zbog toga sto se po vrednosti prenosi adresa pocetka niza , a ne ceo niz"
isto je i int * px ;
Moguce je dodeliti niz pokazivacu odgovarajuceg tipa
Demonstrira vezu izmedju pokazivaca i nizova
a = pa ;
Niz je moguce koristiti kao pokazivac tj. vaze pravila pokazivacke aritmetike
Pokazivace je na osnovu prethodnog moguce indeksirati kao nizove
"Pronalazi prvu poziciju karaktera c u stringu s , odnosno -1 ukoliko s ne sadrzi c"
nikako else return -1 ;
"Pronalazi poslednju poziciju karaktera c u stringu s , odnosno -1 ukoliko s ne sadrzi c"
"Kopira karakter po karakter , sve dok nije iskopiran karakter ' \ 0 '"
Nadovezuje string t na kraj stringa s. Pretpostavlja da u s ima dovoljno prostora .
Pronalazimo kraj stringa s
"Vrsi se kopiranje , slicno funkciji string_copy"
"Vezbe radi , implementirane su funkcije biblioteke string . h"
"* s i * t su prvi karakteri u kojima se niske razlikuju . Na osnovu njihovog odnosa , odredjuje se odnos stringova"
Izracunava duzinu stringa
"Funkcija izracunava sumu \ sum_ { i = 1 } ^ n f ( i ) , gde je f data funkcija prvi argument funkcije sumiraj je int ( * f ) ( int ) sto je pokazivac na funkciju koja ima jedan argument tipa int i vraca vrednost tipa int"
Izracunava duzinu duzi zadatu sa dve tacke
Izracunava povrsinu trougla Heronovim obrascem . Argumenti funkcije su tri tacke koje predstavljaju temena trougla
Duzine stranica
Poluobim
Dodajemo duzine stranica koje spajaju susedna temena
Izracunava povsinu konveksnog poligona . Argumenti funkcije su niz tacaka koje predstavljaju temena poligona kao i njihov broj
Definisemo dve promenljive tipa tacke
"triangle je niz od tri tacke - trougao ( 0,0 ) , ( 0,1 ) , ( 1,0 )"
square je niz od cetiri tacke - jedinicni kvadrat .
Definisemo promenljivu tipa tacke . Umesto struct point mozemo koristiti POINT
Ispisujemo velicinu strukture tacka
Promenljive lokalne za funkciju main
Globalna promenljiva
stampanje podataka o zaposlenom
"Primer : Rad sa strukturom . Korisnik unosi podatke o zaposlenom , program ih tabelarno ispisuje ."
niz struktura svih aspolvenata
for petlja koja se krece od prvog do poslednjeg apsolventa
unos podataka o svakom apsolventu
prosek inicijalizovan na nulu pre unosa
lista predprocesorskih direktiva
Korisnik odredjuje broj timova sto ce odrediti duzinu niza za tabelu
Upis podrazumevanih vrednosti u tabelu
Izracunavanje broja svih mogucih utakmica
Popunjavanje rezultata utakmica . Iteracijom kroz dve petlje dobijamo broj prolaza koji odgovara promenljivoj BROJ_UTAKMICA . To znaci da se dobijaju parovi ( utakmice ) po kriterijumu ‘ svako sa svakim ’ – kombinacije bez ponavljanja . Timove uzimamo iz tabele timova .
Dodela id_a svakog tima po utakmici . Uspostavlja se relacija tim-utakmica . Kasnije se id_i koriste za rekonstrukciju rezultata utakmice .
Funkcija izracunava max broj kombinacija . Formula za kombinacije bez ponavljanja je : n ! / ( k ! * ( n – k ) ! )
"Primer : Program za izracunavanje statistike u grupi na SP u fudbalu . Grupa ima 4 tima , u grupi igra svako sa svakim , na osnovu odigranih utakmica u grupi i unetih rezultata izracunava se : poredak u grupi , ekipa sa najboljom gol razlikom , ekipa sa najvise postignutih golova ."
Niz struktura za unos rezultata utakmica
definisanje promenljive i sa dodeljivanjem vrednosti 2
definisanje promenljive
izracunavanje obima pravougaonika
izracunavanje povrsine pravougaonika
simbolicka konstanta
unos prve tacke
Primer : Izracunati rastojanje izmedu dve tacke u prostoru ako su zadate koordinate krajnjih tacaka
unos ugla u radijanima
konverzija u stepene
zaokruzivanje broja stepeni
provera uslova izraza
prvi nacin
Primer : Izracunavanje n-tog stepena celog broja a. Oba broja se unose sa tastature
izracunavanje sume kvadrata
cifra na mestu stotica
"Primer : Program za nalazenje svih trocifrenih brojeva koji su jednaki zbiru kubova svojih cifara , abc = a3 + b3 + c3"
tabeliranje funkcije
Primer : Program za tabeliranje funkcije : y = ( 1 + x + x2 ) u opsegu od xmin do xmax sa korakom dx
Primer : Program za tabeliranje funkcije ' s ' u opsegu od xmin do xmax sa korakom dx s =( 1 + x ) * ( 1 + x ^ 2 ) * … * ( 1 + x ^ n )
unos granice ispisa
izracunavanje i stampanje sinusa ugla
Primer : Program za izracunavanje aritmeticke sredine prvih n brojeva . Unos broja n vrsi se sa tastature
odredjivanje broja pojavljivanja znaka
zaglavlje
pauzu koristimo za ispis jednog po jednog ekrana
promena boje
poruka press any key …
kraj sa NULL
prihvata dekadni broj i vraca oktalni niz
smesta ostatak u niz
prvih 10 su mogli ici pod default vrednosti ali je ovako preglednije
menjanje boje
ispisivanje linije
provera i eventualna zamena ukoliko je OD vece od DO
funkcija koja vrsi izracunavanje i prikaz fib . niza
ucitavanje broja m
funkcija koja radi izracunavanje
dodaj na sumu kvadrat neparnog broja
Primer : Program za sortiranje niza u neopadajucem redosledu . Niz se unosi sa tastature .
unos broja sa tastature
izracunavanje srednje temperature za celu godinu
Primer : Program za izracunavanje i prikazivanje prosecne vrednosti clanova niza i daje izvestaj koji clanovi niza su manji od izracunatog proseka . Niz brojeva se unosi sa tastature
zbiru se dodaje cifra koja oznacava stotine
zbiru se dodaje cifra koja oznacava desetice
"Primer : Program za izracunavanje povrsine trougla , ako su unete sve tri stranice ( uz upotrebu funkcija )"
Ispis rastojanja izmedju tacaka
Izracunavanje poluobima trougla
Ispis povrsine trougla
WinApi header za promenu boje
definise vrednost za PI
Ucitavanje vrednosti za korak
ispis prozirne linije
"koriscen je uslov < 90.01 , a ne < 90 zbog racunanja sa double vrednostima , a ne sa int vrednostima"
Uvecanje x za zadati korak
pomocna promenljiva temp postavljena je na dva
"ako nije , onda program nece ni ulaziti u while petlju"
dodela vrednosti odgovarajucem clanu niza
temp se inkrementira uvek kada je niz [ i ] = niz [ i-1 ] + niz [ i-2 ]
"poruka korisniku , koja se stampa ako je temp = duzina"
"deklarisanje funkcije , koja vraca celobrojni rezultat"
alokacija potrebne memorije
unos dodatnog clana sa tastature
alokacija dodatne memorije
unos sa tastature
unos elemenata matrice sa tastature
poziv fukcije za izracunavanje broja polozenih na ispitu
poziv fukcije za izracunavanje proseka polozenih
ako je korisnik uneo bilo sta osim malog ili velikog slova Y ili N
promenljiva ' j ' je pomocna i koristi se u svim ' for ' petljama
selekcija ' if ' odredjuje tok izvrsavanja programa u slucaju ispravnog odgovora zavisno da li je korisnik odgovorio sa Y ili sa N
ispisuje 52 puta dati karakter u istom redu
"sada sledi niz naredbi ' printf ' , namenjenih za formiranje i ispisivanje okvira tabele pri tome se koristi karakter , koji je u prosirenoj ASCII tabeli oznacen brojem 178"
u slucaju da je korisnik odgovorio sa ' N ' ili ' n '
"ova ' for ' petlja sluzi za ispisivanje brojeva 128 - 255 i , njima odgovarajucih , karaktera ima ukupno 32 iteracije , jer tabela treba da ima 4 kolone sa po 32 clana 4 * 32 = 128 to je ukupan broj dodatnih znakova ovde se koristi pomocna promenljiva ' k ' pri svemu ovome , vodi se racuna i o stampanju granica tabele ( koristi se karakter 178 )"
funkcija za rotiranje za jedno mesto
prikaz 10 prvih znakova datog stringa
prikaz 7 poslednjih znakova datog stringa
stampanje sortiranog niza
stampanje duzina sortiranog niza
Primer : Program koji iz datog stringa izdvaja samo slova . Funkcija vraca pokazivac na novokreirani niz .
"trebaju nam dve celobrojne promenljive , suma je na pocetku jednaka nuli"
odredjujemo da li su uneti brojevi u datom opsegu
alokacija memorije
oslobadjanje memorije
unos elementa matrice
"funkcija za izracunavanje broja elemenata , koji su jednaki aritmetickoj sredini svojih suseda"
"temp – za racunanje broja trazenih elemenata , broj – za broj suseda datog elementa"
da li postoji red iznad
da li postoji kolona desno
Primer : Program koji izracunava broj i ispisuje pozicije elemenata matrice realnih brojeva ( tipa float ) koji su jednaki aritmetickoj sredini svojih suseda ( maksimalno 8 suseda )
upis broja kolona
poziv funkcije ispisRezultata ( )
ove tri promenljive sluze za smestanje ukupnog dnevnog radnog vremena za svakog pojedinca
izracunavanje rezultata preko poziva funkcije racunaj ( )
"s – broj sala , st – broj studenata"
unos broja sala i broja studenata
provera da li je alokacija uspela
"Primer : Program za rasporedjivanje studenata po salama za polaganje ispita . Na pocetku programa treba ucitati broj sala , broj studenata i broj mesta u svakoj od sala . Sale treba popunjavati redom , pocev od onih sa najvecim brojem mesta . Na kraju treba ispisati redne brojeve onih sala , koje ce se koristiti za polaganje ispita ."
pretpostavka je da ce bar jedan student polagati
pravljenje pokazivaca f na fajl
visestruka selekcija za uneti izbor
pokazivac f pokazuje na fajl podaci . txt za citanje
"Ukoliko otvaranje nije uspelo , fopen vraca NULL , prijavljujemo gresku i zavrsavamo program"
Zatvaramo datoteku
poruka korisniku za unos stringova
Pozivamo funkciju tako sto joj saljemo dva broja ( 5 i 2 ) I adrese promenljivih div i mod na koje ce se postaviti rezultati
Primer : Funkcija vraca dve vrednosti-kolicnik i ostatak dva data broja . Ovo se postize tako sto se funkciji predaju vrednosti dva broja ( x i y ) koji se dele i adrese dve promenljive na koje ce se smestiti rezultat .
int * pt = & t [ 0 ] ;
Izracunavanje krajnje isplate penzije na mesecnom nivou
Poziv sistemske pauze i brisanja prethodnog sadrzaja sa ekrana
"Primer : Program za izracunavanje penzija prema privatnom penzionom fondu . Korisnik unosi godine uplate , godine isplate godisnju stopu prinosa i mesecnu sumu koju uplacuje . Program za unete vrednosti izracunava krajnju akumuliranu sumu i krajnju sumu isplate mesecne penzije ."
"U koliko je uneta pogresna vrednost , poruka korisniku o gresci"
Poruka korisniku o unosu godisnjeg trajanja isplate penzije
Maksimalni broj artikala
Ucitava podatke o jednom artiklu iz date datoteke . Vraca da li su podaci uspesno procitani
Otvaramo datoteku i proveravamo da li smo uspeli
Ispitavanje da li je doslo do prekoracenja broja radnih sati i obracun plate sa povisicom u zavisnosti od sati dodatnog rada
"inicijalizacija , broj trenutno ucitanih igraca i broj bodova"
najbolji igrac na turniru
ucitavanje igraca iz fajla
Ispis obracuna kredita
Izbor kdedita br. 2
Ispis obracuna podataka
Poruka korisniku o banci br. 2-RAIFFAEISEN BANK
stampa
"Program na koji iz datoteke igraci . txt č  ita podatke o igrač  ima na svetskom prvenstvu u fudbalu , pronalazi igrač  a sa najvećim brojem ostvarenih poena , na standardnom izlazu ispisuje ime tog igrač  a i broj ostvarenih poena . Smatra se da datoteka igraci . txt postoji ."
igrac svakako dobije bod
igrac dobija dodatni bod ako je igrao preko 200 min
azuriranje maksimalnog broja bodova
Petlja koja ucitava podatke iz fajla i broji njihov ukupan broj
Petlja koja tabelarno ispisuje podatke o igracu
Unosenje cetiri celobrojnih vrednosti
funkcija ceo_br iyracunava manji broj od r1 i r2 i smesta u promenljivu rezultat
"Primer : Program koji na standardnom ulazu prima cetiri celobrojne vrednosti i vraca najmanju unetu vrednost pozivajuci funkciju koja uzima dve celobrojne vrednosti , poredi ih i vraca vrednost manje ."
uvecavanje clana niza
ostatak pri deljenju krajnje sume po modulu 11
kontrolni broj je 0
poruka korisniku o unosu maticnog broja
"provera , ako je kontrolni broj jednak poslednjoj cifri jmbg"
poruka korisniku o tacnosti jmbg
poruka korisniku o gresci prilikom unosa jmbg
promenljiva ' c ' predstavlja ostatak pri deljenju krajnje sume po modulu 10
"provera , u koliko nema ostatka pri deljenju kontrolni broj je 0"
"u koliko ima ostatka , od broja 10 se oduzima broj ostatka i dobijeni broj predstavlja kontrolni"
funkcija koja izracunava kontrolni broj
unos vrednosti potrebnih za proracune
racunanje predjenog puta preko duplog poziva funkcije
upis u izlazni fajl outf
"Primer : Program koji šifrira sadržaj iz fajla test . dat ( formiran od velikih slova alfabeta ) , šifriran sadržaj upisuje u fajl sifra . dat . Znak se šifrira tako što se zamenjuje sledećim ASCII znakom . Znak Z se zamenjuje sa znakom A."
Primer : Program koji iz datog fajla “ ulaz . txt ” čita reči i određuje prosečan broj slova u rečima parne dužine .
provera uslova da li je n jednako 1
prototip funkcija
funkcija za unos elemenata niza
Uvecava se golbalna promenljiva a
Umanjuje se lokalna promenljiva a. Globalna promenljiva zadrzava svoju vrednost
racunanje duzine visine bocne strane
unos vrednosti H
racunanje duzine visine bocne strane trostrane pravilne piramide
Kraj bloka naredbe za stepen
Ispitivanje tacnosti unosa za trazene vrednosti Xmin i Xmax
u promenljivu a stavljamo vrednost prvog elementa niza preko pointera * p_fniz
ispisivanje znakovnog niza preko pointera
"funkcija , brzina nekog tela po formuli : v =* a*t + b*sin ( c*t )"
Celobrojno deljenje - rezultat je 2
"Iako je c float , vrsi se celobrojno deljenje jer su i a i b celi"
vece
razlicito
Lenjo izracunavanje : kako 3 nije vece od 5 to se vrednost drugog poredjenja nece racunati jer je netacno u konjunkciji sa proizvoljnim izrazom sigurno netacno .
isto sto i a = a + KORAK ;
Definicija simbolickih konstanti preko #define direktiva
x ce biti jednako tri
ekvivalentno prethodnom
Obratiti paznju na raspored zagrada
Koristi se int a ne char zato sto zelimo da razlikujemo kraj ulaza od vazecih znakova
Ucitava se prvi znak sa ulaza
brojac linija
brojac horizontalnih tabulatora
For petlja mora da ima telo pa makar ono bilo przno
tekuci znak sa ulaza
UOCITI : blok naredbi while ciklusa NIJE OGRADJEN viticastim zagradama jer postoji samo jedna if naredba !
Kraci nacin da se postigne prethodno
Ispis niske s koristeci funkciju printf
Prva vrsta sadrzi brojeve od 1 do 10
Ilustruje vidljivost imena
Izlaz : Zdravo Zdravo svima 4 5 0 5 2 -1
Broj bitova tipa unsigned
Pozicije brojimo kao u sledecem primeru : poz : . 10 9 8 7 6 5 4 3 2 1 0 bit : . 0 0 0 1 1 1 0 0 1 1 0
Maska 0.01 - poslednjih n jedinica
Brisemo n bitova pocevsi od pozicije p
Upisujemo bitove broja y u broj x i vracamo rezultat
Maska 01.110 - n jedinica pocevsi od pozicije p
Invertujemo koristeci ekskluzivnu disjunkciju
Funkcija obrce binarni zapis neoznacenog broja x tako sto bitove cita unatrag
Postupak se ponavlja n puta
Funkcija proverava da li se dati element x nalazi u datom nizu celih brojeva . Funkcija vraca poziciju u nizu na kojoj je x pronadjen odnosno -1 ukoliko elementa nema .
Binarna pretraga niza celih brojeva - iterativna verzija
! VAZNO ! Pretpostavka je da je niz a uredjen po velicini
"Pretrazujemo interval [ l , d ]"
Element je nadjen
itoa : konvertuje broj n u niz karaktera s
"reverse : obrce string , npr string "" 1234 "" postaje "" 4321 """
izbaci cifru iz zapisa
Obradjuju se karakteri sve dok su to validne cifre
Racuna se vrednost broja dok se ne naidje na tacku
Racuna se vrednost broja iza tacke
Preskace se jedno mesto ukoliko je bio upisan znak u broj
Deklaracija celog broja
Jovan Krstevski NRT-86 / 17
Izračunavanje datog binomnog koeficijenta .
Redni broj dana u nedelji .
Broj dana u mesecu .
Dodavanje celog broja .
Skraćeno ime dana .
Pisanje datuma .
Transponovana matrica
Zbir matrica .
Razlika matrica .
Proizvod matrica .
dinniz . h
Ispisivanje dinamičkog niza .
Struktura dinamičkog niza .
Čitanje dinamičkog niza .
Izračunavanje exp ( x ) pomoću Tejlorovog razvoja .
ekspon . c
Apsolutna greška .
fibo . c
Rekurzivno :
Iterativno :
Gausova eliminaciona metoda .
memorije :
Čitanje reda sistema jednačina :
Kraj ako je dužina imena nula .
grafik1 . c
grafik3 . c
Ispitivanje funkcije grafik .
izost1 . c
izost2 . c
Izračunavanje zbira uzastopnih prirodnih brojeva .
izraz2 . c
Izračunavanje proizvoda uzastopnih prirodnih brojeva .
Izračunavanje zbira faktorijela .
izraz3 . c
for ( int i = 1 ; i < = n ; s + =( f * = i ++ )) ;
Struktura kompleksnog broja .
krug . c
Koeficijenti jednačine .
Imaginarni delovi korena .
Pretraživanje lavirinta .
Korak udesno .
Ispisivanje lavirinta .
Izostavljanje svakog pojavljivanja .
Ispisivanje liste .
Dodavanje na kraj .
Definicije paketa funkcija za obradu listi ( iterativno ) .
Definicije paketa funkcija za obradu listi ( rekurzivno ) .
Dodavanje iza poslednjeg elem .
Dodavanje ispred tekućeg elem .
Stvaranje prazne liste .
Pomeranje na prvi element .
Pomeranje na sledeći element .
uz čuvanje redosleda brojeva :
Određivanje dužine liste :
Ispisivanje liste :
Glava liste .
Obrada relativne binarne datoteke .
magacin . c
magpisi . c
Stvaranje početne datoteke .
Uređivanje kolona po veličinama zbirova :
matrica2 . c
min3 . c
minim . c
minimt2 . c
Najveći zajednički delilac i najmanji zajednički sadržalac dva broja .
Ispitivanje funkcije obrni .
Funkcija za prigušene oscilacije .
Iterativno - generiše samo sledeću permutaciju .
Primer obrade jedne permutacije .
Koeficijenti i red polinoma .
dan
premesti . c
Glavna funkcija za prikazivanje rada prethodnih funkcija .
do kraja reda
Čitanje brojeva za traženje :
Sekvencijalno pretraživanje . ( neuređen niz )
". i je novo mesto , idi dalje ."
Početno i krajnje mesto .
razmak1 . c
Stavljanje broja u red .
Stvaranje novog reda :
red2 . c
Definicije paketa za redove neograničenog kapaciteta .
Stvaranje reda .
redosled . c
reduk . c
Deklaracije paketa za obradu relativnih datoteka .
Broj zapisa u datoteci .
Stvaranje nove datoteke .
Dužina zapisa .
Struktura zapisa u datoteci =
Brisanje zapisa =
Promena cene artikala =
Promena količine artikala u skladištu =
Ispisivanje poruke o grešci =
Glavna funkcija =
Obrada sekvencijalne binarne datoteke .
Rekurzivna funkcija za računanje skalarnog proizvoda dva vektora .
Unija dva skupa :
Čitanje podataka :
Srednja dužina reči u tekstualnoj datoteci
srduzrec . c
srvred2 . c
stablo . c
Definicije paketa za obradu binarnih stabala .
Dodavanje u neuređeno stablo .
Zbir brojeva u stablu .
Čitanje uređenog stabla .
Postfiksno ispisivanje .
Broj pojavljivanja u neuređenom stablu :
Zbir elemenata stabla :
Primena operacije na stablo za svaki pročitani broj :
Stavljanje broja na stek .
Ispisivanje sadržaja steka .
Stvaranje novog steka :
Ispitivanje paketa za stekove neograničenog kapaciteta .
stek2t . c
Određivanje datuma sutrašnjeg dana .
Obrazovanje datuma za sledeći dan :
tabela2 . c
taboscil . c
Tabeliranje polinoma .
tabpoli . c
tekst . c
= Učitavanje sledćeg znaka =
- Pregled potprograma -
- Globalne promenljive -
Izlazni bafer za jedan red .
Broj znakova u izlaznom redu .
Stek za vraćene znakove .
Sledi komanda .
. i salji red na izlaz .
Početna dužina jednog reda .
Dodatni broj razmaka .
Transponovanje kvadratne matrice .
Transponovanje matrice .
trougao . c
Površina trougla :
Stvaranje i ispisivanje niza :
Uređivanje niza :
Metoda izbora ( Selection Sort ) .
Broj ponavljanja .
Duzine nizova .
Ispitivanje algoritama uređivanja .
Deklaracije paketa za obradu velikih celih brojeva .
velceo . h
Tip za logičke podatke .
Izračunavanje vrednosti verižnog razlomka
zbir1 . c
zbir2 . c
Brojanje slova i cifara .
srpski
engleski prevod
"printf ( "" wvalue = % s , rvalue = % s , fvalue = % s , ovalue = % s "" , wvalue , rvalue , fvalue , ovalue ) ;"
JPEG - JFIF Compliant ; izlaz konvertovan u PNG
Ovaj program koristi prethodno instaliranu FreeImage biblioteku . http://freeimage.sourceforge.net/
default value
Umesto da svaki put kad otvaramo fajl pišemo 5 linija koda :
"Umesto da svaki put kad otvaramo fajl pišemo 5 linija koda : p = fopen ( "" ime fajla "" , "" r "" ) ; if ( ! p ) { perror ( "" ime fajla "" ) ; exit ( 1 ) ; } možemo u samo jednoj liniji napisati : ASSIGN ( p , "" ime fajla "" , "" r "" ) ;"
Ovaj fscanf čita maks . 30 znakova ili do prvog ] i pamti u ` name `
Umesto unsigned još bolje size_t iz < stdlib . h >
Ne treba sizeof ( char ) jer je to uvek 1
Unos boje se može bolje uraditi ovako ( u tom slučaju solve prima 2 × Board ) :
Ne mora se čuvati redni broj jer je sam indeks škole u nizu redni broj
stavlja čvor N na glavu liste L. Vraća pokazivač na glavu liste
pronalazi i vraća čvor stabla u kojem je string str. Ako ne može naći string str vraća NULL
zatvori datoteku
Deklaracije varijabli
"Otvori datoteku "" dat . txt “ za čitanje"
kraj niza detektira se sa NULL stringom
a ) unos
Odredi najmanji element u x [ i. . n-1 ] .
pretpostavi da je to x [ i ]
zapamti njegov indeks
kopiraj x u string u čvoru
broj alociranih čvorova
vrati sebe kao novi početak liste
ako lista nije prazna onda se novi čvor vezuje na početak liste
alociraj memoriju za string u čvoru
vrati privremeno spremljeni drugi član liste kao glavu
"privremeno spremi drugi član liste , prije dealokacije"
ako je stablo prazno vrati čvor kao novo stablo
stavi čvor N kao desnu granu
ako je veći onda uđi u desnu granu priručnog čvora i ponovi petlju
petlja koja se ponavlja sve dok se ne dođe do lista stabla
uzima vrijednost člana
ako je lista prazna izlazi i vraća nulu
mjenja da je posljednji član u stvari predposljednji
dealokacija stabla
"otvaranje datoteke za pisanje , uz provjeru ispravnosti"
zatvaranje datoteke
varijabla prekid služi da se premosti višekratno uzastopno ponavljanje znakova prekida riječi
otvaranje datoteke za pisanje
ispis stringova obrnutim redoslijedom
otvaranje datoteke uz provjeru uspješnosti
čitanje vrijednosti završava na kraju datoteke
alokacija memorije za novog člana liste - tmplist
currlist nam služi za šetanje po listi
provjera je li pL glava liste
je li x u ovom članu liste
upisivanje imena u novi član stoga
ako stog ima više članova onda pomoću tmpL prošetaj do kraja stoga
alokacija stringa putem kojeg će se vratiti tekst iz izbrisanog čvora
pomoću tmpL se šeta do kraja liste
tekst se kopira u string tmp
dealokacija zadnjeg člana
ispisujem zadnji član
"izbacujem član sa tekstom "" kraj """
ispisujem i izbacujem članove
ako je ključ manji od ključa x idem u livu granu
ako je ključ veći od ključa x idem u desnu granu
"ponavlja se sve dok string nije "" kraj """
"ako je string "" kraj "" onda izlazak iz programa"
stvaranje glave liste i ubacivanje prvog stringa u glavu
ispis svih vrijednosti iz reda
smještam učitani broj na stog
ispis vrijednosti izbacivanjem iz stoga
tip fajla
prava pristupa
"greska ( unlink ( srcPath ) ! = -1 , "" unlink failed "" ) ;"
"fprintf ( stderr , "" dname : % s , ind : % d "" , entry -> d_name , ind ) ;"
pisem iz bafera na stdout
"printf ( "" % d "" , status ) ;"
da li je drugi proces otvorio pajp ?
citanje je blok operacija
3.16 U ZBIRCI //
3.20 U ZBIRCI //
"ucitava broj i ispisuje da li je veci , manji ili jednak nuli"
od veceg broja oduzima manji
ucitava tri broja i ispisuje najmanji
za ucitani n ispisuje n !
"ispisuje sumu troznamenkastih brojeva djeljivih sa 17 i njihov broj , koristeci while"
"ispisuje sumu svakog 3. od n ucitanih brojeva , pomocu while"
ucitavanje elemenata polja
pretrazivanje polja
string4 . cpp
string8 . cpp
ispisuje rijeci u slijedeci red
provjerava da li je ucitani string palindrom
izbacuje razmake
ucitava dva kompleksna broja i ispisuje njihovu sumu i razliku
formiranje niza bez maks sume
Autor : Danijel Jovanovic CharSet : UTF-8 Date : 21.10.2019.
break prekida izvrasavanje while ( )
Postavljamo zavrsni znak
26
Broje se svi karakteri !
Prototup funkcije faktorijel ( )
Može se izostaviti jer je tip povratne vrednosti naše funkcije void
Glavna ( main ) funkcija
n = odredjivanjeBrojaElemenataNiza ( ) ;
"Dok ovo radi , bez problema"
"printf ( "" % d "" , n ) ;"
Funkcija koja ispisuje jedan znak na ekran
char string [ 10 ] ;
Premala veličina za string !
Program koji ispisuje brojeve od 1 do n Pomoću for petlje
Krećemo od k-te pozicije i redom vršimo
Rotiranje elemenata niza ulevo za jedno mesto
Deklaracija celobrojnog niza od 50 elemenata
Zaštita od unosa pogrešnog broja
Definisanje konstante pomoću pretprocesorske direktive
Definisanje konstante pomoću naredbe const
/ Niz za cuvanje najveceg elementa iz vrste
Pretpostavljamo da je trenutni najmanji element na prvoj poziciji
Ako je trenutni element veći od max
"printf ( "" Unesite niz [ % f ] = "" , i ) ;"
POŠTO je i ceo broj konverzija je druga
neparnim indeksom . Prikazati sumu .
Prikazati novonastali niz .
4. Inicijalizovati celobrojni niz od 7 elementa . Sabrati sve elemente niza .
Rezultat prikazati na konzoli .
Sabiranje elemeneta
Ucitavanje elemenata niza
Jer koristimo funkciju sqrt (.)
Računanje proizvoda
Inicijalizovati niz realnih brojeva od 6 elementara . Izračunati proizvod unetih brojeva . Rezultat prikazati na konzoli .
Ucitavanje promenljive broj
Zavrsetak Do while ( ) ; petlje
Poruka korisniku da unese vrednost za dati element niza
Dodeljivanje vrednosti broj u promenljivu na mestu k
Promenljiva u kojoj čuvamo veličinu niza
Broj elemenata u nizu ne može biti negativan ili veći od maksimuma
Mora da se inicjalizuje sa nulom
Dodaj neparan element u sumu
"1. Inicijalizovati niz Y od 3 realna broja , float Y [ 3 ] = { 5.55 , 6.66 , 7.77 } ; Svaki element uvećati za dva puta i prikazati taj niz nakon uvećanja na ekran ."
uvecavanje 2 puta
ispis uvevcanog elementa
MORA PROIZVOD = 1 jer je 1 neutralan clan mnozenja
15. Za uneti niz od n elemenata realnog tipa odrediti proizvod elemenata u nizu .
"2. Inicijalizovati niz koji se sastoji od sledećih vrednosti { 1 , 5 , 6 , 9 , 12 , 15 , 7 , 3 } . Prikazati sve elemente niza na ekran ."
4. Za uneti niz od n elemenata realnog tipa float izračunati sumu svih elemenata elemenata u nizu i prikazati sumu na ekran .
c = broj1 ;
Ova naredba neće proći kompajliranje
Ako je broj pronadjen prekida se for petlja tj. dalja pretraga niza !
Cuvamo poslednji element u nizu jer ce biti prepisan !
"Drugom i pretposlednjem , i tako redom"
Smanjujemo velicinu niza za 1 manje element koji smo izbacili
Parametre prosleđujemo po vrednosti
10 proizvoda
da li je uneti znak malo ili veliko slovo
max je 100 proizvoda / artikala
Pretprocesorska direktiva
Koristimo za ponavljanje naredbe 5 puta
Ispis na konzolu
Računanje površine pravougaonika
Računanje obima pravougaonika
Racunanje obima kruga
Racunanje povrsine krugs
Ispis obima kruga na konzolu
Matematicka C biblioteka
Racunamo tako sto izracunamo koliko na mesecnom nivou dobijemo novca za datu kamatnu stopu i to sve puta 12 meseci
Ucitavamo dan u promenljivu
Naredba Višestrukog granjanja switch ( )
Prosleđujemo adresu prvog pokazivača pomoću operatora &
Znak < ili > određuje da li sortiramo rastuće ili opadajuće
Funkcija koja spaja 2 stringa
U kom se prstenu nalazimo
Kolona desno
Upis u centralno polje
Ako su stringovi jednaki funkcija strcmp ( ) vraća 0 Ako nisu jednaki vraća broj različit od 0
Biblioteka za rad sa stringovima
izmena podataka
upis u datoteku !
kopija originala zbog ispisa
Upis
niz od 10 nagrada
UCITAVANJE KRAJ
za rotiranje udesno
cuvanje matrice znakova
"Zašto [ i ] , zato jer brojač for petlje iterira ( uvećava se ) Od 0 pa do n - 1 ( u ovom slučaju 10 ) A mi moramo da redom učitavamo elemente niza brojevi [ 0 ] , brojevi [ 1 ] , . , brojevi [ 9 ]"
Uvek mora biti int !
Da li imamo dovoljno mesta u nizu za novi element
Pomeranje elemenata udesno za jedno mesto
Na k-tu poziciju upiši broj koji je korisnik Uneo ranije u programu
Nijedan od prethodnih uslova nije ispunjen i izvršava se else deo
Dimenzije kolaca
/ PRVI ZNAK
Kraj test scenarija za biblioteku formiranjeNiza . h
Test scenario za biblioteku pretrazivanjeNiza . h
Sortiranje elemenata niza
Test scenario za biblioteku izbacivanjeElementaIzNiza . h
Glavna funkcija
A C program which demonstrates string reversering
BUG : Ako se unese nesto sto nije broj program puca !
POZICIJA - 1 JER INDEKSI NIZA IDU U INTERVALU OD 0 DO N - 1 !!
PROVERA
KRAJ IGRE
RACUNANJE RACUNA
PEKARSKI HLEB
ucitavanje niza b
unos niza od 10 elemenata
"PROGRAM KOJI UCITAVA DVA NIZA , PRVI NIZ SE SASTOJI OD 10 ELEMENATA , A DRUGI NIZ OD 5 ELEMENATA . POZIV FUNKCIJE UMETNI ( ) UBACUJE NIZ B NA K-TI INDEX U NIZU A I PRIKAZUJE NIZ A SA UMETNUTIM NIZOM B"
PROGRAM PRIKAZUJE VREDNOST fibonaci ( 10 ) FIBONACIJEVOG NIZA POMOCU REKURZIVNE FUNKCIJE
"PROGRAM UCITAVA NIZ OD N ELEMENATA , ZATIM SE KORISNIK PITA DA UNESE INDEKS ELEMENTA KOJI BI DA PRIKAZE . ZATIM POKAZIVAC VEZUJEMO ZA NIZ [ K ] I PRIKAZUJEMO VREDNOST ELEMENTA NA KOJI POKAZIVAC POKAZUJE"
PROGRAM DEFINISE JEDAN REALNI NIZ OD 6 ELEMENATA . ZATIM VEZUJEMO POKAZIVAC NA NIZ [ 5 ] ( POSLEDNJI ELEMENT U NIZU ) I PRIKAZUJEMO VREDNOST NA KOJU ON POKAZUJE
vezujemo pok na poslednji element niza
PROGTAM UCITAVA CELOBROJNI NIZ OD 15 ELEMENATA . ZATIM SE NIZ SORTIRA OPADAJUCE . SORTIRARANJE SE VRSI BEZ FUNKCIJE
PROGRAM DEFINISE JEDAN REALNI NIZ OD 6 ELEMENATA . ZATIM VEZUJEMO POKAZIVAC NA PRVI ELEMENT U NIZU I PRIKAZUJEMO VREDNOST NA KOJU ON POKAZUJE
PROGRAM POMOCU REKURZIVNE FUNKCIJE IPSISUJE JEDAN CEO BROJ PO CIFRAMA S LEVA UDESNO
Zadatak 40 : Napisati funkcije koje računaju obim i površinu pravouganika . Parametri obe funkcije su stranice pravougaonika koje unosi korisnik i koje se prosleđuju u pozivu funkcije .
Zadatak 42 : Napisati funkciju koja računa zapreminu kocke . Parametar funkcije je ivica kocke koju unosi korisnik i koja se prosleđuje u pozivu funkcije .
ne menjaju se vrednosti
"Zadatak 45 : Napisati program koji prikazuje PRENOS PARAMETARA PO ADRESI . Program realizovati pomoću funkcije koja koristi svojstvo prenosa parametara po adresi , tj. u njenom pozivu u main ( ) funciji prosleđene su dve adrese promenljivih . Unutar funkcije promeniti vrednosti prosleđenih promenljivih . Koje su vrednosti promenljivih nakon izvršavanja funkcije ?"
Zadatak 35 : Napisati funkciju koja računa zbir kvadrata brojeva od 1 do N. Broj N unosi korisnik i on se prosleđuje u pozivu funkcije kao njen parametar .
Zadatak 47 : Napisati funkciju void izmeni ( int * broj ) koja za parametar ima adresu jedne celobrojne promenljive . Uvećati vrednost te promenljive za 150. Prikazati vrednost promenljive pre i posle poziva funkcije izmeni ( ) u glavnom programu .
Zadatak 37 : Napisati funkciju koja računa proizvod brojeva od od 1 do N. Broj N unosi korisnik i on se prosleđuje u pozivu funkcije kao njen parametar .
"PITANJE : Sta je ugaona konstanta , dobija se kao 180 / broj impulsa za rotaciju .?"
Moras da ih deklarises sa extern u onom . c fajlu u kome zelis da ih koristis .
"TIM_Cmd ( TIM2 , ENABLE ) ;"
if ( ! input_limit_switch_X1 ) {
else task_pid_X . state = 99 ;
sta kad se ugasi ?
if ( speed_current_YARR = 1 + ( int ) ( 100 / speed_current_Y ) ; } else { TIM4 -> ARR = 1 + ( int ) ( 100 / maximum_speed_Y ) ; } ;
"absPosition calculatePosition ( int Left , int Right ) { static long X = 0 , Y = 0 ; static float Theta = 0 ; static unsigned long formerLeft = 32767 , formerRight = 32767 ; absPosition temp ; int D , dRight , dLeft ; float dTheta ; dLeft =( int ) ( Left-formerLeft ) ; dRight =( int ) ( Right-formerRight ) ; D =( dLeft + dRight ) / 2 ; dTheta =( float ) ( angularConstant * ( dLeft-dRight )) ; Theta + = dTheta ; X + =( int ) (( float ) ( D*sin ( Theta*PI / 180 ) ; Y + =( int ) (( float ) ( D*cos ( Theta*PI / 180 ) ; temp. x = X ; temp. y = Y ; temp. theta =( int ) ( Theta )) > = 0 ? 0 : 360 ) + (( int ) ( Theta )) % 360 ; formerLeft = Left ; formerRight = Right ; return temp ; }"
file ( startup_stm32f10x_xx . s ) .
PITATI JOVICICA
"brzina = Speed_profile_Y ( Pos2 , ENC2 ) ;"
"USART_SendData ( USART3 , err ) ;"
"USART_SendData ( USART3 , (( brzina == 0 ) ? 43 : 91 )) ;"
anglePID = anglePID < 180 ? anglePID :( anglePID-360 ) ;
Propac =( float ) ( Kac * ( deltaAngle > 10 ? deltaAngle : 0 )) ;
if (( greska > -4 ) && ( greska < 4 ) && ( Int1 > 0 )) Int1 = Int1-4*Ki ;
if (( greska == 0 ) && ( speed_current_X == 0 )) { Reg = 0 ; Int1 = 0 ; }
if ( Reg <- 90 ) Reg = -90 ;
"swap ( A [ i ] , A [ i + 1 ] ) ;"
POGRESNO
ucenik osnovni podaci
uceknik podaci rodjenje
podaci razrednik
GET : api / Categories
POST : api / Categories
GET : api / Comments
GET : api / Comments / 5
GET : api / Manufacturers
PUT : api / Manufacturers / 5
GET : api / OrderDetails
PUT : api / Orders / 5
PUT : api / Products / 5
GET : api / Roles
POST : api / Roles
PUT : api / Roles / 5
POST : api / Users
SERIJALIZACIJA / DESERIJALIZACIJA IZ DATOTEKE
podesavanje na Light temu
Bez ovoga COMMAND Save u XAML-u nece da radi
Bez ovoga COMMAND Open u XAML-u nece da radi
ovo bas i nije najsigurniji nacin da se cuva passworda al ajd sad
omogucava da se prozor pomera tako sto se drzi levi klik na prozoru
< auto-generated > This code was generated by a tool . Runtime Version : 4.0.30319.420 Changes to this file may cause incorrect behavior and will be lost if the code is regenerated . < / auto-generated >
Meni
Modalni prozor
KeyPress za HELP tj. dokumentaciju
uzimanje pozicije ako smije
uzeti adresu na osnovu GeoTacke
pokretanja taska citanja
Konfiguracioni fajl radi laksih naknadnih izmjena mogu se i ostale opcije po potrebi Baud rate etc .
ucitavanje json konfiguracija radi laksih izmjena
"rfidConfig = JsonValue . Parse ( File . ReadAllText ( "" RfidConfig . json "" )) . GetObject ( ) ;"
"rfidConfig . GetNamedString ( "" port "" ) ;"
"najosjetljivija metoda , vraca null ako nesto nije uredu to moze biti da nije capability naveden u manifestu , da device ne prepoznaje ili da je device zauzet od druge aplikacije da je user blokirao ili sistem moze biti null iako je nadjen device information"
cita iz streama
Moze se u output printati exception ako zatreba u nekim situacijama
ALI OBAVEZNO KORISTITI DEBUGGER
prvo provjeri jel dobro unesen stari password
"string VerifikacijaPoruka = """" ;"
DataContext = new MyMovieCollection . ViewModels . PocetnaViewModel ( ) ;
implementirati validaciju
"< seealso cref = "" mrs . ApplicationCore . Interfaces . IAsyncRepository { mrs . ApplicationCore . Entities . Remark } "" / >"
"< seealso cref = "" mrs . ApplicationCore . Interfaces . IRepository { mrs . ApplicationCore . Entities . Screening } "" / >"
"< seealso cref = "" mrs . ApplicationCore . Interfaces . IRepository { mrs . ApplicationCore . Entities . SeatReservation } "" / >"
POST : PropAds / Edit / 5
GET : PropAds
GET : PropAds / Create
POST : PropAds / Create
"To protect from overposting attacks , please enable the specific properties you want to bind to , for more details see http://go.microsoft.com/fwlink/?LinkId=317598 ."
GET :/ Reservation / Delete / 5
POST :/ Reservation / Delete / 5
"else { ViewBag . Message ( "" Ne mozete otkazati za manje od 30 minuta pre projekcije ! "" ) ; }"
GET : ThematicProps / Delete / 5
POST : ThematicProps / Delete / 5
GET : ThematicProps
GET : ThematicProps / Create
POST : ThematicProps / Create
GET : ThematicProps / Edit / 5
ovde smestamo listu ikona ;
otvaramo tabelu
pravimo i string za boju i ujedno je trazimo kada trazimo tip
TODO 1 : ukoliko postoji ikona
svakako iz ove tabele vucemo boju
fokus na prvo
inicijalizacija alkoholnog box-a
dodavanja vjua etiketa
ispis rezervacija
za hendikepirane
dodavanje ikone sa mape na formu
pravimo tu paintbox komponentu
"customPB p = new customPB ( name , color , ico , p ) ;"
ispisuje koju je metodu pozvao client
ovde proverava da li ima dva elementa
id ce biti dodeljen prilikom dodavanja u bazu
Mora da bi se aktivirao eventLog
Za prvi zadatak dugme se pojavi tek kad se napuni progress bar tako da uvek je uspesno zavrsen quest kada se klikne ovo dugme
"ovo treba da se uradi bolje , treba da mozemo DTO da pretvorimo u model ako hocemo ovde da ne loadujemo opet iz baze"
Vraca listu alijansi
Restrikcija koriscena samo brojeva
Pravilo ogranicenja na samo reci u okviru polja .
nasledjujem observable-object kako bi dobio on-property-change
MessageBox . Show ( _trenutniProgresKlipa . ToString ()) ;
Promenljiva u kojoj cuvam trenutno otvoreni prozor ako bih kasnije u komandama u zavisnosti od komande recimo zatvorio trenutni prozor
gasenje trenutnog prozora
regulisem da prvo povecam kolicinu novo izmenjene vrste leka
provera leka koji je korisnik menjao
selektovani objekat prima vrednosti od menjanog objekta
Koristan link : https://help.syncfusion.com/file-formats/pdf/working-with-flow-layout?cs-save-lang=1&cs-lang=csharp#working-with-table
Lek za izmenu / stimanje preuzima podatke od selektovanog leka
podesavanje prikaza dijaloga izmene
Odredjivanje koliko imamo kog leka
"<summary> Podesavam trenutnu kolicinu odredjene GRUPE LEKOVA </summary> < param name = "" lek "" > </param> < param name = "" koeficijentPravca "" > Prosledjuje se broj koji govori koliko povecavam / smanjujem odredjenog leka </param>"
potvrdjujem dodavanje podataka
potvrdjujem brisanje podataka
sada je moguca izmena profila
"kao parametar se ocekuje delegat , posto je delegat pokazivac na funkciju prosledjujem funkciju i onda se ona okida , u ovom slucaju bez uslova pod kojim se okida ali moze se proslediti i uslov pod kojim se okida"
"kao parametar se ocekuje delegat , posto je delegat pokazivac na funkciju prosledjujem funkciju i onda se ona okida , u ovom slucaju bez uslova pod kojim se okida ali moze se proslediti i uslov pod kojim se okida"
u temp upravniku cuvam trenutne podatke
Algoritam izmene prostorije : http://prntscr.com/sul6bj
dodajem prostoriju za dodavanje ukoliko je odgovor bio potvrdan
regulisem da prvo povecam kolicinu novo izmenjenog tipa prostorije
"podesiBrojOdredjenihLekova ( SelektovaniLek , -1 ) ;"
dodam ove dve nove
prvo moram uklonite ove 2 prostorije
dodajem prostoriju
Zelim da renoviranje bude prvo selektovano u radio button grupi
preuzimanje od prave opreme prostorije
prikaz dijaloga za dodavanje
Prostorija za izmenu / stimanje preuzima podatke od selektovane prostorije
ako dodjem dovde znaci da moram celu tu trenutnu opremu dodati jer je nema u spisku opreme
i kolekciji i zapravo selektovanom dodam
uklonim iz prave opreme
ako sam dosao do ovoga onda znaci da te opreme zapravo i nema u listi
"<summary> Podesavam trenutni broj odredjenog tipa prostorije . </summary> < param name = "" prostorija "" > </param> < param name = "" koeficijentPravca "" > Prosledjuje se broj koji govori koliko povecavam / smanjujem broj odredjenih prostorija </param>"
uklanjanje opreme
"TODO : Kada saznas kako dobiti koje trenutno validacione probleme ima app , ovde to mogu hendlovati"
instanciram fizicke radove selektovane prostorije
kreiram novog zaposlenog da u slucaju potvrde mogu da ga dodam u listu zaposlenih
"prikazivanje bez vremena , samo datum ovako dobijam"
dodajem sve izabrane lekare
za pomeranje slajdera vremena videa
biblioteka za cartove
uz dodatak na WPF
za kolekciju lekova
za kolekciju prostorija
u C # metode _nisu_ podrazumevano virtuelne !
preopterecenje binarnog operatora
u Javi ovo bi bila HashMap-a
u Javi ovo bi bio isto HashSet
"ovo oznacava da se klasa moze serijalizovati , nista drugo ne treba , posto joj se atributi mogu serijalizovati"
< auto-generated > This code was generated by a tool . Runtime Version : 4.0.30319.1022 Changes to this file may cause incorrect behavior and will be lost if the code is regenerated . < / auto-generated >
"da hocemo da radimo i sa precicama , trebalo bi da nasledom RoutedUICommand , recimo"
"ovde ide model-level obrada komande , tj. Deo koji ne radi sa interfejsom"
"Instanca OpenGL "" sveta "" - klase koja je zaduzena za iscrtavanje koriscenjem OpenGL-a ."
Inicijalizacija komponenti
Rukovalac dogadjaja iscrtavanja OpenGL kontrole
< auto-generated > This code was generated by a tool . Runtime Version : 4.0.30319.239 Changes to this file may cause incorrect behavior and will be lost if the code is regenerated . < / auto-generated
Izabrana strana poligona .
Izabran nacin iscrtavanja poligona .
Raspon debljina tacaka
Raspon debljina linija
Sablon isprekidanosti linija
Parametri vezani za tacke
"Ocitaj iz promenljive stanja GL_POINT_SIZE_RANGE minimalnu i maksimalnu velicinu ( min = prvi el . niza , max = drugi el . niza )"
Parametri vezani za linije
Iscrtavanje OpenGL kontrole .
"Podesi da tacka se iscrtava kao krug , a ne kao kvadrat"
<summary> Klasa koja enkapsulira OpenGL programski kod </summary>
Dispose metoda .
Destruktor .
Oslobodi managed resurse
Isprekidanost linija
razmera isprekidanosti linija
Definisanje callback delegata za belezenje poruka u toku ucitavanja podataka o sceni .
Oslobadjanje resursa koriscenih za ucitavanje podataka o sceni .
Inicijalizacija i podesavanje OpenGL parametara .
"<summary> Rekurzivna metoda zaduzena za iscrtavanje objekata u sceni koji su reprezentovani cvorovima . U zavisnosti od karakteristika objekata podesavaju se odgovarajuce promenjive stanja ( GL_LIGHTING , GL_COLOR_MATERIAL , GL_TEXTURE_2D ) . </summary> < param name = "" node "" > Cvor koji ce biti iscrtan . </param>"
Primena komponenti materijala datog objekta .
Primena teksture u slucaju da je ista definisana za dati materijal .
Klasa enkapsulira programski kod za ucitavanje modela pomocu AssimpNet biblioteke i prikazivanje modela uz uslonac na TaoFramework biblioteku .
Definisanje temena primitive .
"Primena razlicitih komponenti datog materijala ( ambijentalna , difuzna , spekularna , emisiona , sjaj ) ."
"Primena sjaja materijala . U slucaju da ista nije definisana , koristi se podrazumevana vrednost ."
Metoda za oslobadjanje resursa .
"<file> World . cs </file> <copyright> Grupa za Grafiku , Interakciju i Multimediju 2013. </copyright> <author> Srđan Mihić </author> <author> Aleksandar Josić </author>"
"Boja pozadine je bela , a boja ispisa je crna"
Klasa enkapsulira OpenGL kod i omogucava njegovo iscrtavanje i azuriranje .
Rad sa teksturama
"gl . Light ( OpenGL . GL_LIGHT0 , OpenGL . GL_AMBIENT , ambLight ) ;"
Oznaci kraj iscrtavanja
Podesava viewport i projekciju za OpenGL kontrolu .
selektuj Projection Matrix
resetuj ModelView Matrix
"Initializes a new instance of the < see cref = "" MainWindow "" / > class ."
"<file> World . cs </file> <copyright> Grupa za Grafiku , Interakciju i Multimediju 2012. </copyright> <author> Srdjan Mihic , Aleksandar Josic </author>"
BOTTOM stranica
"<copyright> Grupa za Grafiku , Interakciju i Multimediju 2012. </copyright>"
LEFT stranica
RIGHT teksturu pridruzi desnoj stranici
Kreiranje teksture .
Iscrtaj svet
Definisanje tajmera za animaciju
Ukljuci i podesi color tracking
Atribut za unosenje nasumicnosti
Podesavanje efekta magle
Boja magle = boja pozadine
magla pocinje od 5 jedinica
Iscrtavanje podloge .
Pomocni vektori preko kojih definisemo lookAt funkciju
Azurira rotaciju kamere preko pomeraja misa
Azurira poziciju kamere preko tipki tastature
Ukljuci generisanje koord . teksture
Identifikator teksture
Iscrtavanje torusa u XY ravni .
Izabrana OpenGL mehanizam za iscrtavanje .
Ugao rotacije sveta oko X ose .
Izabrani OpenGL rezim stapanja teksture sa materijalom
Nabrojani tip OpenGL rezima filtriranja tekstura
Neprozirna slika
Posto je kreirana tekstura slika nam vise ne treba
Transliraj scenu tako da se vidi unutar prozora
"Pomeranje desno , skaliranje i iscrtavanje kocke"
Model sencenja na flat ( konstantno )
Podrazumevano
Ako je izabrano back face culling ukljuci ga i obratno
Ako je izabrano testiranje dubine ukljuci ga i obratno
Naizmenicna promena boje poligona
Sacuvaj stanje ModelView matrice i primeni rotacije
"Da bismo dobili omotac a ne krug , postavljamo vrednost z koordinate na visinu kupe"
Menjaj boju trouglova naizmenicno ( zuta / plava )
Gotovo iscrtavanje omotaca kupe
"Centar osnove je u ( 0,0 )"
Specifikuj teme na osnovu izracunatog
Gotovo iscrtavanje osnove kupe
Indikator stanja mehanizma iscrtvanja poligona kao linija .
Permutacija boje poligona u zavisnosti od parnosti indeksa
"Generator slucajnih brojeva , koji sluzi za generisanje boje poligona"
private Random m_random ;
Nabrojani tip OpenGL podrzanih mehanizama iscrtavanja
Kreiraj identifikator liste
Kreiraj listu
Podesavanja za vertex buffer objects Generisi i podesi bafer za crtanje
"Neophodno je kreirati dva posebna bafer objekta ( prvi sadrzi nizove koordinata temena , a drugi indekse temena )"
Neophodno zbog vertex array-a - iskljucuje postojeci vertexpointer
Bafer sa nizom jedinstvenih temena
Bafer sa nizom indeksa temena
podesi boju za brisanje ekrana na crnu
Odabrani tip projekcije .
Trenutna udaljenost objekta po z-osi ;
perspektiva
Sacuvaj stanje modelview matrice i primeni transformacije
Primeni transformacije
Primitive preko kojih definisemo scenu
Trenutno aktivni shading model .
Maksimalno svi poligoni dele ovo teme
Odredi sve poligone koji dele ovo teme
Definisemo belu spekularnu komponentu materijala sa jakim odsjajem
Uikljuci color tracking mehanizam
Podesavanje boje za anbient i diffuse komponentu osvetljenja
Ukljucivanje rada sa vertex array ( VA ) mehanizmom
namesti pointer na nizove temena i normala
Iskljucivanje postojeceg pokazivaca na niz sa pozicijama temena i niz sa normalama
Iskljucivanje rada sa vertex array i normal array mehanizmom
Iscrtavanje aviona .
Konstanta koja opisuje sa koliko komponenti su zadate pozicije temena .
Nabrojani tip OpenGL podrzanih tipova normala
Pomeri se u tacku gde je svetlo pozicionirano i nacrtaj kupu
Crna pozadina
Ukljuci depth testing i back face culling i podesi da je front = CW
Pomeraj objekat po z-osi
Pod tunela
Desni zid tunela
Pomeraj po Z osi
Bela pozadina
Prozirna slika 25 %
Podesi nacin blending teksture
Nacrtaj piramidu
uvek je dobro pravilo da se definisu materijali s obzirom da postoji mogucnost da se ne kreira i pridruzi tekstura objektu
Osnova piramide
Menja trenutno aktivni mod za blending .
"Ocitaj iz promenljive stanja GL_POINT_SIZE_RANGE ( to se nalazi u grafickom hardveru ) minimalnu i maksimalnu velicinu ( min = prvi el . niza , max = drugi el . niza )"
"Opseg koji zavisi od nase kartice , sto je veci to je ' jaca ' graficka kartica"
Funkcija Enable nam sluzi za iskljucivanje / ukljucivanje PROMENLJIVIH STANJA
"BEGIN I END FUNKCIJE IDU U PARU I NIKAD NE MOGU ICI DISJUNKTNO , ODNOSNO JEDNO BEZ DRUGOG !"
Klasa koja enkapsulira OpenGL programski kod
"<summary> Verteksi tacaka , linija i poligona . Treca kordinata je z , koja je zapravo ovde 0 pa nema potrebe da se pise < / summary"
koristi se alfa komponenta
<para> @author : Stanislava Selena </para>
"<summary> Method implements method for comparing two objects . <para> Method is applicable only if both of given objects are instances of the same class . </para> <para> Method designed is for ProfileElement , ProfileElementStereotype and CIMObjects objects . </para> <para> This is impelemtation of IComparer interface . </para> </summary> < param name = "" modelObject1 "" > object for comparing </param> < param name = "" modelObject2 "" > object for comparing </param> <returns> </returns>"
"<summary> ModelElementComparer class is impelemntation of IComparer interface . <para> It is used for comparing two objects , and is designed for ProfileElement , ProfileElementStereotype and CIMObjects objects . </para> <para> This class can be used for sorting lists of objects . </para> </summary> < typeparam name = "" T "" > one of the : ProfileElement , ProfileElementStereotype or CIMObject class </typeparam>"
"<summary> "" http://iec.ch/TC57/2008/CIM-schema-cim13 # "" </summary>"
"<summary> "" http://iec.ch/TC57/2008/CIM-schema-cim14 # "" </summary>"
"<summary> "" http://iec.ch/TC57/2008/CIM-schema-cim15 # "" </summary>"
"<summary> "" / &gt; "" </summary>"
"<summary> "" \ "" &gt; "" </summary>"
"<summary> "" rdf : ID =\ """" </summary>"
public List <RoomsPropsViewModel> RoomsItemsList { get ; set ; }
RoomsItemsList = new List <RoomsPropsViewModel> ( ) ;
kad napravi sobu setuje mu se na true
ostao ulogovan
Ako se ne menja onda nista
Updateujemo DataContext
"throw new ArgumentNullException ( "" par "" ) ;"
"<remarks> The method should be non-static and conform to one of the supported signatures : <list> <item> <c> NotifyChanged ( string ) </c> </item> <item> <c> NotifyChanged ( params string [ ] ) </c> </item> <item> <c> NotifyChanged { T } ( Expression { Func { T }} ) </c> </item> <item> <c> NotifyChanged { T , U } ( Expression { Func { T , U }} ) </c> </item> <item> <c> SetProperty { T } ( ref T , T , string ) </c> </item> </list> </remarks>"
"<example> <code> public class Foo : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged [ NotifyPropertyChangedInvocator ] protected virtual void NotifyChanged ( string propertyName ) { . } string _name ; public string Name { get { return _name ; } set { _name = value ; NotifyChanged ( "" LastName "" ) ; / * Warning * / } } } </code> Examples of generated notifications : <list> <item> <c> NotifyChanged ( "" Property "" ) </c> </item> <item> <c> NotifyChanged (() = &gt; Property ) </c> </item> <item> <c> NotifyChanged (( VM x ) = &gt; x. Property ) </c> </item> <item> <c> SetProperty ( ref myField , value , "" Property "" ) </c> </item> </list> </example>"
<summary> Describes dependency between method input and output . </summary>
"public bool TryParse ( string s , out Person result )"
class ComponentAttribute : Attribute { }
class MyComponent : IComponent { }
"Indicates that the value of the marked element could be <c> null </c> sometimes , so the check for <c> null </c> is necessary before its usage ."
"<example> <code> [ StringFormatMethod ( "" message "" ) ] void ShowError ( string message , params object [ ] args ) { / * do something * / } void Foo ( ) { ShowError ( "" Failed : { 0 } "" ) ; // Warning : Non-existing argument in format string } </code> </example>"
"ShowError ( "" Failed : { 0 } "" ) ;"
horizontalni algoritam
nadji k-to prazno mesto
"uradi sva vertikalna skaliranja ( samo transponuj i zameni n , m )"
sta da mu radim . mora ovako
matrica slike
ubrzavac racunanja seam carvinga
"sluzi da se preuzme pocetna tacka kada se klikne negde , ista moze i za mapu i za drvo"
prikaz cvorova u drvetu
ovo sluzi za pokretanje draga sa mape
funkcija koja zapravo pokrene drag sa mape
"zbog null , ako je neko krenuo da vuce po mapi bezveze"
ovo sluzi da se prikaze da se na drvo moze spustiti objekat
"ova komplikacija je da se lokali ne mogu uzeti iz drveta i vratiti u drvo , jer je glupo"
ubacuje lokal sa drveta na mapu
"one sve f-je iznad samo menjaju mis da korisnik vidi da ne moze drop , a ako ipak drop , ovo sprecava efekat"
Ako postoji obradjivana nju izuzmi iz provere
Ako ne postoji obradjivana radi kao i do sada
"Console . WriteLine ( "" Ne postoji obradjivana ! "" ) ;"
Za onemogucavanje dodavanja
Dodato za tultip
"Console . WriteLine ( "" Obradjivana postavljena "" ) ;"
Preuzimanje parametara od ugrozene vrste
Unos i validacija
Selektovano u DataGridu
Ako brisem vrstu uklonicu je iz tipova koji je sadrze
Filtriranje
List < UgrozenaVrsta > ugrozenaVrstaSaOznakom = MainWindow . ugrozeneVrste . Where ( m = > m. Etikete . Contains ( eta )) . ToList ( ) ;
Za onemogucavanje dodavanje kada nema tipova
stanje dugmeta DOLE
stanje dugmeta LEVO
Polje za stanje dugmeta jedan
Polje za stanje dugmeta dole
Polje za stanje dugmeta minus
stanje dugmeta A
stanje dugmeta B
stanje dugmeta DVA
Stanja koja ucitamo iz fajla
Fajl iz koga citamo
stanje dioda na kontroleru
Stanje LED-a broj jedan
Stanje LED-a broj dva
Stanje LED-a broj tri
Stanje vibracije
"<summary> Konstruktor klase Reakcija </summary> < param name = "" led1 "" > stanje LED 1 </param> < param name = "" led2 "" > stanje LED 1 </param> < param name = "" led3 "" > stanje LED 1 </param> < param name = "" led4 "" > stanje LED 1 </param> < param name = "" vibracija "" > stanje vibratora </param>"
Stanje koje je snimljeno
Stanje dugmica
Stanje akcelerometra
Stanje senzora
Stanje LE Dioda i vibratora
"<summary> Klasa koja sadrzi informacije o stanju Wii kontrolera . Elementi stanja su hijerarhijski organizovani u 4 podgrupe : <br/> Dugmici , Akcelerometar , Infracrveni Senzori , LE diode i vibrator </summary>"
Metoda prekida komunikaciju sa prosledjenim WiiKontrolerom
Enumeracija tipova kontrolera koje fabrika moze da proizvodi
"Jedina instanca klase WiiFabrika , skrivena u unutrasnjoj klasi radi lazy inicijalizacije"
"Konstante za definisanje tipa WiiMisa , tj da li se posmatra Akcelerator ili polozaj dioda"
Konstruktor klase u koji se prosledjuje Kontroler
Dogadjaj pomeraja
Dogadjaj pritiska na dugme
Predstavlja wii kontroler
Potrebno zbog kalibracije kod pracenja 2 izvora
Preciznost do koje se radi aproksimacija parametra t. Koristi se samo kod pracenja 3 izvora .
inicijalizujemo prvi naziv slike
"Funkcija initPaleteAlatki : Inicijalizuje sve alatke na paleti alatki sa koje mozemo da koristimo na default vrednosti . Nema parametara , niti povratne vrednosti ."
"Funkcija initPaleteAlatki : Inicijalizuje sve alatke na paleti alatki sa koje mozemo da koristimo na default vrednosti . Nema parametara , niti povratne vrednosti ."
dodajemo dugme ManjeVece
dodajemo dugme za novi papir po kom crtamo
dodajemo dugme snimanje
dodajemo dugme izlaz
Grafika za crtanje po panelu za Kalibraciju
Grafika za crtanje po panelu za Crtanje
slika kursora
Grafika za crtanje po panelu Alatke
lista objekata koji predstavljaju paletu boja
pocetna boja kojom se iscrtava je crna
pomocne promenljive za racunanje kordinat kursorX i kursorY
veca od 2 i deljiva sa 2
boja dugmadi na panelu
path gde snimamo slike koje nacrtamo .
"Funkcija init : Inicijalizuje sve parametre na default vrednosti . Nema parametara , niti povratne vrednosti ."
zauzeti pregledi za odredjenog doktora
glavna metoda je spajanje :
Klasa koja treba da odradi i sacuva trijangulaciju
"saljemo mail svima onima kojima je isteklo vrijeme cekanja , i ponistavamo njihove rezervacije"
sada ponovo racunamo koliko je dostupno knjiga
sada dajemo 3 dana posto su cekali
provjeravamo da li je vec rezervisano
oduzimamo broj onih koji nisu vratili
preracunavanje dostupno kopija za knjigu
da li je rezervisao
"jezici , oznake po : ISO 639 - 2"
"ako nije naveo type , stavljamo da je 1"
"response . Status = "" SUCCESS "" ;"
razdvojimo na tokene i dobijemo unutar zagrada koje vrednosti unosi
ovde postaviti type na default vrednost
pristpu drugoj tabeli :
postavimo metodu u request objekat
ukoliko imamo ID onda nemamo dodatne filtere
moramo spojiti sve razmake posle
"fields se prvo naidje na fields a zatim ide redom kroz queries da bi dobili sve fields jer su razdvojeni ide sve dok ne naidje na "" jer je to kraj u json"
i sam gore povecavao da bi preskocio te delove ovde pa ako je kraj onda je kraj
i sam gore povecavao da bi preskocio te delove ovde pa ako je kraj onda je kraj
"ako uspesno parsira onda sacuvaj u Query isto kao sa specifikacije odradjeno , nema ; na kraju"
"isto kao sa specifikacije odradjeno , nema ; na kraju"
ukloni ; sa kraja
provere da li je dobro unesen zahtev
"razdvojimo request tako da dobijemo odvojeno GET , pa onda / resource / { id } a zatim u JSON obliku ostatak filtera , ukoliko ID nije naveden"
ove sve akcije nadole bi trebalo da izbrisemo
privavljane trenutno ulogovanog korisnika
tek treba da se implementira
. OnDelete ( DeleteBehavior . SetNull ) ;
See https://sendgrid.com/docs/User_Guide/Settings/tracking.html
trebati ce za sihronizaciju kasnije
Ime clana posade u bazu podataka
Prezime clana posade u bazi podataka
Svi registrovani clanovi u tabeli se dobijaju iz ovog seta
"modelBuilder . Entity <ClanPosade> ( ) . Property ( p = > p. Slika ) . HasColumnType ( "" image "" ) ;"
Views . PrikazParametara var = new Views . PrikazParametara ( ) ;
var . UgasiDiodu ( ) ;
"<summary> Event koji se poziva ako je kliknuto dugme "" Ugasi "" da bi se poslali podaci na serijski port da se upali dioda . Kod "" 0 "" je znak programu na arduinu da se ugasi dioda . </summary> < param name = "" sender "" > </param> < param name = "" e "" > </param>"
ovo ce konstantno citati podatke i kada dodje do kraja onda poziva metodu da se iscita taj text
ovaj objekt ce se koristiti da se citaju podaci sa serijskog porta
Selector nadje device
podesiti tacno koji je port
nadje se device info
"najosjetljivija metoda , vraca null ako nesto nije uredu to moze biti da nije capability naveden u manifestu , da device ne prepoznaje ili da je device zauzet od druge aplikacije da je user blokirao ili sistem moze biti null iako je nadjen device information"
"najosjetljivija metoda , vraca null ako nesto nije uredu to moze biti da nije capability naveden u manifestu , da device ne prepoznaje ili da je device zauzet od druge aplikacije da je user blokirao ili sistemmoze biti null iako je nadjen device information"
"<summary> Event koji se poziva ako je kliknuto dugme "" Upali "" da bi se poslali podaci na serijski port da se upali dioda . Kod "" 1 "" je znak programu na arduinu da se upali dioda . </summary> < param name = "" sender "" > </param> < param name = "" e "" > </param>"
handlanje greske
Ovdje je potrebno ubaciti uslov tipa ako su uneseni svi parametri da ide na narednu komandu
Nakon toga prelazi se na novu stranicu za prikazivanje parametara
"Dodati : Ovdje dodati , kao i u bazi , datume registracija , kao i aktivnost drugih ppraviti"
obicna navigacija bez parametra
navigiranje na page ali da se proslijedi parametar stranici
Standardna relaycommand klasa koja se reuse u MVVM
dodavanje uloga korisniku
zahtjevOdmah . lokacijaKorisika . duzina ;
dobavljanje svih meni stavki za koje prijavljeni korisnik ima pravo pristupa
metoda koja mapira MeniStavke iz Modela u ViewModel koji se koristi na view-u
"Dodati : Zbog MVVM potrebno je da prima MainPageViewModel parametar , ali zbog nemogucnosti samo view"
selektovanje dispecera u gridu
za dispecera
pozove se uvijek kad nekog vozaca selektuje
izmjene
trazimo klijenta
trazimo njegove narudzbe odmah
Dodati : za kontrolu unosa naloga
registrovaniKlijent = new RegistrovaniKlijent ( ) ;
"pridruzivanje odabranih stavki menija , listview-u koji prikazuje meni"
show-hide funkcionalnost menija
"Metoda koja na osnovu odabranog menija , poziva podstranicu koja je definisana u meniju"
da slucajno neka rec nije ostala bez kategorije
prvo moramo obrisati sve poteze i tokove igre po korisniku . i jos nesto ako ima
generisanje tokena koji se vraca na FE
"nakon toga se vrsi kodiranje tih bajtova , i ta kodirana verzija se smeta u token taj SecretKey je u sustini jedan stepen zastite , bez da se zna on , niko sa strane ne moze da generise pravi token !! nakon prijave kad se salje token , prilikom authorizacije se taj proces verovatno obavlja obrnuto , vrsi se dekodiranje do niza bajtova koji predstavljaju SecretKey i proverava se jel se poklapa sa ocekivanim secretkey-om"
treci audience
duzina trajanja tokena
kljuc
"niz bajtova koji se ocekuje da se primi preko token-a , taj niz bajtova u sustini predstavlja secretkey"
services . AddScoped < DataLayer . Repository . KorisnikRepository > ( ) ;
vrsi se stalno prebacivanje iz stanja ready u running i obrnuto
ako se proces vec nalazi u RAMu ne diraj nista
"ako fali memorija na RAMu , oslobodi RAM memorije onih procesa koji su u Blocked stanju"
ako proces nije na RAMu skini ga sa Hard diska
prioritet ima onaj proces koji je najmanje korisito CPU ( CPU_Utilization 0 - 100 % )
prebacujemo onaj proces koji je najvise koristio CPU
Dodaj aktivnost o tome da je kreiran novi projekat
_context . Korisnik . FirstOrDefault ( a = > a. KorisnickoIme == korisnik . KorisnickoIme ) . Projekat . Remove ( projekat ) ;
Dodaj aktivnost o tome da je korisnik uklonjen sa projekta
ova funkcija dodaje aktivnost
Dodaj aktivnost o tome da je kreiran novi zahtev
Dodaj aktivnost o tome da je kreiran dodat novi trosak
ova funkcija uzima sve korisnike koji su angazovani na jedan projekat
vraca listu dokumenata jednog projekta
ova funkcija vraca sve zahteve koje je ulogovani korisnik poslao sa tog projekta
Izbaci iz baze one koji vise nisu tu
IZGRADNJA
ovo pretvara izabrani fajl u bajtove i pamti ga u infromacijiOLokaciji byte [ ]
Kreiranje i prikazivanje progress windowa
U bazi se kreira novi projekat i za njega se kreiraju odgovarajuca dokumenta
TODO : Ovde mogu i ostali atributi informaicje o lokaciji da se unose
Ako je vec uneta informacija o lokaciji onda se ona pamti u bazi pri kreiranju projekta
Prelazak na ClanoviProjektaPage
ovo kreira lokalni pdf fajl od bajtova
Dodavanje novog PDF u tabelu
Update dokumenta
ProgressWindow moze da se zatvori
Update podataka koji se prikazuju u dataGridu
informacija o lokaciji je uvek ukljucena
Da ih poredja od novijih ka starijim po ID-u
"Kad se klikne dugme sacuvaj treba da zna da li treba da vrsi update ili add u bazi To odlucuje na osnovu IDTroska , ako je 0 onda ga jos nema u bazi treba add , ako je razlicit od 0 onda se vrsi update"
"<summary> Generalne informacije o troskovima se prikazuju kao dva textblocka jedan iznad drugog Prvi je naslov tu pise npr "" Budzet projekta Broj rata 1. Rata 2. Rata . drugi ispisuje vrednosti "" 10 5 2500 50 . Koristim formatiranje stringova da bih to uspeo , ali font mora da je monospace , tj. da je sirina svih karaktera ista da bi se ovo postiglo </summary> <returns> </returns>"
naslovni red
Ucitava procente u tbProcenti
Ucitava i podatke u uplatama iz tabele generalniTrosak i pamti u tbProcenti
"Da izbacim razmak iz naziva projekta jer nije u bazi varchar i vraca mi gomilu "" """
Filtiranje korisnika
Filtiranje po tipu aktivnosti
Filtriranje po datumu aktivnosti
ako nije unet pocetni datum onda se postavlja 1/1/1 tj. prikazuje aktivnosti od pocekta
ako nije unet kranji datum onda se postavlja 1/1/9 tj. prikazuje aktivnosti do kraja
Postavi pomocnu listu rez kao itemssource lvAktivnosti
resetuj sva polja
kolekcija svih aktivnosti koje se ucitaju
kolekcija svih korisnika koji rade na projektu koji se prikazuju u listi za izbor korisnika
"izabrani korsnici , kad se chekira combobox onda se ovde dodaju , kad se uncheck onda se uklone"
"U Aktivnosti imam id projekta a treba mi njegovo ime , pa to resavam preko Dictionary"
"<summary> Konsturktor </summary> < param name = "" zaSveProjekte "" > Da li treba ucitati i prikazati aktivnosti za sve projekte </param>"
treba mi da privremeno pamti aktivnosti
"ovo mora malo da se preradi , kasnije"
ako nije admin onda mu prikazi samo one zahteve sa kojima on ima veze
refreshuj zahteve
znaci zahtev je na cekanju
Vraca sumu svih troskova za jednu potkategoriju
"Ovo radim zbog performansi , da bi izbegao visestruko racunanje ove vrednosti pamtim je u privatnom atributu i racunam u konsturktoru"
"Zanimljivi deo , grupise troskove na osnovu kategorije a onda na osnovu podkategorije , izracunava sumu troskova kategorije / podkategorije i to stampa"
Automatsko odredjivanje sirine kolona cell range-a
"Ispisuje naziv troska , iznos i deli ga na rate prema Uplatama i to ispisuje"
var dataProvider = new EFCoreDataProvider ( ) ;
Mala pomocna klasa
Interaction logic for pocetnaStranaUC . xaml
razmisli da li treba da se svaki put kreira konekcija ili je server uvek povezan mozda da postoji jedan exchange i da se postavljaju routing keyevi za vesti ??
TODO razmisli da li ovo moze nekako bolje
"ovaj lanac else-if-ova sluzi kako bi osvezili polja comboboxa za KATEGORIJU CENA , jer se desavao bug koji je sa time ispravljen !"
isto to samo za status sluzenaj alkohola
kreirane precice preko tastature
da ne moze ici AND nesto OR nesto ne moze tako
dodajemo izraz levo od njega u cvorove !
sada dodajemo ADD i pomeramo pokazivac da moze dalje da trazi ko covek
SADA SVE ISTO SAMO ZA OR LOGICKI IZRAZ !
PRETRAGA ZA TIP
ovo je kao pocetak pa ako imamo vise izraza ovo cemo uzimati 2 izraza pa onda treci dodajemo na to pa 4. dodajemo na sve ono pre i tako .. al ovo je prvi
ako je tip cvora AND onda samo postavi && izmedju 2 bool tipa
ovo ako nije prvi element onda svaki sledeci samo nadodavaj !!
ovo oznacava da se trazi razlicito od unosa !!
PRETRAGA ZA ETIKETU
u slucaju trazenja etiketa koje nisu ovaj id
ispitujemo i ako je prva zagrada u nizu onda stavi da pocne ubacivanje zan ovi cvor od te vrednosti
ako je nacinjena greska u ulazu samo izadjemo i prekinemo pretragu !
ako je samo od brojeva sastavljen onda mozemo da poredimo
izvlacimo vreme koje je uneo i proveravamo da li je to to !
ako je ovo nula onda smo dosli do neke celine i mozemo da ispitamo da li posle toga se nalazi ili nista ili AND ili OR
"ako je ovaj datum ranije od postavljenog datuma onda ce ovo vratiti vrednost ili 0 ili < 0 ( tj nula ako je to isti dan , sto ovde dozvoljavamo )"
sada kada znamo da je AND i OR tu negde mi cemo to da ubacimo ! jer necemo da dozvolimo da se ubacuje AND i OR koji nisu na najvisem nivou !
for petlja je ubacena jer smo dozvolili koliko god razmaka da bude izmedju OR AND i tako toga !
proveravamo mesto odrzavanja !
ovo je zastita ako pokusamo u najnizem nivou bez zagrada da ubacimo i AND i OR sto nije validno
proveravamo kategorijuCena !
ovde smo ubacili logicki izraz i povecali iterator za 2 kao da smo ga pokupili i nastavljamo dalje !
proveravamo pusenje
ako je upisano true onda gledamo da li je postavljeno pusenje na true
ispitujemo da li su hendikepirani dozvoljeni
ako je stavlejno na true ispitujemo da li je vrednost atributa hendikepiraniDozvoljeni na true
NEGACIJA OD TRAZENJA TIPA
proveravamo da li se poklapa tacna vrednost za ocekivanu publiku !
NEGACIJA OD TRAZENAJ PUBLIKE
prvo moramo da proverimo da li se bas radi o promenljivoj AND
"ako je string == sa "" AND "" onda je super to je to"
ovo je ubaceno da se ne bi prikazivala ova validacija u izmeni manifestacije
ovde implementiramo sta ce se raditi svaki sekund kada otkuca !
ovo radimo da bi obrisali // bin // Debug jer tu nam nisu html kodovi
ovo je uradjeno ako se promeni nesto u lokalnoj promenljivoj da se ne desi u bazi podataka !
geteri i seteri tj ovo se drugacije zove ovde
koristi se kod editovanja
ova promenljiva sluzi za filtriranje tabele etikete
ovo samo sluzi da evidentira ako se nesto promeni !!
PONISTAVANJE PRETRAGE
"kada kreiramo novu manifestaciju ovo stavljamo na true , da bi mogli da pokupimo tipove i etikete za tu manifestaciju"
PretragaManifestacija ( ) ;
ubacujemo selektovanu manifestaciju kako bi drugi prozor mogao da vidi koja je to manifestacija
"metoda izbacuje prozor za unos nove etikete , ako u listi svih etiketa nema nijedne , ali ako ima nesto u tabeli izbacuje novi prozor za izbor iz tabele"
metoda koja ubacuje ikonicu kod izmene manifestacije
brisanje svih tipa i manifestacija koje njega sadrze
FILTRIRANJE TABELE MANIFESTACIJA !!
metoda koja se koristi prilikom kreiranaj nove manifestaciju u tabelarnom rezimu
"<summary> Dodaje jedan naslov u pdf , naslov je bold i centriran </summary> < param name = "" text "" > Tekst koji ce biti u naslovu </param> < param name = "" fontSize "" > Velicina fonta naslova </param>"
"<summary> Dodaje sliku u pdf , slika je centrirana </summary> < param name = "" slika "" > Slika koja ce biti dodata u pdf </param> < param name = "" scale "" > Skaliranje velicine slike </param>"
"<summary> Dodaje n praznih paragrafa i na taj nacin stvara razmak </summary> < param name = "" velicina "" > Broj praznih paragrafa </param>"
Ova funkcija je suvisna jer se isto to postize preko margine ali mi se ne brise
"Kreira se tabela od tri kolone jednake sirine i bez okvira Prva je prazna , druga ima "" M. P. "" i treba ima mesto za potpis Na taj nacin postizem da se nalaze u istom redu"
Dodaje mesto za potpis profesora
"<summary> Otvara fajl ili ispisuje gresku ako to nije moguce </summary> < param name = "" file "" > Fajl koji treba otvoriti </param> <returns> </returns>"
"<summary> Postavlja neke atribute koji se cesto ponavljaju Postize se uniforman izgleda pdf-a </summary> < param name = "" element "" > Element za koji treba postaviti stil </param>"
<summary> PdfWrapper je klasa koja predstavlja jedan nivo apstrakcije za rad sa biblioteko iText 7 Implementira IDisposable interfejs pa moze da se korsiti sa using blokom </summary>
"<summary> Instancira objekat klase PdfWrapper </summary> < param name = "" file "" > Pdf fajl u kome ce se upisivati podaci </param>"
"<summary> Dodaje u pdf jedan paragraf , prva linija je uvucena </summary> < param name = "" text "" > Tekst koji ce paragraf da sadrzi </param>"
"<summary> Vrsi enkripciju ulaznog string i vraca ga </summary> < param name = "" password "" > ulazni string koji treba enkriptovati </param> <returns> Enkriptovan string </returns>"
Funkcija ComputeHash prima i vraca byte [ ] pa zbog toga ova konverzija string u byte [ ] i nazad
Thread . Sleep ( 100 ) ;
Ocekivani sertifikt centralne baze
Preuzimanje sertifikata iz skladista sertifikata
"Provera da li "" subjectName "" sertifikata odgovara datom "" subjectName-u """
Preuzimanje username iz Windows Logon name-a
Validacija na serverskoj strani Proverava se da li je issuer klijentskog sertifikata isti kao i issuer serverskog sertifikata
"public Point ( int x , int y )"
ideviPodkomentara predstavlja string id-eva podkomentara koji pripadaju tom komentaru prodji kroz sve podkomentare i napuni u listu samo one ciji je id == idPodkomentaraukomentarima
"NE zaboravi : mora proci kroz sve da bi dodao u listuSvihKomentara , kako bi mogao celu listu ponovo da upisem"
nasli smo komentar
popunjavamo polja za podkomentar
na nasem komentaru dodamo id podkomentara
prepisemo listu svih komentara-ukljucujuci i ovog izmenjenog
Upis u podkomentari . txt
U slucaju da je vec lajkovao taj komentar vrati false
svi drugi komentari
"Nakon sto sam dodao u . txt fajl ko je lajkovao , sada nadji taj komentar i povecaj mu brojlajkovanih"
nasli smo komentar kome treba povecati pozitivne glasove
"Prvo ako ova tema nema komentar tj ako joj je spliter listaSvihTema [ indexZaIzmenu-1 ] [ 8 ] == ' nePostoje ' , obrisi to nePostoje"
na kraj teme dodamo novi kometar-tj njegov id
provera ukoliko korisnik vec prati postojeci podforum
prepisemo sve teme - pa i ovu izmenjenu
otvori bulk writer
ubaci tu izmenjenu liniju na to mesto u listiSvih
"Prodji kroz sve komentare , nadji taj sa tim id-em , napravi novi komentar , od podataka i dodaj ga u listu"
"NOTE : kada dodajem ovde komentar , necu dodavati njegove podkomentare , posto to nije bitno za tu stranicu , korisnik treba samo da ima uvid u jedan komentar"
Upis u komentari . txt
"evenutalno : prodji kroz sve teme i pogledaj da li komentarLineSplitter [ 9 ] odgovara nekoj ako ne odgovara nijednoj , to znaci da ta tema ne postoji tj da je obrisana i nemoj dodati ovaj podkomentar u listu"
"evenutalno : prodji kroz sve teme i pogledaj da li komentarLineSplitter [ 9 ] odgovara nekoj ako ne odgovara nijednoj , to znaci da ta tema ne postoji tj da je obrisana i nemoj dodati ovaj podkomentar u listu"
podkomentar u listu
tokeniOdabranogKorisnika [ 8 ] tu se nalazi spisak pracenih podforuma
spoljasnjost-podforumi
"1. Prodji kroz sve podforumi . txt i kada nadjes da je splitter [ 0 ] == p. Naziv preskoci ga sa dodavanjem u listu 2. Prodji kroz sve teme i svaka koja ima splitter [ 0 ] == p. Naziv obrisi , tj nemoj je prepisati 3. Prodji kroz komentare i svaki obrisan dodaj u listuObrisanih 4. Prodji kroz podkomentare i obrisi one ciji su roditelji u listiObrisanih 5. prodji kroz lajkDislajkKomentari 6. Prodji kroz lajk dislajk teme"
za pocetak ima samo jedan moderator
unutrasnjost-podforum
uzmi mu pracene podforume i teme
ako korisnik prati podforum u kom se ova tema nalazi proveri da li se OVA tema nalazi u listi njegovih pracenih
"ukoliko korisnik nije vec sacuvao ovu temu , i ova tema ima 5 ili vise pozitivnih glasova , dodaj mu je u preporuke"
pretrazi samo po sadrzaju
pretrazi samo po autoru
pretrazi po podforumu u koji pripada i autoru
pretrazi po naslovu i autoru
pretrazi po sadrzaju i autoru
"pretrazi po podforumu , naslovu , sadrzaju"
"pretrazi po podforumu , naslovu , autoru"
"pretrazi po podforumu , sadrzaju , autoru"
"pretrazi po naslovu , sadrzaju , autoru"
pretrazi po nazivu i opisu
pretrazi po nazivu i moderatoru
"pretrazi po nazivu , opisu i moderatoru"
U slucaju da je vec lajkovao tu temu vrati false
"Nakon sto sam dodao u . txt fajl ko je lajkovao , sada nadji tu temu i povecaj joj brojlajkovanih"
nasli smo temu kojoj treba povecati negativne glasove
tokeniOdabranogKorisnika [ 9 ] tu se nalazi spisak pracenih tema
"NOTE : kada dodajem temu u listu pracenih tema , stavim da nema ni jedan komentar , posto mi ne trebaju komentari kada budem ispisivao samo teme"
1. Prodji kroz sve teme . txt i kada nadjes da je splitter [ 0 ] == temaZaBrisanje . PodforumKomePripada i splitter [ 1 ] == temaZaBrisanje . Naslov tu nemoj dodati
"1. Prodji kroz sve teme . txt i kada nadjes da je splitter [ 0 ] == temaZaBrisanje . PodforumKomePripada i splitter [ 1 ] == temaZaBrisanje . Naslov tu nemoj dodati 2. Prodji kroz sve komentare , i svaki koji u sebi sadrzi tu temu obrisi ga , tj prepisi komentare . txt a nemoj dodati te koji sadrze tu temu 3. Za svaki komentar koji ne sadrzi tu temu dodaj njegov id u neku listu stringova , zatim prodji kroz sve podkomentari . txt i obrisi sve podkomentare ciji je splitter [ 0 ] == id-em iz liste obrisanih komentara , i takodje te obrisane ideve dodaj u jos neku listuObrisanihPodkomentara 4. Prodji kroz lajkDislajkKomentari i obrisi svaki koji sadrzi neki id ili iz listeObrisanihKomentara ili iz listeObrisanihPodkomentara 5. Prodji kroz lajkDislajkTeme i obrisi svaku temu ciji je splitter [ 1 ] == temaZaBrisanje . PodforumKomePripada-tema . Naslov"
"prodji kroz komentare svih tema , ukoliko neka tema sadrzi u svojoj listi komenara zalba . Entite ( idProsledjenogKomentara ) sacuvaj podforum u kojem se nalazi ta tema onda prodji kroz sve podforume i nadji onaj podforum koji sam malopre nasao i izvuci mu odgovornog moderatora"
To znaci da ova tema sadrzi taj komentar koji je poslat na zalbu i sad uzimam podforum u kom se ta tema nalazi
pa sada prodji kroz podforume i nadji odgovornog moderatora za podforum u kojem se nalazi tema u kojoj se nalazi komentar na koji se korisnik zalio
lista tema
lista komentara
ako hoce da pomeri manifesatciju jako malo da ne okida dole
kreiranje sedista
editovanje sedista
dodavanje lokacije
TODO : jedna kompanija ne sme da ima vise istih lokacija
Proveri da li vec postoji kompanija sa tim imenom
Proveri da li je user vec admin neke kompanije
Proveri da li je korisnik vec ocenio kompaniju
Proveri da li auto pripada kompaniji ulogovanog admina
Proveri da li filijala pripada kompaniji ulogovanog admina
Validacija datuma
Proveri datume
smanji za popust
"File : InvertoryType . cs Author : Vaxi Created : Friday , April 17 , 2020 12:50:01 AM"
"TODO : Proveriti da li treba properti , i kako to resiti u PD"
<summary> Remove an existing InventoryAmount from the collection </summary> <pdGenerated> Default Remove </pdGenerated>
Purpose : Definition of Class Room
Inventar koji ne zahteva zauzimanje od strane cinioca sistema .
"File : Rate . cs Author : Vaxi Created : Wednesday , April 29 , 2020 7:34:31 PM"
Purpose : Definition of Class SurveyResponse
"File : Doctor . cs Author : Vaxi Created : Wednesday , April 1 , 2020 9:43:20 PM"
Purpose : Definition of Class Doctor
Purpose : Definition of Class Manager
Purpose : Definition of Class Person
Purpose : Definition of Class RegisteredUser
"File : Specialist . cs Author : Igorr Created : Thursday , April 2 , 2020 12:54:00 PM"
"File : SpecialtyType . cs Author : Igorr Created : Saturday , April 4 , 2020 10:20:10 PM"
"File : UserDTO . cs Author : Filip Zukovic Created : Wednesday , May 20 , 2020 5:04:06 PM"
"Ostaviti , trebace kasnije da se nadograde"
"Version information for an assembly consists of the following four values : Major Version Minor Version Build Number Revision You can specify all the values or you can default the Build and Revision Numbers by using the ' * ' as shown below : [ assembly : AssemblyVersion ( "" 1.0. * "" ) ]"
"Version information for an assembly consists of the following four values : Major Version Minor Version Build Number Revision You can specify all the values or you can default the Build and Revision Numbers by using the ' * ' as shown below : [ assembly : AssemblyVersion ( "" 1.0. * "" ) ]"
"File : BlogPostDataBaseRepository . cs Author : Vaxi Created : Saturday , May 2 , 2020 5:16:42 PM Purpose : Definition of Class BlogPostDataBaseRepository"
"File : BlogPostDataBaseRepositoryFactory . cs Author : Vaxi Created : Friday , May 29 , 2020 6:19:06 PM Purpose : Definition of Class BlogPostDataBaseRepositoryFactory"
"Ako je sve ovo zadovoljeno , slobodna je"
"TODO : Resiti ove interakcije sa repo , preko factory patterna"
Ako jeste predlazemo njega
"Ako je prioritet doktor , i taj doktor nije slobodan u izabranom temrinu , tada trazimo prvi slobodan termin izvan izabranog intervala"
Da li se taj termin nalazi unutar radnog vremena
public IUserRepositoryFacotory iUserRepositoryFacotory ;
MERGE JE ISTO KAO CREATE ALI NE DOPUSTA DUPLIKATE
Nema korisnika u bazi
Pilot
aerodromi
avion
stjuardese
tezina
broj putnika
drugi parametar je redni broj presedanja
Citamo dok je ulaz validan
"za std :: complex na primer : ( 1,2 ) ( 3,4 ) ."
Duzina najduze linije za unte poruke .
"istream & getline ( istream & is , string & str , char delim ) ; istream & getline ( istream & is , string & str ) ;"
"Separator sa zvezdicama ima duzinu najduze linije + 4 usled toga sto poruku """" hello """" menjamo sa """" * hello * """" ."
Ispisujemo gornji separator .
Brisanje poslednjeg elementa .
Vremenska slozenost : O ( 1 )
"Brisanje elementa na poziciji koja je definisana iteratorom , u ovom slucaju , brisemo element na indeksu 0 + 3 = 3."
Vremenska slozenost : Linearna
Inicijalizacija skupa pocetnim vrednostima .
Blok ispod je dodat kako bi se omogucilo da recikliramo imena promenljivih .
Pretraga u skupu
Pristupanje elementima sa datim kljucem .
Vremenska slozenost : Logaritamska
"Koriscenjem prvog pristupa , ukoliko kljuc ne postoji u recniku , bice unet novi par vrednosti u recnik , pri cemu se za vrednost u tom paru uzima podrazumevana vrednost za dati tip ( std :: string u ovom primeru ) ."
"++ key_not_existing ; std :: cout << """" Student sa indeksom """" << key_not_existing << """" se zove / "" << students.at ( key_not_existing ) << """" / "" << std :: endl ;"
"Unosesenje novog para ( kljuc , vrednost )"
Konstruisemo par koji zelimo da dodamo .
"Povratna vrednost je par ( iterator , bool ) . Ukoliko je unos uspesan , iterator """" pokazuje """" na uneti par u recniku , a bool vrednost je tacna . Ukoliko unos nije uspesan , iterator """" pokazuje """" na postojeci par u recniku , a bool vrednost je netacna ."
uzimamo prvi element uredjenog para
Primer za unos koji ne uspeva .
Inicijalizacija JPL .
"Vrlo slicno kao za vektor , provera da li je kolekcija prazna i pristup elementima ."
"Primetite da funkcija ` back ( ) ` ne postoji , da li mozete da pretpostavite zasto ?"
"Pored ` cbegin ( ) ` , ` begin ( ) ` , ` cend ( ) ` i ` end ( ) ` iteratora postoje i iteratori ` cbefore_begin ( ) ` i ` before_begin ( ) ` iteratori koji pokazuju na prvu poziciju pre pocetka liste . Namena ovog iteratora je na primer za funkcije poput : ` insert_after ( ) ` , ` emplace_after ( ) ` , ` erase_after ( ) ` , ` splice_after ( ) ` ."
"Dodajemo element pre elementa na koji pokazuje prosledjeni iterator , u ovom slucaju , dodajemo ' > ' na pocetak liste ."
Vremenska slozenost : * konstantna - u slucaju unosa jedne vrednosti * linearna po broju unetih vrednosti
Iterira se kroz listu .
"Tip std :: list < T , . > predstavlja dvostruko povezanu listu ( DPL ) vednosti tipa T."
Izracunavanje broja elemenata
Vremenska slozenost : Konstantna ( od C ++ 11 )
Unosenje jednog ili vise elemenata ispred nekog elementa .
Vremenska slozenost : Konstantna ( u slucaju unosa jedne vrednosti ) ili linearna po broju unetih vrednosti
Unosenje elementa na pocetak i kraj DPL .
Vremenska slozenost : Konstantna
Inicijalizacija praznog vektora
Dodajemo na kraj vektora svaki uneti broj . Vektor vrsi povremenu realokaciju memorije pri kojoj rezervise vise nego sto mu u tom trenutku potrebno kako bi dodavanje na kraj bilo efikasnije .
Prikazujemo broj elemenata u vektoru .
Dodaje se broj na pocetak vektora .
Umesto std :: cbegin i std :: cend moze se koristiti i xs . cbegin ( ) i xs . cend . Preporuceno je koristiti opstiju verziju funkcije std :: cbegin ( ) i std :: cend ( ) jer rade u vise slucajeva u zavinosti od tipa na kojim se pozivaju ( na primer pokazivaci ) .
Dodaje se pet 0 na kraj vektora .
Ispisivanje sadrzaja vektora koristeci kolekcijsku petlju .
"STL kolekcije su pravljenje sa ciljem da budu izuzetno efikasne , tako da se ne vrsi provera granica prilikom pristupu elementima kolekcije . Ovde treba biti pazljiv i obratiti paznju na granice ."
"Dodavanje vrednosti na kraj vektora , pri cemu vrednost konstruisemo u mestu ."
Vremenska slozenost : Amortizovana konstantna O ( 1 )
Postfiksno inkrementiranje .
Inkremenitiramo trenutni objekat koristeci prefiksni operator inkrementacije .
Vracamo originalnu verziju .
TODO Domaci
Operatori za jednakost i nejednakost .
Binarni operatori za sabiranje i oduzimanje razlomaka ` a ` i ` b ` gde je : - ` a ` -> * this - ` b ` -> other
"DOMACI : - Mnozenje razlomaka - Deljenje razlomaka - Operatori > , < - Prefiksni i postfiksni operatori -- - Operatori > = , < = - Mnozenje i deljenje skalarom"
Preporuceno kastovanje u C ++ svetu koristeci static_cast . https :/ stackoverflow.com/ questions / 103512 / why-use-static-castintx-instead-of-intx
"std :: back_inserter je pogodna funkcija koja za datu kolekciju konstruise iterator koji se koristi za dodavanje elemenata na kraj te kolekcije . Ocigledno , ovo funkcionise samo za one kolekcije koje imaju definisanu operaciju push_back ."
"Sortiramo vektor , osim prvog i poslednjeg elementa"
"Alternativno , i preporuceno , je koristili std :: begin i std :: end jer su opstiji ( u ovom slucaju rade isto ) . Na primer , ukoliko je xs staticki-alociran niz ili neka druga kolekcija ( koja podrzava operacije begin i end ) , sledeci kod bi i dalje radio ."
Ispisujemo sadrzaj
"Alternativno , i preporuceno , kao i sa sortiranjem vektora iznad jeste koriscenje funkcija std :: cbegin i std :: cend za dobijanje konstantnih iteratora na pocetak , odnosno , kraj kolekcije ."
Ispisujemo sadrzaj u obrnutom poretku
Iteratori nam pruzaju apstrakciju nad pokazivacima .
Vrsimo razdvajanje stringa po separatoru ' / ' . Rezultat je lista stringova ( QStringList ) razdvojenih po karakteru . Na primer :
Inkrementacija prvog operanda
Azuriramo vrednost razlomka .
"VAZNO Uocite da se logika za drugi razlomak ponavlja i da izuzetno lici na logiku za prvi razomak . Ima smisla i preporuceno je apstrahovati obe funkcije novom funkcijom , a potom nju pozvati i izbeci ponavljanje koda . Uradite to za domaci ."
Uocite da se logika za drugi razlomak ponavlja i da izuzetno lici na logiku za prvi razomak .
"Ima smisla i preporuceno je apstrahovati obe funkcije novom funkcijom , a potom nju pozvati i izbeci ponavljanje koda . Uradite to za domaci ."
Pokusavamo da parsiramo prvi razlomak
"Ako je uspelo parsiranje , vrsimo izracunavanje ."
"Izracunavamo zbir ( rezultat je Fraction ) , i potom se poziva implicitno kastovanje u tip QString ( implementirali smo taj operator ) ."
Oduzimanje
"Uocite da se logika za oduzimanje ponavlja i da izuzetno lici na logiku za sabiranje . Ima smisla i preporuceno je apstrahovati obe funkcije novom funkcijom , a potom nju pozvati i izbeci ponavljanje koda ."
Uradite to za domaci .
Vrsi parsiranje razlomka iz QLineEdit polja koji se prosledjuje
"Rad sa std :: shared_ptr """" pametnim """" pokazivacem"
Funkcija ` use_count ( ) ` prikazuje broj referenci na objekat .
"U nasem slucaju bice 3 usled pokazivaca p1 , p2 i p3 ."
Sada ce broj referenci biti 4.
"Rad sa std :: unique_ptr """" pametnim """" pokazivacem"
"Sirovi pokazivac mozemo izvuci koristeci funkciju ` get ( ) ` . Ovo bi trebalo izbegavati , osim ukoliko nemamo dobar razlog za to - na primer neki stari deo projekta bas zahteva da se prosledi sirovi pokazivac , a nemamo vremena ili dozvolu da menjamo taj deo projekta ."
"unique_ptr ( kao i shared_ptr ) imamo predefinisane operatore * i -> tako da se unique_ptr objekat sa njima ponasa kao da je sirovi pokazivac , odnosno operator * vrsi dereferensiranje , a -> vrsi pristup objektu na koji pokazuje pametni pokazivac ."
"Klasa std :: unique_ptr sluzi da zameni koriscenje """" cistih """" pokazivaca u situacijama kada najvise jedan pokazivac moze da sadrzi adresu na neki objekat , odnosno kada je taj pokazivac glavni i jedini odgovorni vlasnik nad objektom ."
const auto p2 ( p1 ) ;
Konstruktor kopije je obrisan ( = delete )
const auto p3 = p2 ;
Operator dodele sa semantikom kopiranja je obrisan ( = delete )
"U klasu unique_ptr operator bool je definisan tako da vraca tacno ako unique_ptr pokazuje na neki objekat , odnosno get ( ) ! = nullptr . Kada se promeni vlasnistvo , odnosno pozove move konstruktor za unique_ptr ( videcemo sta je move konstruktor u narednom primeru sa listom ) , stari objekat ce biti azuriran i operator bool ce vracati false jer unique_ptr vise ne pokazuje na objekat ( primer ispod ) ."
"Za primitivne tipove , kao sto je size_t , nema potrebe zvati std :: move ."
1. Pravi se privremena kopija objekta ( poziva se konstruktor kopije )
"Operator dodele uvek vraca referencu na tekuci objekat , kako bismo mogli ulancavati ovaj operator ."
"Ponovo , ovde ne koristimo std :: move jer je tip podatka trivijalan , ali moramo da resetujemo broj elemenata u drugoj listi na 0 , kao u konstruktoru sa semantikom pomeranja ."
"Kad god se napravi destruktor , obavezno je napraviti i konstruktor kopije i operator dodele ( rule of 3 ) , ili ih eksplicitno izbrisati ( navodjenjem """" = delete """" nakon metoda ) , a pozeljno je napraviti i konstruktor operator dodele sa semantikom pomeranja ( rule of 5 ) ."
"Kljucnom reci noexcept navodimo da metod nece izbacivati izuzetke . Ukoliko noexcept metod ipak izbaci izuzetak , i taj izuzetak nije uhvacen i obradjen unutar funkcije , C ++ program to smatra za gresku od koje nema oporavka , te ce pozvati std :: terminate ( ) i zavrsice se . Za neke metode se smatra da bi trebalo da budu noexcept , kao sto su metodi sa semantikom pomeranja ispod ."
Konstruktor kopije
Operator dodele sa semantikom pomeranja
Operacije za rad sa listom
Operator indeksiranja kojim samo dohvatamo element
! MATF_LIST_HPP
"S obzirom da smo """" ukrali """" implementaciju ys , u opstem slucaju ne bi trebalo da je koristimo u daljem kodu . Ipak , mi ispisujemo njen sadrzaj da bismo pokazali da konstruktor sa semantikom pomeranja zaista """" krade """" implementaciju iz ys ."
"Naredni fragment koda kreira dve prazne liste , as i bs , a zatim poziva operatore dodeljivanja sa semantikom kopiranja i pomeranja radi testiranja njihove implementacije ."
"Primer ispravne implementacije rada sa resursima . Resurs moze biti datoteka , konekcija ka bazi podataka , dinamicka memorija , i dr."
Inicijalizacija resursa se vrsi na pocetku funkcije
Nacin implementacije u programskom jeziku C
Deinicijalizacija resursa se vrsi na kraju funkcije
"Resource Acquisition Is Initialization ( skr . RAII ) predstavlja tehniku programiranja u jeziku C ++ kojom se zivotni ciklus nekog resursa vezuje za zivotni ciklus odgovarajuceg objekta . Drugim recima , resurs se dobija kada se objekat konstruise , dok se resurs oslobadja kada se objekat unistava ."
Inicijalizacija resursa se vrsi u konstruktoru
Deinicijalizacija resursa se vrsi u destruktoru
"Zbog inicijalizacije i deinicijalizacije resursa je prilikom pisanja C programa nastala praksa da bi metod trebalo da ima samo jedan izlaz , tj. jednu return naredbu Za C ++ ovo ne moze biti praksa , jer i pored jedne naredbe return , izlaz iz metoda moze da se pojavi bilo gde , tj. izuzetak moze biti ispaljen bilo gde u kodu . Tako da je ideja inicijalizacije na pocetku metoda i deinicijalizacija na kraju nesto sto je obeshrabreno ."
"Implementirati funkciju koja vraca iterator na prvi element u kolekciji koji zadovoljava predikat ` p ` . Ako funkcija ne pronadje takav element , vratiti iterator na kraj kolekcije ."
Implementirati funkciju koja pocevsi od iteratora ` first ` pa do iteratora ` last ` postavlja vrednost ` value ` .
"Napisati funkciju koja prosledjenu vrednost ` v ` odseca na interval [ low , high ] tako sto : - v < low = > v = low - v > high = > v = high - inace = > v"
find
find if
clamp
"Dedukcija sablona ne uspeva ako se ne navede <float> za poziv matf :: clamp ( value , 0 , 1 ) jer ne postoji funkcija matf :: clamp ( float , int , int ) . Kada navedemo <float> pri pozivu , vrednosti 0 i 1 se implicitno kastuju u float te se pronalazi funkcija matf :: clamp ( float , float , float ) ."
Uocite razliku pri konstrukciji objekata i dodavanju u vektor ako se koriste ` push_back ` i ` emplace_back ` .
"Uocite redosled pozivanja konstruktora i move operatora . Zakomentarisite move konstruktor i move operator dodele pa analizirajte ponasanje ovog dela koda ponovo . Iako se unutar matf :: accumulate vrsi izmena neutrala , primetite da se on kopira pri pozivu funkcije , i da je nakon funkcije i dalje vrednost u redu , te ga zbog toga deklarisemo kao konstantnog ."
Da li sledeci kod validno radi ?
Sablonska funkcija koja vraca maksimum od dve prosledjene vrednosti . Vrednosti mogu biti bilo kog tipa nad kojima je definisan operator ' > ' . Kljucna rec ` inline ` sugerise kompilatoru da pokusa da poziv funkcije zameni direktno sa implementacijom funkcije . Time se moze izbeci cena pozivanja funkcije .
Pretpostavimo da je prvi najveci .
Funkcija ` accumulate ` vrsi akumuliranje vrednosti kroz kolekciju podataka koristeci operator ' + ' i koristeci neutral ` init ` .
"C """" - ovski nacin da se napise """" genericka funkcija """" kroz koriscenje sistema zasnovanog na makroima ."
ifndef POINT_HPP * / #endif / * ifndef POINT_HPP
"Operator [ ] je promenjen da uvek vraca referencu , da bismo izbegli kopiranje potencijalno velikih objekata . Ocigledno , da bismo sprecili menjanje objekta , potrebno je da vratimo konstantnu referencu ."
"Uocite prelepu stvar : osim promene ' int ' u ' T ' , i dodavanje template < typename T > prakticno nismo nista promenili u klasi ."
"Genericke klase nazalost ne mozemo da razvojimo u . hpp i . cpp datoteke kao sto smo videli na ranijim casovima . https :/ stackoverflow.com/ questions / 495021 / why-can-templates-only-be-implemented-in-the-header-file Jedino sto mozemo uraditi jeste odvojiti implementacije u posebnu datoteku zaglavlja koja cesto ima ekstenziju . ipp ( ili nekad . tpp ) , a potom tu datoteku ukljuciti na dnu . hpp zaglavlja . Napomena : Ovakve datoteke ( . ipp /. tpp ) se NE KOMPILIRAJU , kao ni ostala zaglavlja ! https :/ stackoverflow.com/ questions / 44774036 / why-use-a-tpp-file-when-implementing-templated-functions-and-classes-defined-i"
! COLOR_H * / #endif / * ! COLOR_H
ifndef PAIR_HPP * / #endif / * ifndef PAIR_HPP
Zadatak : Za dati argument komandne linije ispitati da li je palindrom .
Proveravamo da li su dve kolekcije jednake . Nedostaje provera da li obe kolekcije imaju isti broj elemenata sto nije potrebno u ovom slucaju .
"Zadatak : Dat je vektor pojmova ( niski ) . Konstruisati novi vektor koji odgovara datom , tako da ukoliko je pojam odabran ( pocinje karakterom ' * ' ) , onda vektor na toj poziciji ima vrednost true , a u suprotnom ima vrednost false ."
"Zadatak : Napisati funkciju split koja prihvata nisku kao parametar , i konstruise vektor reci koje se nalaze u datoj niski ."
Preskacemo razmake sa pocetka
Kopiramo karaktere u izlazni vektor
Zavrsavamo petlju nastavljajuci od kraja prethodne reci
Izdvajamo elemente koji su deljivi brojem 3 na pocetak kolekcije . Algoritam vraca iterator na prvi element koji nije deljiv nakon razdvajanja .
"Particionisemo ostatak kolekcije ( preskacemo elemente koji su deljivi brojem 3 ) . Druga grupa ce imati samo elemente koji daju ostatak 1 pri deljenju brojem 3 , dok su elementi iz intervala [ second_end , std :: end ( xs )) u trecoj grupi ."
Zadatak : Napisati sablonsku funkciju slide_selection koja prihvata iteratore na pocetak i kraj dela kolekcije i iterator na poziciju ispred koje se pomeraju elementi datog dela kolekcije . Funkcija treba da izvrsi dato pomeranje i vrati par iteratora koji pokazuju na pomereni deo kolekcije .
"Ne moramo koristiti std :: make_pair , vec ga mozemo konstruisati inicijalizatorom"
"Algoritam vrsi levu rotaciju dela kolekcije , tako sto zamenjuje elemente iz [ first , last ) tako da element n_first postaje prvi element u novom delu kolekcije i element n_first - 1 postaje poslednji element u novom delu kolekcije . ( Od C ++ 11 ) Algoritam vraca iterator na novu lokaciju elementa koji pokazuje na first , tj. first + ( last - n_first ) ."
"Zadatak : Napisati sablonsku funkciju move_selection koja prihvata iteratore na pocetak i kraj dela kolekcije , iterator na odredisnu lokaciju i predikat kojim testiramo vrednosti . Funkcija pomera sve elemente koji zadovoljavaju predikat oko mesta na koje pokazuje iterator na odredisnu lokaciju ."
Problem mozemo da razdvojimo na dva dela :
"1. Particionisemo deo kolekcije od pocetka do destination iteratora , u ovom delu zelimo da pomerimo selektovane elemente na kraj"
"Ove nam je potrebna funkcija koja vraca ` true ` kada ` predicate ` vrati false i obrnuto . Jedan nacin je da napisemo sablon koji to radi ( ` not_predicate ` ) , pa da """" vezemo """" argument koji ce nam proslediti stable_partition , sto se moze izvesti pozivanjem funkcije ` std :: bind ` , pri cemu ` std :: placeholders :: _1 ` predstavlja taj argument koji ce biti prosledjen . Medjutim , dodatni problem je sto moramo da eksplicitno navedemo tipove za dati sablon . Tip za predikat vec imamo , ali tip vrednosti kolekcije nemamo . Na srecu , dostupan nam je operator decltype koji da prosledjenu vrednost dedukuje o kojem tipu je rec ."
"Kada budemo ucili lambda izraze , videcemo da su one mnogo pogodnije za rad ( od C ++ 11 ) . Na primer , ovde je mnogo lakse proslediti naredni lambda izraz koji radi istu stvar , ali bez definisanja ` not_predicate ` i """" mucenja """" oko tipova . [ predicate ] ( const auto & item ) { return ! predicate ( item ) ; }"
Zadatak : Napisati sablonsku funkciju count_adj_equals koja vraca broj uzastopnih jednakih elemenata kolekcije .
"S obzirom da nam je sablonski tip T kolekcija , ako zelimo da """" izvucemo """" koji je sablonski tip jednog elementa kolekcije , to mozemo uraditi tako sto iskoristimo vrednost T :: value_type . Medjutim , zbog nacina kako sabloni rade , potrebno je da taj sablonski parametar takodje imenujemo , sto se radi sintaksom : """" typename Inner = typename T :: value_type """""
"Algoritam izracunava """" skalarni proizvod """" dveju kolekcija . Naravno , definicija """" skalarnog proizvoda """" u ovom kontekstu moze odgovarati bilo kojim binarnim operacijama ` + ` i ` * ` koje mi definisemo . U ovom primeru , operacija ` * ` je ispitivanje da li su vrednosti jednake ( ` equal_to_int ` ) dok je operacija + klasicno sabiranje ( ` plus ` ) ."
Primer izvrsavanja za nisku : Hooloovoo
"Primetimo da ovde poredimo kolekciju ( bez posl . elementa ) i istu tu kolekciju samo """" pomerenu """" za jedno mesto ulevo : Hooloovo | o ooloovoo Algoritam ce za svaka dva karaktera pozivati ` equal_to_int ` , cime ce dobijati vrednosti : 01001001 koje ce se """" akumulirati """" operacijom ` plus ` , sto daje vrednost 3."
Jedan pokusaj bi bio cuvanjem objekta :
"Kao sto vidimo iz ispisa , cak i ako je metod ` name ` deklarisan kao virtualan , objekat ` s2_sliced ` nema informaciju o tome da je to zapravo ` master_student ` . Ova pojava se naziva odsecanje ( engl . slicing ) ."
Drugi pokusaj je cuvanjem reference :
"Primetimo da je tip ` s2_pointer ` pokazivac na ` student ` . Zbog toga , bez obzira sto on zapravo sadrzi adresu objekta tipa ` master_student ` , ne mozemo preko njega da pristupimo clanicama koje su definisane u ` master_student ` , a nisu u ` student ` . Naredna linija ne prolazi kompilaciju :"
"Da bismo kastovali pokazivac niz hijerarhiju klasa ( engl . downcast ) , moramo da pozovemo operator dynamic_cast , koji vrsti kastovanje u toku izvrsavanja programa . Ako ovaj operator vrati ` nullptr ` , to znaci da pokazivac zapravo ne sadrzi adresu ciljane klase ."
"Slicno vazi i za reference , sa razlikom da se u slucaju neuspeha ispaljuje std :: bad_cast"
. a u izvedenoj klasi za dati metod navesti kljucnu rec ` override ` .
"Apstraktne klase se ne mogu instancirati , vec vazi pravilo : - U stablu hijerarhije na svakom putu od korena ( bazne klase ) do svih listova ( najspecificnijih izvedenih klasa ) mora postojati makar jedna implementacija apstraktnog metoda . Na primer , na putu ` Vehicle ` -> ` VehicleWithWindow ` -> ` Car ` , apstraktni metod ` Type ( ) ` je implementiran u klasi ` Car ` . Metodi koji su virtualni i apstraktni se nazivaju """" cisto virtualni """" ( engl . pure virtual ) ."
"Implementiramo netrivijalni destruktor i konstruktor kopije . Prema """" pravilu 5 """" , treba implementirati i : - operator dodeljivanja sa semantikom kopiranja - konstruktor pomeranja - operator dodeljivanja sa semantikom pomeranja Uraditi za domaci !"
"Tip vozila je nepoznat za baznu klasu , pa zato ovaj metod mora biti apstraktan ( notacija ` = 0 ` ispod ) ."
"Ako zelimo da napravimo klasu za koju zelimo da zabranimo kopiranje i operator dodele , dovoljno je da """" izbrisemo """" njihove implementacije . Ako zelimo da napravimo vise takvih klasa , ovo ponasanje mozemo da ubacimo u neku od natklasa ."
Ne zelimo da iko moze da napravi direktno instancu nase klase . Moze da pozove konstruktor ili destruktor samo ako je izvedena .
Pravimo klasu koja ' barata ' bazom podataka
Pravimo klasu koja barata internom bazom . Implementacija se oslanja na to da mozemo imati samo jednu konekciju ka internoj bazi .
internal_database db2_copy = db2 ;
Pravimo klasu orao . Orao je ptica koja bi trebalo da moze da leti .
Kompajler nam sada javlja da pingvini ne mogu da lete
p. fly ( ) ;
Dva objekta su razlicita ako nisu jednaka
Pravimo klasu koja ce testirati implementirane operatore
"Ponekad implementacija metoda koji dolaze u parovima i zavise jedan od drugog mogu da nam dosade . Na primer , zasto ne napravimo klasu koja ce nam dozvoljavati da definisemo samo operator == , a ! = da bude automatski implementiran ( ili obrnuto ) ?"
Sada sve radi kako bi trebalo
"Funkcionalni objekti implementiraju """" operator pozivanja """" , tako da kada se kreira objekat ove klase , moguce ga je """" pozivati """" . Argumenti ovog operatora su argumenti koje prosledjujemo pri """" pozivu """" ."
"Kreiramo recnik , pri cemu kao operaciju poredjenja koristimo funkcionalni objekat ."
Ispisujemo sve reci koje pocinju prefiksom koji korisnik zada
Trazimo iterator na prvu rec koja je veca ili jednaka onoj koju je korisnik zahtevao
"Trazimo iterator na prvu rec koja ne pocinje onim sto je korisnik zahtevao . To radimo tako sto """" uvecamo """" poslednji karakter u upitu , pa onda trazimo prvu rec sa tim prefiksom ."
Metod koji menja originalni string tako sto sva slova pretvara u mala .
Algoritam count_if vraca broj elemenata intervala koji zadovoljavaju dati predikat
"O referencama , kategorijama izraza i savrsenom prosledjivanju : http :/ bajamircea.github.io/ coding / cpp / 2016/04/07 / move-forward . html"
Algoritam ` find_if ` vraca iterator na prvi pronadjeni element . Prosledjujemo anonimnu funkciju ( anonimni funkcijski objekat ) . Trazimo prvu parnu vrednost u nizu .
"bind ce vratiti unarnu funkciju ( imamo jednu """" rupu """" , samim tim rezultat ce biti funkcija od jednog argumenta ) . Kad bude pozvana uz konkretan argument ` v ` , vratice isti rezultat koji vraca v. between ( 2 , 4 )"
"bind ce vratiti unarnu funkciju ( imamo jednu "" rupu "" , samim tim rezultat ce biti funkcija od jednog argumenta ) . Kad bude pozvana uz konkretan argument ` v ` , vratice isti rezultat koji vraca v. between ( 2 , 4 )"
Dodajemo miseve
Ukljucujemo anti-aliasing
Primetite karakter : u nazivu resursa - koristimo Qt resource system ( . qtc ) da se neophodni resursi postave u izvrsivu datoteku naseg programa tako da nismo u obavezi da ih korisniku zasebno isporucujemo .
Omogucava se da korisnik misem moze da pomera glavni pogled na scenu ( drag and drop akcija ) .
Postavljamo tajmer
Postavljamo da se advance poziva na svakih 10/33 ms sto otprilike daje 30 fps .
QGraphicsScene poziva advance nad svakim elementom scene kada se odluci da predje na sledeci frame .
"Metod advance se poziva dva puta : Ako je step == 0 , onda se poziva da informise elemente o tome da ce se desiti advance ( korisno da se elementi pripreme za advance ) . Ako je step == 1 , onda se zapravo izvrsava advance na sceni ."
Linija od centra misa do centra scene
Rotiramo na desno
Trazimo miseve koji su nam u vidokrugu
Haoticno kretanje
Prosledjujemo dogadjaj roditeljskoj klasi .
QGraphicsItem :: mousePressEvent ( event ) ;
Uklanjamo misa iz scene .
"Metod koji vraca pravouganik u cijim okvirima garantujemo da se mis nalazi ( to jest , da ni jedan deo misa ne izlazi van ) . QGraphicsView ovo koristi kako bi proverio da li QGraphicsItem zahteva ponovno crtanje ."
Funkcija koja vraca preciznije granice misa radi detekcije kolizije .
Crtamo telo
Ostale elemente misa crtamo samo ako imamo dovoljno mesta za detalje
"Sluzi za definisanje """" preciznog """" oblika elementa scene . Koristi se pri detekciji kolizija ."
U pitanju je cisto virtualan metod u natklasi QGraphicsItem . Definise proceduru za iscrtavanje elementa scene .
"Za svaki frejm u animaciji , scena poziva advance nad elementima scene ."
izracunavamo jedan medjuproizvod
dodajemo na medjurezultat
brisemo vodece nule
da li je prvi > = drugi
slucaj x == y
ako su brojevi istog znaka
broju koji ima vecu apsolutnu vrednost dodajemo broj sa manjom aps . vrednoscu
"ako su brojevi istog znaka , od broja sa vecom aps . vred . oduzimamo broj sa manjom aps . vred ."
CEOBROJ_H_
Arrange
Assert
"Ako neki izraz treba da bude jednak vrednosti true , koristimo makroe CHECK i REQUIRE . Razlika izmedju ova dva makroa je u tome sto : - CHECK ne prekida testiranje ostalih provera u jednom testu - REQUIRE prekida testiranje ostalih provera u jednom testu"
File : event . cpp
postavlja novu prekidnu rutinu
restore-uje prekidne rutine u prvobitno stanje
externals iz kernel . h
"Ne treba nam stack , koristimo stack od glavnog programa"
Ovu metodu treba pozvati svaki put kada se desi prekid na tajmeru
"Dok ima niti koje treba da se odblokiraju , odblokiraj ih"
File : list . cpp
"static List < pair < const char * , va_list > > buffer ;"
"buffer . pushBack ( makePair ( format , arglist )) ;"
lock za buffer b
InteruptLock lock ( true ) ;
"while ( ! buffer . empty ()) { pair < const char * , va_list > * curr = buffer . getFirst ( ) ;"
"check ( curr ! = NULL , """" curr == 0 , log . cpp """" ) ;"
lock . unlock ( ) ;
Da bi se zakljucali prekidi po izlasku iz vfprintf ako su bili zakljucani pre ulaska
delete curr ; lock . lock ( ) ; }
File : PCB . cpp
pamtimo adresu metode run ( ) SEG OFF
Kreiramo stack content za ovaj proces
Postavljanje konteksta steka
NAPOMENA : sp je na pocetku stack [ 0 ] - kod u PCB konstruktoru
Posle metode run izvrsava se metoda killThread ( podesavamo return adress-u na stacku )
zbog threads
pokazuje na pocetak niza
strcpy i strlen
waitingForMeToComplete - nije thread safe
File : PCBlist . cpp
bool semPreempt = false ;
value - nije thread safe blocked - nije thread safe
"Ne sme da se promeni lista blokiranih , Scheduler :: put - nije thread safe value - nije thread safe blocked - nije thread safe"
File : tControl . cpp
Locks this block problem ako se interrupt desi neposredno pre instukcije : inside = true ovo moze dovesti do nekoegzistentnog stanja
sp = runningThread -> sp ss = runningThread -> ss
"check ( runningThread -> id ! = -1 , """" dispach """" ) ;"
File : thread . cpp
timeBlocked nije thread safe
"log3 ( """" / tLOG : Allocating % d bytes / n """" , size ) ;"
"log3 ( """" / tLOG : Deallocating % p memory / n """" , loc ) ;"
File : event . h
Event-ovi kreirani na ovom ulazu
Kod van OS-a koji se pokrece
"Sve niti koje su """" zivi """" objekti"
Trenutni broj niti u Scheduler-u
Vraca element sa pocetka bez uklanjanja iz lise
Brise samo prvi pronadjen Node ne brise se vrednost
void remove ( Cmp cmp ) { Node * del = findNode ( cmp ) ; delete del ; }
Pri brisanju prevezuje se ostatka liste
! GLUPI BC31 poziva destruktor sa skrivenim parametrom po referenci
Dodaje element na pocetak
"blokira prekide vraca u stanje pre poziva lock , ako lock nije pozvan nema efekta"
File : log . h
Da li neko trenutno vrsi upis u log
"Ako je definisano ispisvace se poruka na ekranu ako dodje do greske Ovo je jer ako je neko vrsio ispis , a mi pisemo moze doci do greske nije toliko bitno posto moramo u svakom slucaju da prekinemo program"
Thread safe
log1 - log najveceg prioriteta Posto je inline nece se ugraditi kada nije definisan LOG1
log3 - log najmanjeg prioriteta Posto je inline nece se ugraditi kada nije definisan LOG3
File : pair . h
"20 , 2 ; 22 , 2"
Da li je probudjena nit pre sa wakeUp ( pre nego sto je trebala )
_PCB_H_
Nije Thread safe
File : schedule . h
File : semaphor . h
Returns the current value of the semaphore
File : sysmode . h
File : tControl . h
_TCONTROL_H_
File : thread . h
"returns : 1 � run completed , 0 � woken up returns : 1 � deblocked , 0 � no effect"
"returns : 1 � sleep completed , 0 � woken up"
"time , x 55 ms"
default = 2 * 55 ms
File : utility . h
potrebno consumeru
dohvati Consumer Thread
ocitava statusni reg. sa 64 h
dok se ocitava takav status da je pritisnut neki taster
Ovo se menja u testu
0 ili defaultTimeSlice
Korisnicki program mora obavezno da definise ovu f-ju
_OS1_USER_H_
File : buffer . h
"! val je 32 bitan , tipa ClusterNo !"
"! vrednost je 32 bitna , tipa ClusterNo !"
Ovaj operator vraca buffer enkapsuliran u objektu koji se prosledjuje
uzmi
vrati
Popunjava ulaz na pozciji pos sa vrednoscu val
File : cluster . h
Za prvi ulaz root dira
zatvaranje fajla
objekat fajla se mo � e kreirati samo otvaranjem
File : fileiterator . h
konverzije iz char-a u indeks i iz indeksa u char
File : partlib . h
Postavlja na 0
Vraca sledeci klaster u povezanoj listi
for ( int i = 0 ; i < POOL_SIZE ; i ++ ) pool . push ( new char [ ClusterSize ] ) ;
File : file . cpp
wait ( myImpl -> fs -> mutex ) ;
File : fs . cpp
File : kernelfile . cpp
Otvorila ga je druga nit
Nismo nasli fajl
Brisemo fajl
Kompresija
Ako je bio jedini u klasteru root dir skida se
da bi se izbeglo dvostruko indeksiranje
Zapisujemo modifikovan klaster na particiju
File : slobodniklasteri . cpp
if ( sledeci.no ! = 0 ) sledeci . _ -> prev = novi.no ;
Trenutni klaster postaje prvi u listi slobodnih klastera
Uzimanje prvog slobodnog sa pocetka liste
Ako je lista prazna
Umetanje na pocetak liste slobodnih klastra
Implementacija sabiranja korespondentnih elemenata celih vektora A i B pokretanjem onoliko niti koliko ima elemenata u vektorima a - Vektor A b - Vektor B Rezultat izvršavanja treba da bude vector <int> koji sadrži rezultat sabiranja korespondentnih elemenata . Implementacija sabiranja jednog para korespondentnih elemenata vektora Ova funkcija treba da bude iskorišćena za funkciju niti koje ovaj program pokreće . a - Iterator na element vektora A koji se obrađuje b - Iterator na element vektora B koji se obrađuje rez - Iterator u rezultujućem vektoru - element na ovoj poziciji će biti popunjen rezultatom sabiranja
"Kreiranje niti od funkcije """" ispisi """" . Svaka nit dobija svoj redni broj"
Čekanje da terminišu sve kreirane niti
"Implementacija pokretanja više niti koje treba da ispišu svoje redne brojeve ( koristeći funkciju """" ispisi """" ) brojNiti - Broj niti koje je potrebno startovati"
"Napraviti konkurentni program koji u poseboj niti vrši obrtanje redosleda elemenata u ulaznoj listi ( listi celobrojnih vrednosti ) . Na primer , ako je ulazna lista definisana ovako : 1 , 2 , 3 , 5 , 4 Rezultat obrtanja redosleda elemenata treba da izgleda ovako : 4 , 5 , 3 , 2 , 1 Potrebno je implementirati dve funkcije : 1 ) funkciju """" obrniRedosled """" koja se nalazi u fajlu obrtanje . h 2 ) funkciju """" izracunaj """" koja se nalazi u fajlu niti . h 1 ) Ulaz u funkciju """" obrniRedosled """" su dve liste - ulazna i izlazna . Ulazna lista je ona čiji se elementi samo čitaju ( ona se ne sme menjati ! ) i koji se u obrnutom redosledu upisuju u izlaznu listu . Test korektnosti funkcije """" obrniRedosled """" je dat u fajlu main . cpp , u funkciji """" testirajObrniRedosled """" . 2 ) Funkcija """" izracunaj """" ima jedan parametar - ulaznu listu koja sadrži neki broj cifara . Ova funkcija treba da pokrene jednu novu nit u kojoj će pozivom funkcije """" obrniRedosled """" da izvrši obrtanje redosleda elemenata ulazne liste i da novodobijenu listu vrati kao svoju povratnu vrednost . Test korektnosti funkcije """" izracunaj """" je dat u fajlu main . cpp , u funkciji """" testirajIzracunaj """" ."
izlazna = list <int> ( ulazna . size ()) ;
"Implementacija obrtanja redosleda elemenata u listi Ova funkcija treba da bude iskorišćena za funkciju niti koje ovaj program pokreće . ulazna - Ulazna lista , koja se obrađuje izlazna - Rezultujuća lista ( biće popunjena elementima u obrnutom redosledu )"
"Napraviti konkurentni program koji pronalazi element najbliži nuli iz zadatog vektora brojeva . Ovaj zadatak potrebno je izvršiti iz tri nove niti , tako da svaka nit pretražuje po trećinu ulaznog vektora . Dužina ulaznog vektora uvek će biti deljiva sa 3. Potrebno je implementirati dve funkcije : 1 ) funkciju """" pretrazi """" koja se nalazi u fajlu pretraga . h 2 ) funkciju """" izracunaj """" koja se nalazi u fajlu niti . h 1 ) Ulaz u funkciju """" pretrazi """" je par iteratora kojima se zadaje opseg elemenata koje je potrebno pretražiti . Postoji još jedan parametar ove funkcije i on služi da se vrati rezultat ( treba da bude postavljen na vrednost pronađenog elementa koji je najbliži nuli ) . Test korektnosti funkcije """" pretrazi """" je dat u fajlu main . cpp , u funkciji """" testirajPretrazi """" . 2 ) Funkcija """" izracunaj """" ima jedan parametar - ulazni vektor razlomljenih brojeva ( double brojeva ) . Ova funkcija treba da pokrene tri niti a kao funkciju tih niti treba da iskoristi funkciju koja je implementirana u prvom delu zadatka ( funkciju """" pretrazi """" ) . Test korektnosti funkcije """" izracunaj """" je dat u fajlu main . cpp , u funkciji """" testirajIzracunaj """" ."
"Implementacija pokretanja tri niti koje treba da pretraže ( svaka svoju trećinu ) ulazni vektor brojeva i nađu element najbliži nuli ulaz - Ulazni vektor brojeva koji se pretražuje Povratna vrednost je nađeni element , najbliži nuli od svih elemenata koji su obuhvaćeni pretragom"
PRETRAGA_H
"Napraviti konkurentni program koji pravi srpsko-engleski rečnik iz zadatog englesko-srpskog rečnika . Posao pravljenja rečnika treba obaviti u posebnoj niti . Napomena : redosled reči u rečnicima ( i ulaznom i u onom koji je dobijen kao rezultat pravljenja rečnika ) ne mora biti u redosledu u kojem se reči pojavljuju u programu ( usled osobine asocijativnih kolekcija da one interno menjaju raspored svojih elemenata ) . Potrebno je implementirati dve funkcije : 1 ) funkciju """" napraviRecnik """" koja se nalazi u fajlu recnik . h 2 ) funkciju """" izracunaj """" koja se nalazi u fajlu niti . h 1 ) Ulaz u funkciju """" napraviRecnik """" je par mapa . Prva mapa je englesko-srpski rečnik ( polazni rečnik ) a druga mapa je ona koju treba popuniti , tako da ona bude srpsko-engleski rečnik . Test korektnosti funkcije """" napraviRecnik """" je dat u fajlu main . cpp , u funkciji """" testirajNapraviRecnik """" . 2 ) Funkcija """" izracunaj """" ima jedan parametar - ulazni rečnik ( mapu reči kod koje je ključ reč na engleskom a podatak prevod te reči na srpski ) . Ova funkcija treba da pokrene novu nit a kao funkciju te niti treba da iskoristi funkciju koja je implementirana u prvom delu zadatka ( funkciju """" napraviRecnik """" ) . Njena povratna vrednost treba da bude napravljeni srpsko-engleski rečnik . Test korektnosti funkcije """" izracunaj """" je dat u fajlu main . cpp , u funkciji """" testirajIzracunaj """" ."
"Implementacija pokretanja dodatne niti koja treba da napravi novi rečnik ( koristeći funkciju """" napraviRecnik """" )"
RECNIK_H
"Funkcija koja će biti iskorišćena kao funkcija niti - od zadatog englesko-srpskog rečnika ona pravi obrnuti rečnik - srpsko-engleski engSrp - Englesko-srpski rečnik ( ključ je reč na engleskom , podatak je njen prevod na srpski ) srpEng - Srpsko-engleski rečnik ( ključ je reč na srpskom , podatak je njen prevod na engleski ) - ovaj parametar treba da se popuni izvršenjem ove funkcije"
ANTONIM_H
"Funkcija koja će biti iskorišćena kao funkcija niti - u zadatom rečniku ( parametar """" recnik """" ) pronaći suprotnu reč ( antonim ) od zadate reči """" rec """" recnik - Rečnik koji sadrži parove reč - reč suprotnog značenja rec - Reč za koju se traži reč suprotnog značenja rezultat - Reč suprotnog značenja ( ako je pronađena , ako nije pronađena ovde treba da se upiše prazan string )"
"Napraviti konkurentni program koji traži reč suprotnog značenja ( antonim ) od zadate reči . Konkurentnost rešenja se ogleda u tome što se pronalaženje reči treba obaviti u posebnoj niti . Zadat je rečnik ( mapa ) u kojem se navode parovi reč - suprotna reč . Iako je u ovoj mapi jedna od reči ključ a druga podatak mape , reči su ravnopravne - odnosno , kada se traži reč suprotnog značenja , moraju se pretražiti i kjučevi i sve vrednosti u mapi . Potrebno je implementirati dve funkcije : 1 ) funkciju """" nadjiAntonim """" koja se nalazi u fajlu antonim . h 2 ) funkciju """" izracunaj """" koja se nalazi u fajlu niti . h 1 ) Ulaz u funkciju """" nadjiAntonim """" je mapa koja sadrži parove reč - suprotna reč . Ovoj funkciji se takođe prosleđuje reč kojoj se traži antonim , kao i parametar koji treba popuniti , tako da nakon izvršenja funkcije u njemu stoji pronađeni antonim . Test korektnosti funkcije """" nadjiAntonim """" je dat u fajlu main . cpp , u funkciji """" testirajNadjiAntonim """" . 2 ) Funkcija """" izracunaj """" ima jedan parametar - ulazni rečnik i reč kojoj se traži antonim . Ova funkcija treba da pokrene novu nit a kao funkciju te niti treba da iskoristi funkciju koja je implementirana u prvom delu zadatka ( funkciju """" nadjiAntonim """" ) . Njena povratna vrednost treba da bude pronađena reč suprotnog značenja . Test korektnosti funkcije """" izracunaj """" je dat u fajlu main . cpp , u funkciji """" testirajIzracunaj """" ."
"Implementacija pokretanja dodatne niti koja treba da pronađe reč suprotnog značenja ( koristeći funkciju """" nadjiAntonim """" ) recnik - Rečnik koji sadrži parove reč - reč suprotnog značenja rec - Reč za koju se traži reč suprotnog značenja Povratna vrednost treba da bude reč suprotnog značenja ( ako je pronađena )"
LOGICKO_KOLO_H
Implementacija XOR operacije - treba da se koristi kao funkcija niti a_pocetak - Iterator na prvi element vektora A koji se obrađuje a_kraj - Iterator iza poslednjeg elementa vektora A koji se obrađuje b_pocetak - Iterator na prvi element vektora B koji se obrađuje rez - Iterator u rezultujućem vektoru - elementi počevši sa ovom pozicijom trebaju biti popunjeni rezultatima XOR operacije
Implementacija operacije XOR nad ulaznim vektorima A i B izvršene uz pomoć dve niti ( svaka nit obrađuje polovinu ) a - Vektor A ( 16 binarnih cifara ) b - Vektor B ( 16 binarnih cifara ) Rezultat izvršavanja treba da bude vector <int> koji sadrži rezultat izvršenja XOR operacije nad ulaznim vektorima .
CENOVNIK_H
"Napraviti konkurentan program koji formira najbolju ponudu cena od dva zadata cenovnika ( A i B ) . Cenovnici se zadaju uz pomoć map kontejnera , pri čemu ključ predstavlja naziv proizvoda ( string ) a podatak je cena proizvoda ( double ) . Program treba da podrazumeva da oba cenovnika ( dve mape ) sigurno sadrže iste proizvode ( svaki proizvod se sigurno pojavljuje u obe ) . Samo se deo sa cenama razlikuje . Program treba da u novoj niti obavi ispitivanje - da pronađe nižu od dve cene i da je ubaci u rezultujući cenovnik . Nebitno je u kojoj radnji je nađen proizvod , rezultujući cenovnik ( kao i dva ulazna ) sadrži samo naziv proizvoda i cenu . Primer : Ulazni cenovnik A : mleko = 85.50 sveska = 44.44 sampon = 140 kafa = 74.40 Ulazni cenovnik B : mleko = 81.20 kafa = 79.90 sampon = 145.50 sveska = 40.33 Izlazni cenovnik treba da izgleda ovako : kafa : 74.40 mleko : 81.20 sampon : 140 sveska : 40.33 Napomena : nebitno je kojim redosledom su prikazani proizvodi na izlazu ( posledica korišćenja asocijativnih kontejnera u STL-u je da se gubi redosled elemenata ) . Potrebno je implementirati dve funkcije : 1 ) funkciju """" nadjiPovoljno """" koja se nalazi u fajlu cenovnik . h 2 ) funkciju """" izracunaj """" koja se nalazi u fajlu niti . h 1 ) Ulaz u funkciju """" nadjiPovoljno """" su mape koje sadrže dva ulazna cenovnika ( A i B ) , kao i referenca na izlaznu mapu ( koju funkcija treba da popuni sa povoljnim cenama , prema prethodno opisanom postupku ) . Test korektnosti funkcije """" nadjiPovoljno """" je dat u fajlu main . cpp , u funkciji """" testirajNadjiPovoljno """" . 2 ) Funkcija """" izracunaj """" dobija dva parametra - dva ulazna cenovnika A i B. Ova funkcija treba da pokrene novu nit a za funkciju niti treba da se koristi funkcija """" nadjiPovoljno """" koja je realizovana u prvom delu zadatka . Test korektnosti funkcije """" izracunaj """" je dat u main . cpp fajlu , u funkciji """" testirajIzracunaj """" ."
"Napraviti konkurentan program koji obračunava ukupnu cenu prilikom kupovine više proizvoda . Da bi se ovo izračunavanje moglo uraditi neophodno je da postoji cenovnik , koji predstavlja mapu u kojoj je ključ naziv proizvoda ( string ) a podatak je cena proizvoda ( double ) . Pored cenovnika , ulaz predstavlja lista kupljenih proizvoda ( obavezno STL lista ) koja sadrži nazive proizvoda koji su kupljeni . Obračunavanje ukupne cene vrši se tako što se prolazi kroz listu kupljenih proizvoda , za svaki se nalazi cena u cenovniku i taj iznos se dodaje na tekući zbir . Jedan isti proizvod se može više puta pojavljivati u listi kupljenih proizvoda . Primer : Cenovnik : mleko = 85.50 sampon = 140 kafa = 74.40 Lista kupljenih proizvoda : { """" mleko """" , """" kafa """" , """" mleko """" } Ukupan zbir : 245.40 Potrebno je implementirati dve funkcije : 1 ) funkciju """" obracunajUkupno """" koja se nalazi u fajlu obracun . h 2 ) funkciju """" izracunaj """" koja se nalazi u fajlu niti . h 1 ) Ulaz u funkciju """" obracunajUkupno """" su lista kupljenih proizvoda i cenovnik , kao i referenca na broj koji funkcija treba da popuni ukupnom cenom svih kupljenih proizvoda . Test korektnosti funkcije """" obracunajUkupno """" je dat u fajlu main . cpp , u funkciji """" testirajObracunajUkupno """" . 2 ) Funkcija """" izracunaj """" takođe kao parametre prima listu kupljenih proizvoda i cenovnik . Ova funkcija treba da pokrene novu nit a za funkciju niti treba da se koristi funkcija """" obracunajUkupno """" koja je realizovana u prvom delu zadatka . Test korektnosti funkcije """" izracunaj """" je dat u main . cpp fajlu , u funkciji """" testirajIzracunaj """" ."
Čeka da se mesto oslobodi
Kad se mesto oslobodi
Metoda koju poziva nit koja simulira studenta u ambulanti nakon sto je student pregledan i izlazi iz nje . rbr - Redni broj studenta p - Pol studenta
Mesto se oslobađa
Obaveštava druge niti da se broj ženskih mesta promenio
"Modelovati koriscenje zaletista na atletskom mitingu . Isto zaletiste koriste dve discipline : skok u dalj i bacanje koplja . Zaletiste ne mogu istovremeno da koriste dva takmicara . Discipline se naizmenicno smenjuju na zaletistu ( jedan skakac u dalj , pa jedan bacac koplja i tako redom ) . Skok u dalj za jednog takmicara traje 1 sekundu . Bacanje koplja 2 sekunde . Metodu skaci poziva skakac u dalj . Metoda vraca duzinu u metrima koliko je takmicar skocio ( izmedju 0 i 9 metara moze skociti ) i koliko je ukupno trebalo vremena da zavrsi skok ( koliko je zajedno trajalo cekanje i skakanje ) . Metodu baciKoplje poziva bacac koplja . Metoda vraca duzinu u metrima koliko je takmicar bacio koplje ( izmedju 0 i 100 metara moze baciti ) i koliko je ukupno trebalo vremena da zavrsi bacanje koplja ( koliko je zajedno trajalo cekanje i bacanje koplja ) . Implementirati oznacene metode klase Atletska_staza u fajlu staza . h"
"Struktura koja opisuje povratnu vrednost , duzinu skoka ili bacanja i trajanje skoka i bacanja u milisekundama ."
Broj bacača se smanjuje
"Metoda koju poziva nit koja simulira skakaca kako bi takmicar obavio skok . Ukoliko je zaletiste zauzeto , ova metoda ce stajati blokirana dok se ono ne oslobodi i takmicar obavi nastup . rbr - Redni broj takmicara"
"Potrebno je pozvati metodu takmicar . skakac_ceka kada skakac ne moze da stupi na zaletiste . Potrebno je pozvati metodu takmicar . skakac_skace kada skakac stupi na zaletiste , pre skoka . Potrebno je pozvati metodu takmicar . skakac_zavrsio kada je skakac zavrsio i kada treba prikazati njegov rezultat ."
Beleženje početka
Broj skakača se povećava
Kada se oslobodi počinje sa skakanjem
Staza se oslobađa i o tome se obaveštavaju druge niti
Ako ima bacača obaveštaavaju se da je staza prazna
Broj skakača se smanjuje
Broj bacača se povećava
Bacač čeka
rbr - Redni broj takmicara
Ako nema knjiga
Kada se pojavi primerak
Potrebno je pozvati metodu primerak . vracen kada je primerak vracen u biblioteku .
I obaveštava drugu nit o tome
rbr - Redni broj clana
rbr - Redni broj automobila
rbr - Redni broj automobila ulaz - Ulaz na koji automobil pokusava da udje
"Metoda koju poziva nit koja simulira kretanje automobila kada on pokusava da udje na parking . Metoda je blokirajuca - ukoliko nema slobodnog mesta , izvrsenje je u blokadi dok se ono ne oslobodi . rbr - Redni broj automobila ulaz - Ulaz na koji automobil pokusava da udje"
Automobil čeka
"Kad se oslobpdi mesto , ulazi"
rbr - Redni broj klijenta salter - Salter na kojem ce klijent obaviti uplatu svota - Svota koju klijent zeli da uplati
rbr - Redni broj klijenta salter - Salter na kojem ce klijent obaviti uplatu ukupno_uplaceno - Ukupan saldo na salteru ( od svih dotadasnjih uplata )
Modelovati salter salu u posti u kojoj postoje 2 saltera .
"Modelovati salter salu u posti u kojoj postoje 2 saltera . Vremensko trajanje uplate ( boravak klijenta na salteru ) je srazmerno velicini uplate . Za svaku uplacenu hiljadu dinara klijent ceka 1 sec . Na salteru se moze uplatiti maksimalno 4 hiljada dinara . ( podrazumeva se da je ispravna vrednost prosledjena klijentu pri stvaranju niti ) . Kada klijent zeli da uplati sredstava , on poziva operaciju uplati ( ) , cime prakticno ulazi u postu i staje u red . Povratna vrednost ove operacije je broj saltera na kojem je klijent izvrsio uplatu i svota koja je do tog trenutka na salteru uplacena . Implementirati oznacene metode klase Posta u fajlu posta . h"
"Metoda koju poziva nit koja simulira klijenta kada on uplacuje neki iznos . Metoda je blokirajuca - ako je salter zauzet , metoda ce stajati blokirana dok se on ne oslobodi . rbr - Redni broj klijenta svota - Svota koju klijent zeli da uplati"
Potrebno je pozvati metodu klijent . ceka kada su salteri zauzeti i klijent mora da ceka . Potrebno je pozvati metodu klijent . uplacuje kada klijent stupi na salter i vrsi svoje placanje . Potrebno je pozvati metodu klijent . napusta kada klijent zavrsi placanje i napusta salter .
Ukupna svota za dati red se povećava
Izlaz iz reda
zauzimanje racunara ( uz moguce cekanje )
simuliranje koriscenja racunara uspavljivanjem niti
oslobadjanje racunara sa navedenim brojem
Znači da je računar slobodan
"Metoda koju poziva nit koja simulira studenta kako bi student zauzeo mesto za racunarom . Ova metoda je blokirajuca - ako nema slobodnih mesta , ona ce cekati dok se neko ne oslobodi . rbr - Redni broj studenta"
Potrebno je pozvati metodu student . ceka kada su racunari zauzeti i student mora da ceka . Potrebno je pozvati metodu student . zauzeo kada student zauzme racunar .
Broj računara za koji student seda
Kada se neki oslobodi
Metoda koju poziva nit koja simulira studenta kako bi oslobodio racunar koji je prethodno zauzeo . rbr - Redni broj studenta id_racunara - Redni broj racunara kojeg student oslobadja ( prethodno je zauzeo taj racunar )
Potrebno je pozvati metodu student . oslobodio kada student oslobodi racunar .
Oslobađa računar i obaveštava druge niti o tome
rbr - Redni broj studenta id_racunara - Redni broj racunara kojeg student oslobadja ( prethodno je zauzeo taj racunar )
rbr - Redni broj kamiona kolicina - Kolicina robe koja se prevozi ( u tonama ) zapaljivo - Ukazuje na to da li je roba koja se prevozi zapaljiva ( takva roba ima prioritet pri istovaru ! )
rbr - Redni broj kamiona
KAMION_H_INCLUDED
Modelovati Skladiste koje ima dve identicne rampe za istovar robe iz kamiona . Nosivost kamiona je maksimalno 7 tona . Kamioni nose obicnu ili zapaljivu robu . Kamioni sa zapaljivom robom imaju prednost pri istovaru . Kamion koji zeli da ostavi robu u skladistu poziva operaciju istovari ( ) . Kamion ceka ispred skadista dok jedna od rampi ne postane slobodna . Istovar traje onoliko sekundi koliko u kamionu ima tona robe . Operacija istovar ( ) vraca pozivaocu informaciju o tome na kojoj rampi je kamion istovaren .
Nosivost kamiona je maksimalno 7 tona . Kamioni nose obicnu ili zapaljivu robu . Kamioni sa zapaljivom robom imaju prednost pri istovaru . Kamion koji zeli da ostavi robu u skladistu poziva operaciju istovari ( ) . Kamion ceka ispred skadista dok jedna od rampi ne postane slobodna . Istovar traje onoliko sekundi koliko u kamionu ima tona robe . Operacija istovar ( ) vraca pozivaocu informaciju o tome na kojoj rampi je kamion istovaren . Implementirati oznacene metode klase Skladiste u fajlu skladiste . h
istovar robe ( uz moguce cekanje ako ispred ima drugih kamiona ) .
Potrebno je pozvati metodu kamion . ceka kada su rampe zauzete i kamion mora da ceka . Potrebno je pozvati metodu kamion . istovara kada zapocne istovar robe iz kamiona . Potrebno je pozvati metodu kamion . odlazi kada je kamion zavrsio istovar i odlazi .
Ulazi samo ako je količina robe manja od 7
Ako ne može proći
Ako je bio zapaljiv broj se smanjuje
rbr - Redni broj kupca pv - Rezultat kupovine
rbr - Redni broj kupca
"Metoda koju poziva nit koja simulira kupca , kada kupac obavlja soping ( procedura je opisana u zaglavlju main . cpp ) Metoda je blokirajuca - ako kupac mora da ceka da se oslobodi kabina za probu , izvrsenje ce blokirati dok se za to ne steknu uslovi . rbr - Redni broj kupca"
"Modelovati prvo kolo teniskog turnira koje se odrzava u teniskom klubu sa n terena . Svaki teren ima svoj broj ( Brojevi su od 1 do 12 ) . Na terenima se igraju teniski mecevi prvog kola teniskog turnira . U prvom kolu ucestvuje X takmicara , tako da ima M = X / 2 teniska meca . Za svaki mec u startu se definise na kojem terenu ce biti odigran . Raspored meceva po terenima pravi se tako da se mecevi ravnomerno rasporede po terenima . Znaci , na svakom terenu se u proseku igraju n / M meca . Svaki mec ima svoj identifikator ( broj ) . Svaki mec traje slucajan vremenski period izmedju 1 i 5 sekundi . Naredni mec na terenu ne moze da pocne dok se prethodni mec na tom terenu ne zavrsi . Za svaki mec potrebno je evidentirati trenutak kada je mec poceo i koliko je mec trajao . Implementirati oznacene metode klase Teniski_klub u fajlu teniski_klub . h"
Nit meca . Prosledjuje se broj meca i na kom terenu se igra .
"Svi mecevi se ciklicno rasporedjuju na terene 1,2 i 3."
rbr - Redni broj meca p - Podaci o mecu
rbr - Redni broj meca teren - Indeks terena na kojem mec treba da se odigra
"Podaci o mecu . Broj meca , trajanje i trenuci dolaska i pocetka ."
"Klasa deljenog resursa . Pravi se maksimalno 30 terena , ali ce u realnosti biti samo 3 terena ."
"Metoda koju poziva nit koja simulira mec kako bi izvrsila teniski mec . Metoda je blokirajuca - ako je zeljeni teren zauzet , izvrsenje ce blokirati dok se on ne oslobodi . broj_meca - Redni broj meca na_terenu - Indeks terena na kojem mec treba da se odigra"
Ako je teren zauzet
rbr - Redni broj kupca kasa - Kasa ( redni broj ) na kojoj kupac ceka da obavi kupovinu
Modelovati placanje robe u trznom centru . U trznom centru postoje 2 kase za placanje . Kupac pri placanju staje u red na onu kasu na kojoj ceka manji broj kupaca . Kupac vrsi placanje pozivom metode kupi ( ) koja kao parametar dobija broj artikala koje kupac placa . Placanje robe traje onoliko sekundi koliko ima artikala . Povratna vrednost metode je identifikator kase na kojoj je placanje izvrseno . Implementirati oznacene metode klase Trzni_centar u fajlu trzni_centar . h
Ukoliko je kasa zauzeta
Kupac čeka
Nakon što završi kupovinu
Unos brojeva
Pronalaženje maksimalnog elementa
Dodavanje novog stringa u vektor
"Napisati program koji omogucuje evidenciju fakultetskih ucionica . Za svaku ucionicu potrebno je evidentirati naziv ucionice , kvadraturu i racunare koji se nalaze u ucionici . Za svaki racunar evidentiraju se podaci o hard disku i procesoru . U okviru main funkcije , definisati jednu ucionicu koja sadrzi dva racunara . Zatim je potrebno na konzolu ispisati hard disk i procesor svakog racunara u ucionici ."
"Mapa - kljuc je engleska rec , a vrednost srpska"
Uciravanje
Uneti 5 celih brojeva sa standardnog ulaza . Koriscenjem STL algoritma sortirati brojeve u opadajucem redosledu
Komparator za sort funkciju
Unos 5 brojeva
Dodavanje u vektor
"Napraviti funkciju : vector <int> min ( const vector <int> & a , const vector <int> & b ) ; Ova funkcija vraca vektor koji sadrzi minimume korespodentnih elemenata vetora a i b. Npr : r [ 0 ] = min ( a [ 0 ] , b [ 0 ] ) , r [ 1 ] = . Podrazumeva se : a. size ( ) == b. size ( )"
Učitavanje
Učitavanje vektora a
"Napraviti funkciju : vector <int> min_n ( const vector <int> & v , int n ) ; Ova funkcija vraca vektor koji sadrzi n najmanjih elemenata iz vektora v. Podrazumeva se : v. size ( ) > = n"
Pomoćni vektor
Sortiranje pomoćnog vektora
Učitavanje dužine
Kreiranje vektora
Učitavanje vektora
Učitavanje broja minimuma
Poziv funkcije
Napraviti konkurentni program koji stvara nit iz koje : pita korisnika za visinu u centimetrima i ispisuje : “ Vasa visina je <uneta_visina> cm. ” Testirati program tako sto ce se nit prevesti iz stanja joinable prvo operacijom join a nakon toga detach .
join - čeka da se nit završi
t. detach ( ) ;
Napraviti konkurentni program koji pokrece vise niti u petlji . Svakoj niti proslediti njen redni broj prilikom kreiranja i svaka nit treba da ispise dati broj u okviru tela niti .
Inicijalizacija svh niti
Čekanje da se sve niti izvrše
Napraviti program koji kreira jednu nit i u okviru niti ispisuje proizvoljnu recenicu
Čekanje da se nit završi
Definisati funkciju : void increment ( int & a ) ; koja povećava ( za jedan ) vrednost argumenta . Napraviti program koji : a ) poziva funkciju increment ( ) b ) stvara nit od funkcije increment ( )
Funkcija koja inkrementira prosleđeni parametar
Obično pozivanje funkcije
"Pozivanje funkcije iz niti ref ( ) - operator reference , obavezan ako rezultat treba da se sačuva"
"Napraviti konkurentni program koji izračunava sumu svih elemenata vektora , koristeći funkciju f ( ) : typedef vector <double> :: const_iterator ci ; void f ( ci pocetak , ci kraj , double & zbir ) ; Funkcija f nalazi se u fajlu suma_vektora . cpp . Potrebno je implementirati i funkciju sumiraj ( fajl vise_niti . cpp ) koja treba da pokrene dve niti i da svakoj niti prosledi polovinu elemenata ulaznog vektora . Obe niti treba da koriste funkciju f kako bi izračunale sumu svog dela vektora . Napomena : ovakva optimizacija sumiranja je značajna kada se radi na dvojezgarnom procesoru za vektore velike dužine ."
Promenljive za čuvanje rezultata
Iteratori
Pozivanje niti
Čekanje da se niti završe
"v - vektor cije elemente treba sumirati povratna vrednost - suma svih elemenata vektora , izracunata pokretanjem 2 niti ( svaka treba da obradi jednu polovinu elemenata )"
"Napraviti konkurentni program koji izračunava sumu svih elemenata vektora , koristeći funkciju f ( ) : typedef vector <double> :: const_iterator ci ; void f ( ci pocetak , ci kraj , double & zbir ) ; Funkcija f nalazi se u fajlu suma_vektora . cpp . Pri tome , """" ci """" je definicija tipa koja služi tome da se kraće zapisuje tip vector <double> :: const_iterator . Funkcija nema povratnu vrednost jer se rezultat prosleđuje kroz parametar """" zbir """" . Potrebno je implementirati i funkciju sumiraj ( fajl vise_niti . cpp ) koja treba da pokrene više niti i da svakoj niti prosledi jedan deo elemenata ulaznog vektora . Sve niti treba da koriste funkciju f kako bi izračunale sumu svog dela vektora . Podeliti računanje sume na N delova tako da svaka nit dobije relativno jednak broj elemenata . Taj broj elemenata treba da bude jednak : broj_elemenata_ulaza / N. Poslednja nit može dobiti i nešto veći broj elemenata na obradu u slučaju da ova dva broja nisu deljiva . Na primer : 1. 12 elemenata ulaza i 4 niti 12 / 4 = 3 -> 3 elementa ulaza se prosleđuju svakoj niti 2. 12 elemenata ulaza i 5 niti 12 / 5 = 2 ( celobrojno deljenje brojeva odbacuje deo broja iza decimalnog zareza ) 2 elementa se prosleđuju nitima 0 , 1 , 2 i 3. Nit broj 4 dobija preostala 4 elementa ."
"v - vektor cije elemente treba sumirati n - koliko niti treba pokrenuti povratna vrednost - suma svih elemenata vektora , izracunata pokretanjem n niti ( svaka nit treba da obradi jedan deo elemenata )"
"Napraviti konkurentni program ( koristeći funkciju f ()) koji sabira korespondentne elemente kontejnera a i b , a rezultat smešta u vektor zbir . typedef vector <double> :: const_iterator ci ; void f ( ci a_begin , ci a_end , ci b_begin , vector <double> :: iterator sum_begin ) ; Funkciju f implementirati u fajlu suma_vektora . cpp . Rezultat se upisuje korišćenjem iteratora sum_begin . Zato je neophodno da vektor nad kojim je kreiran taj iterator bude kreiran pre poziva funkcije f. Taj vektor mora da sadrži dovoljno mesta za upis svih elemenata . Funkciju sumiraj implementirati u fajlu vise_niti . cpp . Ova funkcija treba da pokrene dve niti koje će , koristeći funkciju f , da izračunaju korespondentne sume vektora . I to tako da svaka nit obradi svoju polovinu elemenata ( prva nit prvu polovinu , druga nit drugu polovinu ) . Program optimizovati za procesor sa 2 jezgra . Napomene : Podrazumeva se da su kontejneri a i b iste dužine . Sabiranje korespodentnih elemenata je sabiranje matrica ( vektora ) ."
Funkcija niti . Funkcija preuzima sledece parametre : 1 ) ci a_begin -> iterator na pocetak dela vektora a 2 ) ci a_end -> iterator na kraj dela vektora a ( dovoljan je samo jedan kraj ) 3 ) ci b_begin -> iterator na pocetak dela vektora b 4 ) vector <double> :: iterator sum_begin -> iterator na pocetak dela vektora suma
Vektor parcijalnih suma
Kreiranje iteratora
Maksimalno vreme cekanja
Maksimalan broj ljudi u redu
Funkcija koja simulira cekanje u redu sa n kupaca
Uzimanje vremena pre početka izvršavanja
Simuliranje čekanja
Uzimanje vremena nakon završetka izvršavanja
Ukupno čekanje
Simulacija čekanja
Pronalaženje reda u kojem se najduže čekalo
Pronalaženje maksimuma
"Napraviti konkurentni program koji pronalazi element najblizi 0 iz zadatog vektora brojeva . Posao podeliti u 3 niti . Vektor treba da sadrzi 90 elemenata . Elementi su pseudoslucajni brojevi dobijeni pozivom funkcije rand ( ) . Za svaku nit , evidentirati trenutke kada je izvrsavanje pocelo i kada je zavrsilo . Na kraju programa , ispisati koliko je trajalo izvrsavanje svake niti u milisekundama ."
Broj elemenata niza
Broj niti
Funkcija koja traži minimum
Traženje minimuma
Ukupno trajanje je razlika vremena kraja i početka
Popunjavanje vektora slučajnim brojevima
Potrebne niti
Traženje minimuma dobijenih minimuma
Ispis vremena trajanja
Prosiriti zadatak najbilzi_nuli_vreme . cpp ispisom u sekundama i minutima .
Data je klasa Brojac . U main funkciji napraviti objekat klase Brojac . Ispis vrednosti Brojaca radi posebna nit . Napraviti nit koja vrsi ispis i proslediti joj Brojac .
propusnica pripada klasi i obezbedjuje sprecavanje stetnog preplitanja pri vrsenju operacija nad objektima klase vrednost Brojaca
inicijalno je Brojac nula
"operacija povecava Brojac , ali pre toga zakljucava propusnicu i na taj nacin sprecava stetno preplitanja pri izmeni Brojaca"
"operacija smanjuje Brojac , ali pre toga zakljucava propusnicu i na taj nacin sprecava stetno preplitanja pri izmeni Brojaca"
"preklopljen operator za ispis objekta klase Brojac . Ispisuje se atribut """" broj """" iz objekta"
"pre pristupa broju , zakljucava se propusnica da bi se sprecilo stetno preplitanje"
Pozivanje nove niti
Funkcija koja inkrementira brojač ITERACIJA puta
Pozivanje funkcija iz različitih niti
Dobijeni rezultat nije nula zbog štetnog preplitanja koje se desilo između
Izmeniti program data_race . cpp i realizovati zaštitu pristupa brojaču uz pomoć klase mutex i njenih operacija lock ( ) i unlock ( ) . Primetiti koliko sada traje izvršavanje programa .
mutex za zaštitu brojača
"Dobijeni rezultat jeste nula , ali se vreme izvšavanja drastično povećalo"
2 mutexa
Funckija koja prebacuje iznos sa izvornog na ciljni račun
Zaključavanje resursa klasom unique_lock
Stara vrednost se čuva
Povećanje računa za datu vrednost
Sumiranje svih računa
Inicijalizacija računa
Ispisuje početno stanje banke
Niti koje će vršiti transfere
Ispisuje krajnje stanje banke
Napraviti konkurentni program koji u funkciji visina pita korisnika koliko je visok . Nakon toga korisnik unosi svoju visinu . Na kraju u funkciji se ispisuje uneta visina . Kreirati 2 niti od date funkcije . Ispratiti ispis .
"Funkcija koa učitava visinu , a zatim je ispisuje"
Onemogućava višestruki pristup resursu
Ukoliko je m već zaključan izvršavanje se neće nastaviti sve dok se m ponovo ne otključa
Omogućava drugim nitima koje su pozvale m. lock ( ) da zaključcaju m i nastave sa izvršavanjem
Konstanta koja govori koliko niti se ceka na zavrsetak pre nego sto se aktivira poslednja .
Metoda koju na svom KRAJU zovu niti ( a i b ) koje ne cekaju ( izvrsavaju se odmah ) .
Obaveštava drugu nit da se stanje promenilo
"Napraviti konkurentni program sa tri niti . Nit a ispisuje : Ja sam nit a. Nit b ispisuje : Ja sam nit b. Nit c ispisuje : Ja sam nit c. Obezbediti da se niti a i b , uvek izvrse pre niti c. Implementirati oznacene metode u klasi Koordinator u fajlu koordinator . h"
Obaveštava drugu nit da se završio
Blokirajuca funkcija koja se poziva na pocetku druge niti kako bi nit cekala dok se prva nit ne zavrsi .
Čeka dok se a ne izrši
Napraviti konkurentni program sa dve niti . Nit a ispisuje : Ja sam nit a. Nit b ispisuje : Ja sam nit b. Obezbediti da se uvek izvrsi prvo nit a. Implementirati oznacene metode u klasi Koordinator u fajlu koordinator . h
Globalni objekat Koordinatora ( kako bi mu pristupale obe niti ) .
Telo niti a.
"Metoda koju poziva nit koja simulira klijenta banke , kada klijent zatrazi kredit od banke . Ukoliko banka nema odgovarajuca sredstva kako bi omogucila kredit , metoda ce blokirati dok se ta sredstva ne oslobode . rbr - Redni broj klijenta svota - Novcani iznos koji je potreban klijentu valuta - Valuta u kojem je novcani iznos"
"Metoda koju poziva nit koja simulira klijenta banke , kada klijent vrati kredit koji je prethodno uzeo od banke . rbr - Redni broj klijenta svota - Novcani iznos koji je potreban klijentu valuta - Valuta u kojem je novcani iznos"
Vraćanje sredstava
rbr - Redni broj klijenta svota - Novcani iznos koji je potreban klijentu saldo - Ukupna raspoloziva sredstva u banci za trazenu valutu ( nakon odobrenja kredita ) valuta - Valuta u kojem je novcani iznos
rbr - Redni broj klijenta svota - Novcani iznos koji je potreban klijentu saldo - Ukupna raspoloziva sredstva u banci za trazenu valutu ( nakon sto je iznos kredita vracen ) valuta - Valuta u kojem je novcani iznos
klijent koristi pozajmljeni novac
tipovi valuta
"Definisati klasu Parking koja modeluje Parking prostor kapaciteta jednog mesta . Ova klasa ima operacije : void Parking :: udji ( ) ; void Parking :: izadji ( ) ; Automobili koji dolaze na Parking su predstavljeni nitima . Za ulazak na Parking , automobil poziva metodu udji ( ) . Za izlazak sa Parkinga , automobil poziva metodu izadji ( ) . Automobil se na Parkingu zadrzava 3 sekunde . Pri ulasku , ukoliko je Parking zauzet , automobil mora da saceka da se Parking oslobodi ."
void Parking :: udji ( ) ; void Parking :: izadji ( ) ;
"Metoda koju poziva nit koja simulira kretanje automobila kako bi automobil pokusao da se parkira . Ako je parking zauzet , izvrsenje ove metode ce trajati dok se parking ne oslobodi i auto se parkira . rbr - Redni broj automobila"
Ukoliko nema praznih mesta
Čeka dok se mesto ne oslobodi
Kad se oslobodi
Obaveštava drugu nit da se parking oslobodion
"Definisati klasu Parking koja modeluje Parking prostor kapaciteta N mesta . Kapacitet Parkinga proslediti kao argument konstruktoru , pri instanciranju deljene promenljive . Ova klasa ima operacije : void Parking :: udji ( ) ; void Parking :: izadji ( ) ; Automobili koji dolaze na Parking su predstavljeni nitima . Za ulazak na Parking , automobil poziva metodu udji ( ) . Za izlazak sa Parkinga , automobil poziva metodu izadji ( ) . Automobil se na Parkingu zadrzava od 1 do 3 sekunde . Pri ulasku , ukoliko je Parking zauzet , automobil mora da saceka da se neko parking mesto oslobodi ."
id - id procesa br_naredbi - broj naredbi koje proces treba da izvrsi
Metode koje se ticu obradjivaca U / I prekida
Funkcija niti koja simulira izvrsenje procesa
Funkcija niti koja simulira ulazno / izlazni podsistem
Pokretanje niti koja simulira ulazno / izlazni podsistem :
Pokretanje niti koje simuliraju procese :
Pomoćna metoda koja vraća referencu na objekat Dijagnostika asociran sa ovim objektom
"Ukoliko je procesor već zauzet i ne mogu se izvršavati naredbe procesa , potrebno je pozvati metodu dijagnostika . proces_ceka a nakon toga proces treba da pređe u stanje čekanja . Kada proces uspe da zauzme procesor , pre izvršenja naredbe treba da se pozove dijagnostika . proces_izvrsava . Nakon što je proces izvršio naredbu , potrebno je pozvati dijagnostika . proces_zavrsio ."
Ukoliko je procesor zauzet
Šalje se na čekanje
Početak izvršavanja
Izvršavanje
Kraj izvršavanja
Cooldown perion
"Ukoliko je procesor već zauzet i ne može se obaviti obrađivanje prekida , potrebno je pozvati metodu dijagnostika . obradjivac_ceka a nakon toga obrađivač treba da pređe u stanje čekanja , dok se procesor ne oslobodi . Kada obrađivač uspe da zauzme procesor , pre obrade prekida treba da se pozove dijagnostika . obradjivac_izvrsava . Nakon što je obrađivač završio obradu , potrebno je pozvati dijagnostika . obradjivac_zavrsio ."
id - id procesa adresa - adresa na koju je pokušan upis
"Napisati konkurentni program koji modeluje pristupanje više procesa deljenoj memoriji . Deljena memorija je predstavljena klasom Memorija . Prilikom instanciranja se zadaje veličina memorije ( ukupan broj lokacija koje postoje u memoriji ) . Upis vrednosti u memoriju se obavlja pozivom operacije Memorija . pisi , a čitanje pozivom operacije Memorija . citaj . I čitanje i upis svake vrednosti traje po 1 sekundu . Ove dve metode kao parametar prihvataju memorijsku lokaciju ( ona je izražena u bajtima / karakterima ) . Interno , sve lokacije koji čine memoriju mogu se predstaviti karakterima ( tip char ) . Iako metode Memorija . pisi i Memorija . citaj memoriju adresiraju po lokacijama , interno pristup pojedinačnoj lokaciji u klasi Memorija pogađa celu memorijsku reč kojoj lokacija pripada . Veličina memorijske reči je 4 bajta , tako da npr ako je zahtevan pristup lokacijama 0 i 3 , to je pristup prvoj memorijskoj reči kojoj obe ove lokacije pripadaju . Tokom upisa u memorijsku lokaciju ekskluzivno se zaključava cela memorijska reč kojoj ta lokacija ( bajt ) pripada . Dakle , operacija upisa ne dozvoljava da paralelno sa njom teče bilo koja druga operacija ( čitanje ili neki drugi upis u istu memorijsku reč ) . Tokom čitanja memorijske lokacije reč kojoj ta lokacija ( bajt ) pripada se može istovremeno čitati iz drugih niti . Treba omogućiti istovremeno pristupanje memorijskim lokacijama koje ne pripadaju istoj reči . Ako istovremeno postoje i procesi koji žele da čitaju i procesi koji žele da pišu u istu memorijsku reč , prvo treba procesi koji čitaju da dobiju pristup . Implementirati označene metode , konstruktor i dodati privatne članove u klasu Memorija ( fajl memorija . h ) ."
"Četiri niti upisuju vrednosti W. Z u adrese koje pripadaju različitim memorijskim rečima . Prema uslovima zadatka , ovi upisi treba da se obave istovremeno :"
Tip pristupa memoriji
Adresa kojoj se pristupa
Vrednost koja se upisuje ( samo ako je tip pristupa upis u memoriju )
Funkcija koju koriste niti koje simuliraju procese koji pristupaju memoriji :
"Četiri niti upisuju vrednosti A. D u četiri adrese prve memorijske reči . Prema uslovima zadatka , ovi upisi treba da se obave jedan za drugim ( iako su niti pokrenute istovremeno ) :"
"Četiri upisa , jedan za drugim , trajaće nešto više od 4 sekunde ."
"Nakon 3.5 s istovremeno se pokreće 8 niti . Namerno se pokreću dok prethodna grupa niti nije skroz završila , kako bi sve niti pokušale pristup memoriji dok je memorija još zauzeta prethodnim operacijama . Prve 4 niti pokušavaju da vrše upis u prve četiri lokacije . Druge 4 niti pokušavaju da vrše čitanje iz tih lokacija . Prema uslovima zadatka , trebalo bi da važi sledeće : 1. Prednost će imati niti koje vrše čitanje , tako da će se očitati vrednosti A. D. 2. Niti koje vrše čitanje će istovremeno izvršiti sva čitanja . 3. Nakon njih startuju niti koje vrše upis i one moraju da se izvršavaju jedna po jedna ."
Pisanje
Ukoliko ima čitača na čekanju
"pristup * , a ne pristup zato sto condition_variable ne može da se kopira"
Broj reči ( 4 bajta = jedna reč )
Ubacivanje reči u vektor
Metoda koju poziva nit koja simulira proces koji pristupa memoriji kako bi obavila čitanje iz nje rbp - Redni broj procesa adresa - Lokacija sa koje se čita vrednost prethodno upisana u memoriju
Potrebno je pozvati dijagnostika . proces_ceka_citanje kada je memorijska reč zaključana i proces mora da čeka . Potrebno je pozvati dijagnostika . proces_procitao onda kada je ostvaren pristup memoriji i kada je vrednost učitana iz nje .
Ukoliko je upis u toku
Kada dođe na red broj čitača se smanjuje
Čitanje
Kraj čitanja
Metoda koju poziva nit koja simulira proces koji pristupa memoriji kako bi obavila upis u nju rbp - Redni broj procesa adresa - Lokacija u koju se upisuje nova vrednost vrednost - Vrednost koja se upisuje u memoriju
Metode koje se odnose na simulaciju procesa
id - ID procesa
Metode koje se odnose na simulaciju U / I podsistema :
id_procesa - ID procesa čiji se zahtev obrađuje
id_procesa - ID procesa čiji je zahtev obrađen
"Napisati konkurentni program koji modeluje izvršavanje procesa u multiprogramiranom jednoprocesorskom okruženju . Procesi su predstavljeni nitima . Svaki proces ima skup instrukcija koje treba da izvrši , pri čemu postoje dva tipa instrukcija : STANDARD ( instrukcija zahteva određeno izračunavanje od procesora ) i UI ( zahtev za operacijom ulazno / izlaznog uređaja ) . U ovom zadatku , smer komunikacije sa UI uređajem je takav da proces inicira UI operaciju i pritom ostaje blokiran dok se ta operacija ne završi . Procesor je incijalno slobodan i zauzima ga prvi proces koji do njega dođe i pokuša da izvrši instrukciju . Sledi opis obrade STANDARD i UI instrukcija . OPIS OBRADE STANDARD INSTRUKCIJE : U sistemu je definisan maksimalan broj od 3 STANDARD instrukcije koje proces koji je zauzeo procesor može uzastopno da izvrši . Nakon što izvrši 3 STANDARD instrukcije , proces prelazi u stanje spreman a drugi proces iz liste spremnih dobija procesor . Na ovaj način na procesoru se vrši preključivanje između različitih procesa i omogućava se ravnomerna raspodela procesorskog vremena . Pri preključivanju nakon 3 STANDARD instrukcije treba voditi računa da se obezbedi mehanizam da proces koji oslobađa procesor ( a koji ima još preostalih instrukcija za izvršavanje ) ne pokuša da zauzme procesor ODMAH nakon puštanja . Ovo se postiže uvođenjem cooldown perioda od 100 ms . Iz liste spremnih procesa , naredni proces za izvršavanje se bira bez određenog pravila . Bilo koji od spremnih procesa prelazi u izvršavanje . Ukoliko neki proces nema više instrukcija , on završava svoj rad i prepušta procesor nekom od procesa iz liste spremnih procesa . Izvršavanje STANDARD instrukcije traje slučajan vremenski period između 10 i 50 ms čime se npr. simulira aritmetičko-logička operacija na procesoru . OPIS OBRADE UI INSTRUKCIJE : UI instrukcije predstavljaju zahteve za operacijom ulazno izlaznih uređaja i njih obrađuje UI podsistem ( preko niti ui_podsistem ) . UI podsistem REDOM opslužuje pristigle zahteve ukoliko takvi zahtevi postoje . Ako proces izvršava UI instrukciju on šalje zahtev UI podsistemu i odlazi u stanje čekanja radi završetka obrade UI zahteva . U čekanju proces otpušta procesor ( tokom čekanja na UI obradu nema smisla da se drži procesor ako drugi procesi mogu da ga koriste ) i tada bilo koji drugi proces iz liste spremnih procesa dobija procesor . UI instrukcija takođe prekida niz STANDARD instrukcija što znaci da se broj prethodno izvršenih STANDARD instrukcija za dati proces prilikom nailaska na UI instrukciju resetuje na 0. Kada UI podsistem obradi zahtev , proces koji je čekao obradu zahteva može da odmah postane aktivan ( ukoliko je procesor slobodan ) ili se uvezuje u listu spremnih procesa ( ukoliko procesor koristi neki drugi proces ) . Operacija UI uređaja traje slučajan period između 100 i 300 ms . Implementirati označene metode , konstruktor i dodati privatne članove u klasu OS ( fajl os . h ) ."
9:1 šanse da će biti STANDARD instrukcija
Kreiranje niti koja simulira U / I podsistem :
Kreiranje niti koje simuliraju procese :
Metoda koju poziva nit koja simulira obrađivač U / I zahteva kako bi se obradili trenutno pohranjeni U / I zahtevi .
"Potrebno je pozvati dijagnostika . ui_ceka kada ne postoje trenutno pohranjeni U / I zahtevi i obrađivač čeka na prvi . Potrebno je pozvati dijagnostika . ui_zapocinje kada obrađivač krene u obradu U / I zahteva . Kada obrađivač završi taj zahtev , potrebno je pozvati dijagnostika . ui_zavrsio ."
Ako nema zahteva ide na čekanje
Obrada
Kraj obrade
"Red zahteva ( mora zahtev * , a ne zahtev zato što condition_variable ne može da se kopira )"
Metoda koju poziva nit koja simulira proces kako bi se izvršile sve instrukcije procesa . p - Struktura koja sadrži opis procesa ( ID procesa i instrukcije koje treba izvršiti )
"Ukoliko proces ne može da se izvrši ( procesor je zauzet ) , proces mora da se uveže u red spremnih i treba pozvati metodu dijagnostika . proces_ceka . Ukoliko dođe do toga da izvršenje procesa prestaje ( dostignut je maksimalan dozvoljen broj uzastopnih STANDARD instrukcija ili su sve instrukcije procesa izvršene ) , potrebno je pozvati dijagnostika . proces_oslobadja_procesor . Kada se izvrši STANDARD instrukcija nekog procesa , potrebno je pozvati dijagnostika . proces_izvrsio_standardnu . Kada se izvršava UI instrukcija , potrebno je pozvati par metoda : dijagnostika . proces_ceka_na_UI kada se pokrene U / I operacija ( nakon čega sledi čekanje na U / I podsistem ) i dijagnostika . proces_zavrsio_UI kada se završi U / I operacija ."
Broj izvršenih instrukcija
Ide na čekanje
Zauzimanje procesora
Ukoliko je izvršeno maksimalno dozvoljeno naredbi ili nema više instrukcija
Oslobađa se procesor
Obaveštava se sledeći proces
Cooldown period
Čekanje da se zahtev obradi
Proces ide na čekanje i sledeći spreman se obaveštava
Tip instrukcije :
id_procesa - id procesa koji je učitan i kreće u izvršenje
Ukupan broj okvira u radnoj memoriji
Ukupan broj procesa koji se izvršavaju
dijagnostika - referenca na instancu klase Dijagnostika ukupno_okvira - ukupan broj okvira u memoriji
Metoda koju poziva nit koja simulira izvršenje procesa kako bi pokušala da učita proces u radnu memoriju broj_stranica - ukupan broj stranica koje proces sadrži id_procesa - identifikator procesa
Kada ima radne memorije
Zauzima slobone lokacije dok ih ne zauzme dovoljno
id_procesa - id procesa koji čeka
id_procesa - id procesa koji se pokreće br_lokacija - broj memorijskih lokacija neophodnih procesu za rad
id_procesa - id procesa koji je zauzeo okvire pocetak - prvi okvir memorije koji je zauzet kraj - poslednji okvir memorije koji je zauzet
Funkcija niti koja simulira servis operativnog sistema koji se bavi sažimanjem memorijskih lokacija :
Scenario je napravljen tako da proces 5 ne bi mogao da se ubaci u memoriju da ne postoji sažimanje memorijskih lokacija :
Traži prvi deo memorije koji nije ničiji
Ide dok ne naleti na prvi zauzeti okvir ili kraj
Obaveštava da je završio sa sažimanjem
"Ukoliko trenutno nema na raspolaganju dovoljno slobodne memorije ( moraju se zauzeti uzastopni okviri u memoriji ! ) , potrebno je pozvati metodu dijagnostika . proces_ceka a nakon toga proces treba da čeka dok se memorija ne oslobodi . Kada proces uspe da dođe do potrebne radne memorije , treba da se pozove dijagnostika . proces_zauzeo_okvire . Kada se proces završi , potrebno je pozvati metodu dijagnostika . proces_zavrsio . Metodu dijagnostika . ispisi_memoriju potrebno je pozvati u sledećim momentima : nakon što proces zauzme memoriju i nakon što proces oslobodi memoriju ."
Ukoliko nema dovoljno okvira proces čeka
Potraga za prvim slobodnim mestom i zauzimanje
Kraj zauzimanja
Oslobađanje
Ukoliko je već sažeta
Proces sažimanja
n - naredba koju je potrebno ispisati u string Vraća string koji sadrži opis naredbe
"n - naredba koja je izvršena slobodno_ram - koliko RAM memorije je ostalo slobodno nakon izvršenja naredbe zauzeto_vm - koliko VM je zauzeto do sada ( ukupno , ne samo ovom naredbom )"
Funkcija koju koristi nit koja simulira servis operativnog sistema za zauzimanje ( alokaciju ) virtuelne memorije :
Ima 100 MB RAM memorije
Struktura koja modeluje 2 tipa naredbe - ili malloc ili repeat
Struktura koju vraća program nakon pokušaja zauzimanja memorije
Ako ima dovoljno memorije
Zauzima ram
Pozove se zauzimanje virtuelne
lock i unlock ne smeju da postoje
Provera tipa naredbi
Vraćanje vrednosi
Završavanje i obaveštavanje drugih niti
"Ubacivanje novog para ključ-vrednost u mapu ( ključ je privezak , vrednost je cv_data )"
"Kada se ispunio uslov , briše se cv_data iz memorije kao i pair struktura iz mape ."
"Prolazi se kroz mapu i traži se ključ ( privezak ) Kada se nađe privezak , polje fulfilled cv_data strukture ( vrednosti ) se postavlja na true . Obaveštava se nit koja čeka na datoj cv_data ."
"Notifikacija svih na CV sa privescima , prolazi se kroz mapu svih i obaveštavaju se jedan po jedan :"
"Destruktor mape , brišu se sve vrednosti jer su dinamički genreisane ( vidi metodu wait ) :"
Klasa cv_tag simulira condition varijablu sa privescima gde je moguće obaveštavati niti po izabranom privesku
Stvaraju se zasebne CV za svako novo čekanje . Ove CV se nalaze u cv_data strukturi .
Mapa prethodno opisanih struktura kako bi se moglo stavljati i brisati iz mape sa proizvoljnih mesta
id_procesa - ID procesa koji mora da čeka kako bi se procesor oslobodio
id_procesa - ID procesa koji je izvršio naredbu naredba - indeks naredbe koja je upravo zavrsena sledeci_proces - ID procesa koji će se sledeći izvršavati
"Napisati konkurentni program koji simulira lutrijski raspoređivač u jednoprocesorskom sistemu . Procesi su predstavljeni nitima . Da bi se izvršili pozivaju metodu """" izvrsi """" deljene promenljive tipa Rasporedjivac . Svaki proces sadrži određeni broj naredbi . Naredbe se izvršavaju jedna po jedna . Za svaku naredbu , proces mora da sačeka da procesor bude slobodan . Izvršavanje jedne naredbe traje 300 ms . Nakon izvršavanja naredbe , proces odlazi u stanje spreman , a drugi spreman proces dobija procesor . Lutrijski raspoređivač se zasniva na tome da je svakom procesu inicijalno dodeljen određeni broj tiketa . Pri izboru sledećeg procesa za izvršavanje , na slučajan način se bira jedan tiket . Proces kojem je dodeljen taj tiket postaje aktivan . Dodelom različitog broja tiketa procesima se implicitno uspostavljaju priroriteti među njima , obzirom da proces sa većim brojem tiketa ima veće šanse da bude izabran ."
Na slučajan način se dodeljuje određeni broj tiketa procesu :
Bilo koji slobodan tiket
Ovaj tiket je dodeljen pa se izbacuje ( ne sme biti dupliranih tiketa )
"Ukoliko je procesor već zauzet i ne mogu se izvršavati naredbe procesa , potrebno je pozvati metodu dijagnostika . proces_ceka a nakon toga proces treba da pređe u stanje čekanja . Nakon što je proces izvršio naredbu , potrebno je pozvati dijagnostika . izvrsio_naredbu ."
Mapiranje svih tiketa na dati proces
Ukoliko procesor pripada drugom procesu
Izvrši se
Izbacuju se svi njegovi tiketi iz mape
Biranje sledećeg procesa na osnovu izvlačenja tiketa
Buđenje procesa čiji je tiket izabran
Ukoliko nema tiketa
Funkcija koju izvršavaju niti koje simuliraju izvršenje procesa :
Funkcija niti koju izvršava nit koja simulira raspoređivač operativnog sistema :
"Metoda koju poziva nit koja simulira raspoređivač operativnog sistema , kako bi se izabrao sledeći proces za izvršenje ."
"Ukoliko još uvek ne postoji potreba da se raspoređivač aktivira , potrebno je pozvati metodu dijagnostika . rasporedjivac_ceka a nakon toga nit treba da pređe u stanje čekanja . Nakon što se raspoređivač aktivirao i izabrao sledeći proces , potrebno je pozvati dijagnostika . rasporedjivac_izvrsio ."
Ukoliko ima procesa
Pokretanje procesa
"skidanje strukture sa vrha reda ( FIFO ) , i brisanje strukture iz memorije"
"metoda ogranicenog cekanja na cv_hrono funkcionise veoma slicno kao metoda wait , sa tim sto ako se desi timeout prekida se cekanje"
"funkcionise veoma slicno kao metoda wait , sa tim sto ako se desi timeout prekida se cekanje"
stvara se nova struktura cv_pair kada se ulazi u wait ova struktura se stavlja na kraj reda ccv ( FIFO ) na ovoj strukturi se ceka dok se bool fulfilled ne postavi na true i tek tada se izlazi iz cekanja
metoda notifikacije na cv_hrono
ukoliko nema nikoga u cekanju vraca se false
"ukoliko ima nekog , uzima se prvi iz reda cekanja ( FIFO ) i obavestava se"
klasa cv_hrono simulira hronolosku condition_variablu tj. fifo CV da bi se ovo omogucilo stvaraju se zasebne CV za svako novo cekanje ove CV se nalaze u cv_pair strukturi
Double ended queue deque prethodno opisanih struktura kako bi se moglo stavljati na kraj i brisati sa pocetka ( FIFO )
id_procesa - ID procesa koji je upravo kreiran broj_naredbi - broj naredbi koje proces treba da izvrši
"Napisati konkurentni program koji simulira raspoređivanje po algoritmu povratne sprege u jednoprocesorskom sistemu . Procesi su predstavljeni nitima . Da bi se izvršili pozivaju metodu """" izvrsi """" deljene promenljive tipa Rasporedjivac . Svaki proces sadrži određeni broj naredbi . Naredbe se izvršavaju jedna po jedna . Za svaku naredbu , proces mora da sačeka da procesor bude slobodan . Izvršavanje jedne naredbe traje 300 ms . Nakon izvršavanja naredbe , proces odlazi u stanje spreman , a drugi spreman proces dobija procesor . Procesi su klasifikovani prema prioritetu . 0 je najviši prioritet dok je N najmanji ! Za svaki prioritet , postoji odvojen red čekanja na procesor . Prednost u korišćenju procesora imaju procesi sa višim prioritetom . Među procesima istog prioriteta , sledeći proces se bira po FIFO principu . Prioritet procesa se određuje dinamički u toku izvršavanja procesa . Na početku rada , proces ima najviši prioritet . Kada izvrši naredbu , prelazi na jedan nivo prioriteta ispod . Nakon svake naredbe , procesu se smanjuje prioritet za jedan nivo , dok ne dođe do najnižeg prioriteta . Ako je došao do najnižeg prioriteta , na tom prioritetu ostaje do kraja izvršavanja ."
Funkcija koju koriste niti koje simuliraju izvršenje procesa :
"Metoda koju poziva nit koja simulira izvršenje procesa , kako bi se proces izvršio id_procesa - ID procesa broj_naredbi - ukupan broj naredbi koje proces treba da izvrši"
na početku ima najviši prioritet
Smanjuje se prioritet ako je to moguće
Traži najprioritetniji spreman proces
Ukoliko je našao red
Ukoliko nema više procesa
"Specijalna klasa koja služi za modelovanje jednog reda čekanja , u jednom nivou prioriteta"
Konstruktor stvara novu CV dinamički
Notifikacija će na hronološkoj CV probuditi PRVOG koji je ušao u čekanje
Skidanje ID-a procesa koji je izašao iz čekanja
Brisanje ID-a iz reda spremnih
id_procesa - ID procesa koji je upravo kreiran prioritet - prioritet procesa ( 0 - najviši prioritet ) broj_naredbi - broj naredbi koje proces treba da izvrši
id_procesa - ID procesa koji je izvršio naredbu naredba - indeks naredbe koja je upravo zavrsena
"Napisati konkurentni program koji simulira prioritetni raspoređivač u jednoprocesorskom sistemu . Procesi su predstavljeni nitima . Da bi se izvršili pozivaju metodu """" izvrsi """" deljene promenljive tipa Rasporedjivac . Svaki proces sadrži određeni broj naredbi . Naredbe se izvršavaju jedna po jedna . Za svaku naredbu , proces mora da sačeka da procesor bude slobodan . Izvršavanje jedne naredbe traje 300 ms . Nakon izvršavanja naredbe , proces odlazi u stanje spreman , a drugi spreman proces dobija procesor . Procesi su klasifikovani prema prioritetu . 0 je najviši prioritet dok je N najmanji ! Za svaki prioritet , postoji odvojen red čekanja na procesor . Prednost u korišćenju procesora imaju procesi sa višim prioritetom . Među procesima istog prioriteta , raspoređivanje se obavlja po FIFO principu ( tj. ciklično će se smenjivati različite naredbe procesa istih prioriteta na procesoru ) . Prioritet procesa je određen statički u trenutku kreiranja procesa . Za uspostavljanje reda čekanja po FIFO principu koristiti datu klasu """" cv_hrono """" ."
"Metoda koju poziva nit koja simulira izvršenje procesa , kako bi se proces izvršio id_procesa - ID procesa broj_naredbi - ukupan broj naredbi koje proces treba da izvrši prioritet - prioritet procesa"
id_procesa - ID procesa čiji je zahtev prosleđen U / I uređaju broj_staze - broj staze koji je potrebno obraditi ( u sklopu ovog zahteva )
id_procesa - ID procesa koji čeka kako bi njegov zahtev ka U / I uređaju bio obrađen broj_staze - broj staze koji je potrebno obraditi ( u sklopu ovog zahteva )
broj_staze - broj staze koji je upravo obrađen
"Napisati konkurentni program koji simulira raspoređivanje diska po FIFO ( First in First out ) principu . Kod ovog načina raspoređivanja diska , UI zahtevi se obrađuju prema redosledu dolaska . Klasa OS predstavlja deo operativnog sistema koji je zadužen za raspoređivanje zahteva . Metodu uputi_UI_zahtev pozivaju niti koje predstavljaju procese . U ovoj metodi prosleđuje se zahtev UI uređaju da izvrši UI operaciju na određenoj stazi diska . Proces mora da sačeka da zahtev bude izvršen , pre nego nastavi dalje izvršavanje . Metodu obradi_zahtev poziva nit koja predstavlja disk . Metoda je zadužena da obradi jedan zahtev iz skupa zahteva . Zahtev za obradu se iz skupa zahteva bira po FIFO principu . Obrada zahteva traje 300 ms . Rezultat metode je broj staze kojoj je disk pristupio pri obradi zahteva ."
Funkcija niti koju koriste niti koja simuliraju izvršenje procesa :
Funkcija niti koju koristi nit koja simulira deo operativnog sistema koji upravlja diskom :
Čekanje da pristignu svi zahtevi
Kašnjenje pri slanju zahteva kako ne bi svi zahtevi istovremeno pristigli
Struktura zahteva koja sadrži sve potrebne informacije za kreiranje istog
Red za zahteve
"Metoda koju poziva nit koja simulira izvršenje procesa , kako bi se uputio zahtev ka U / I uređaju id_procesa - ID procesa koji upućuje zahtev broj_staze - broj staze diska kojoj nit želi da pristupi"
"Metoda treba da formira novi zahtev i uputi ga U / I uređaju na obradu . Proces će biti blokiran dok god se ovaj zahtev ne izvrši . Pre nego što stupi u blokadu , potrebno je pozvati dijagnostika . proces_ceka ."
Obaveštava obrađivač da ima zahteva
"Metoda koju poziva nit koja simulira deo operativnog sistema koji upravlja diskom , kako bi se obradio jedan pristigli zahtev Prema uslovima zadatka , metoda treba da obradi zahtev koji je najranije pristigao . Povratna vrednost metode treba da bude broj staze koji je obrađen ."
Izvršava zahtev
Traži najbliži blok trenutnom
id_procesora - ID procesora koji je učitao vrednost iz memorije adresa - adresa sa koje je očitana vrednost vrednost - vrednost koja je pročitana iz memorije
id_procesora - ID procesora koji je zatražio DMA transfer
odakle - adresa u memoriji odakle počinje DMA transfer koliko - koliko karaktera se kopira iz memorije kome - destinaciona adresa - na nju se upisuju očitani karakteri
"Stanja sabirnice - slobodna , čitanje iz memorije , pisanje u memoriju , dma transfer ."
"Primetiti sličnost sa stanjima iz zadatka """" multiprocesor """" :"
Čekanje za zauzimanje propusnice
Ukoliko nema zahteva čeka
Kada se pojavi
Funkcija niti koju izvršavaju niti koje simuliraju procesore :
Funkcija niti koja simulira DMA kontroler :
Upis
? - pošto se ne zna šta je u memoriji na početku
Vreme čekanja
Vraća bajt sa date adrese
Piše bajt na datu adresu
Ispisujemo korisniku menü
Ispis gradova za unesenu državu
Hvatalica grešaka
* @author Vedran Vidakovic
prilikom logina ako zelimo da odustanemo i vratimo se na početak
klik na dugme admin na pocetku programa
klik na dugme OK prilikom login admina
dugme za pregled racuna prilikom lookup gosta tab2 admin window
pregled racuna na prozoru gosta
ucitavanje podata za prikaz racuna
odjava gosta iz hotela
brisanje notifikacije za check out
provjerava bazu da li ima vec username i pass od prije za korisnika sa datim idnumberom
editovanje podataka o gostu tab2 admin windows guest lookup and change podataka
Halim
panel za prikaz informacija
uzet iz baze
close app button
polje za unos password
* @author Vedran Vidakovic & Sefer Kuduzovic *
pozivamo metode za tablu i brodove
string u kojem se nalaze riječi za pogađanje
uzima neku random rijec iz našeg niza
"ako jeste , brisemo zvjezdicu na poziciji pogodjenog slova i stavljamo slovo"
* Author : Sefer Kuduzovic
unos mjeseca i godine :
"Početni dan u mjesecu je stavljen za 1 , mada se može napraviti i da se mijenja , tj da korisnik unese dan ."
printa prazan prostor dok ne dođe tačan dan koji se poklapa sa prvim u mjesecu
"metoda koja igra igru """" Craps """" po utvrđenim pravilima ako korisnik izvuce broj 7 ili 11 , vraca da je pobijedio ako izvuce 2 , 3 ili 12 , vraca da je izgubio inače baca ponovo te provjerava da li je izvuako isti broj ako je izvukao isti broj , pobijedio je , ako je izvukao 7 , izgubio , ako ni jedno od tog dvoga baca se ponovo"
unos kreditne kartice
postavlja token trenutnog igrača u to polje
promjena turna - tj. ko je na redu
te ispisuje ko je na redu u status labelu
"nakon petlje , dodajemo tu sve u grid te njega dodajemo u naš """" box """""
"obavijamo čitav kod sa try / catch , za hvatanje grešaka"
i printamo rezultat
"koji se zatim parsira metodi toBinaryString koja vraća binarni broj našeg """" broja """" te se zatim dodaju nule sa strane , čime se efektivno ispisuje tačno 16 bita"
korisnik unosi broj
"pozivanje metode , te print rezultata"
provjera da li je širina veća od broja
"u listu ubacujemo brojeve koji se ponavljaju , a niz koristimo da vidimo koji su to brojevi"
i sve se to fino ispisuje
"niz nam sluzi kao brojac , ako dobijemo random broj npr 2 ; onda će se povećati niz [ 2 ] za 1 .."
petlja se vrti 100 puta
"ako prođe petlju , vraća broj"
prvo generišemo neki random broj
"te se ona salje metodi , i provjerava se šta nam je vratila ako je true , ispisuje poruku da ima 4 uzastopna , else , ispisuje da nema"
"ako slucajno unese vecu kolonu nego sto je zadata , prekida se program ."
pravi se matrica velicine brojRadnika x brojDana
te mu se printaju dani da se lakše snađe za unos
"te se dodaje u listu , i resetuje , da moze za sljedećeg radnika da sabire"
metoda koja mnozi dvije matrice
formula za mnozenje 3 x3 matrice
preskace se prvi red jer nema potrebe da se provjerava sam sa sobom
vrtimo loop dokle god ima redova
"ako nema više redova , povećavamo kolonu"
te poslije sortiranja
te metoda koja vraća tu kamatu
pozivamo metodu te printamo rezultat
"pitamo korisnika za velicinu matrice , nakon cega on unosi elemente u istu"
"šaljemo matrice metodi , koja vraća """" boolean """" tip , nakon čega provjeravamo dati """" return """" te shodno time ispisujemo poruku :"
te šaljemo brojeve metodi na sortiranje
"standardna petlja za sortiranje prolazimo kroz brojeve , te shodno tome gledamo da li je broj """" j """" veći od sljedećeg ako jeste , mijenjaju mjesta ( values ) i idemo dalje"
"pravimo niz """" brojevi """" u kojeg ubacujemo generisane brojeve"
podizanje i polaganje novca // test //
kojeg vraćamo ..
"metoda koja postavlja radius provjerava da li je veći od 1 , tj ne može biti manji od 1 .."
y koordinata
konstruktor sa parametrima
metoda za računaje diskriminante
informacije
vraća rješenje za X
vraća rješenje za Y
"ako se jednačina može riješiti , ispisuje rezultat"
metoda za provjeru da li su brojevi jednaki
prosljeđivanje karaktera u cifru via Integer . parseInt ( ) ;
"input metoda za provjeru da li je broj """" prime """""
"ako nema djeljivih brojeva , onda je broj prost"
prime = djeljiv samo sa sobom i sa 1
pozivanje klase vraća trenutno vrijeme !
"ako želimo sami postaviti trenutno vrijeme , pozivamo ovu metodu :"
/ < -- testiranje dalje -- > \
pozivanje metode za računanje distance i njen rezultat
petlja za print liste
lista za brojeve
ispisujemo ga
"furka kod BigIntegera je da se može pozvati metoda koja provjerava da li je prime so , we do that"
"ako je prime , ispisuje ga , that's it ."
metoda pretvara karakter u veliko slovo
vraća char od - do unesenog intervala
provjera dužine broja
"ako su iste dužine , upoređuju se , slovo po slovo"
od malih slova postaju velika
"od toga kakvo je boolean """" b """" , shodno tome vraća rezultat"
korisnički def . string
za vraćanje stringa
"prvo pretvaramo regex u niz karaktera , jer će nam tako biti lakše prepoznati ga u našem stringu"
"nakon što završe petlje , smještamo iz ArrayListe u niz , te vraćamo rezultat"
unos generisanih vrijednosti u matricu i stampanje matrice
"petlja prolazi kroz listu i sabire brojeve , te ih return vraća"
pomoću petlje provjeravamo da li imamo iste brojeve u listama
provjerava da li je lista null / prazna
pozivanje liste
brojaci samoglasnika i suglasnika
"petlja provjerava najveci djelilac izmedju ta dva broja , te zamjenjuje max vrijednost sa trenutnom najvecom sa kojom se oba broja mogu dijeliti"
to je ta fensi metoda
generišemo 100 random brojeva :
dva niza - jedan za 100 random brojeva drugi za brojanje koliko se puta taj broj ponovio
glava programa .. ovdje se magija odvija :
petlja prolazi s pozada ka početku
izdvaja se karakter
lista za smijestanje linija teksta iz fajla bez unijete rijeci
"nakon unosa od korisnika , prosljedjujemo fajl metodi"
"petlja koja prolazi kroz sve godine , te ako je godina prestupna , dodaje je u listu"
glavni dio programa koji generiše pitanja
"metoda prima broj bacanja , te na osnovu toga vrsi racunanje"
metoda koja provjerava da li je broj prost
printanje rezultata
slanje nizova metodi :
korisnik unosi niz :
"pravimo novu matricu , koja ce se sortirati"
saljemo matricu u metodu
"kada metoda uradi svoje , printamo sortiranu matricu"
metoda koja sortira uzetu matricu
while petlja vrti dokle god se moze broj dijeliti
metoda ih strpa u niz
koji sortira
i ispiše .
"ako uneseni broj nije 0 , unosi se u listu te se povecava brojac i sabire se sa proslim unosom"
"ako nije uneseno brojeva , ispisuje da se ne moze dijeliti sa nulom i prekida program"
sve se to na kraju fino ispise
korisnik unosi koliko želi da štedi mjesečno
te zatim unosi koliko mjeseci zeli da stedi
ovdje se racuna mjesecna stopa
te se smanjuje broj simulacija za 1
pravimo niz u koji ce se unositi brojevi
"zatim provjerava da li ima """" spejsinga """""
godisnja interesna stopa se dijeli sa 100 da se dobije procenat
buduca vrijednost investicije se računa po datoj formuli
pomjeranje zareza za jedno mjesto u lijevo kod unesenog broja
dodavanje odvojene cifre novom broju
ako je broj jednak svom naopakom ispisu on je palindrom
odvajanje slova iz rečenice
te njihov zbir
"dok korisnik ne unese tacan rezultat , vrti se loop"
postavljanje pitanja
upisivanje svih djelitelja za trenutni broj u listu
sadrzaj liste se brise
prolazak kroz password slovo po slovo ( broj po broj :O )
"provjeravanje da li password ima dovoljno ukupno karaktera i dovoljno brojeva , i stampanje odgovarajuceg rezultata"
kalkulacije za racunanje dana :
radius Zemlje
te prelazi u novi red ako je ispisano 10 linija
da li je broj djeljiv i sa 5 i sa 6
uzimanje broja milisekundi
"petlja sabire trenutni broj sa prethodnim , te se zamjenjuju mjesta"
metoda za računanje te sume brojeva po zadatom principu .
rekurzivna metoda za računanje
unosi se pocetna i krajnja godina
provjera liste za twin prime brojeve
pravljenje kombinacija pomoću dvije petlje
prolazak kroz citav string
provjera da li je drugi string substring prvog stringa
pitamo korisnika koliko zeli unijeti gradova :
te se oni sortiraju :
"ako je broj prost , on se stampa te se povecava brojac"
"racunanje ostatka , broj dana koji ne čine jednu cijelu godinu"
broj se dodaje na sumu
"ako je broj pozitivan , povecava se brojac za pozitivne brojeve"
racunanje prosjeka unesenih brojeva
generisanje cetri broja
povecavanje brojaca prostih brojeva
da bi broj bio prost mora biti veci od jedan
sortiranje liste
lista za smijestanje brojeva
"ako je sve ok , broj se salje metodi"
metoda za ispis broja :
odvajanje zadnjeg broja od unosa
petlja se vrti dok ne dobijemo 100 emirp brojevaa :)
petlja se vrti dok ne dobijemo 100 palindrome emirp brojevaa :)
provjerava je li broj palindrom i da li je prost
informacije o drugom pakovanju
mjeseci smjesteni u niz iz kojeg se printa
"ako petlja dodje do kraja , prelazi se u novi red"
unosi se n ( n x n ) od matrice
"korisnik unosi svoj string , rečenicu , šta god hoće"
preuzeto sa stranice stackoverflow.com http://stackoverflow.com/questions/4087468/ssn-regex-for-123-45-6789-or-x-xx-x
"provjera štapmanja System . out . println ( ) ; pa onda desna strana , tj 1 2 3 4 5."
"inače se štampa malo manje , zbog veličine dvocifrenih brojeva"
prelazi se u novi red
* Funkcija popunjava horizontalBox-ove sa adektvatnim slikama i * informacijama o autorima programa .
"* Funkcija definise reakciju prozora na esc dugme na tastaturi ili pak * pritisak na dugme """" Close """" . Prozor se sakriva ."
moze samo graph da bude
* Piše po streamu sve podgrafove nekog grafa * * @param out * @param graph
* Ispisuje sve grafove sa svim svojim podacima * * @param out
uklanjanje sa selektovanog grafa propertija
* Vrši registraciju svih default komandi u Coru . Ukoliko baci * ExGCommandAlreadyExistException znači da je komande već registrovala neka * konzola .
* OSGI context u okviru koga se pokrece ConsoleService
* Određuje da li se caret nalazi pre kraja prompta * * @return da li se nalazi pre kraja prompta
* Realizuje cutovanje teksta sa konzole ( doCopy + delete )
* Vrši ispis u textPane * * @param text * koji želimo da ispišemo .
* Uklanja sve listenere konkretne konzole po zatvaranju taba
ako je obrisan bas taj node koji je u konzoli aktivan
"* Obrađuje događaje koji su u vezi sa tabovima ( promena imena , zatvaranje ) . Ove * događaje ispaljuje TabManager , za razliku od ActiveTabChangedListener-a čije * događaje ispaljuju komande ! *"
pokusavamo da izvrsimo komandu
ako je samo jedna komanda nju izvrsavamo
"prvo moramo da kreiramo Core , jer od njega zavise servisi koji rade sa ostalim komponentama"
vadim set i vrednosti
* Vraca vrednost datog parametra u obliku stringa . Ukoliko pod zadatim * ključem nema vrednosti vraćena vrednost će biti <em> null </em> . * * @param category * Kategorija ( komponenta ) u kojoj se nalazi parametar * @param key * Naziv parametra * @return String koji sadrzi vrednost parametra
"* Dodaje pod kategoriju <em> category </em> i pod ključem <em> key </em> * vrednost <em> value </em> . Ukoliko kategorija ne postoji , dodaće se nova , * koja je zadata . Ukoliko u zadatoj kategoriji pod zadatim ključem postoji * neka vrednost , ta vrednost će biti zamenjena novom . * * @param category * Kategorija u koju se dodaje * @param key * Ključ za koji se dodaje * @param value * Vrednost koja se dodaje"
* Registar podataka koje komponente mogu da razmenjuju .
* Kontekst u kome se komponenta izvršava unutar OSGI Fremework-a .
* Dodaje podmeni u glavni meni * * @param menu * naziv glavnog menija u koji podmeni treba da se doda . * @param submenu * Podmeni koji se dodaje
* Konstante za određivanje po čemu sorted metoda sortira
* Panel sa svim toolbar-ovima
* Mapa svih toolbar-va koji se pojavljuju na glavnom prozoru
* Registruje novi meni . * * @param menuCode * Kod novog menija * @param menuName * Ime novog menija .
"* Implementira akciju promene naziva tab-a , konteksnog menija { @link TabPanel tabPanel-a } ."
@author Tim 2 *
pomeri ako je pritisnuto
iscrtaj ivicu
levi taster ?
"* Konstruktor , samo inicijalizuje * * @param tabPanel { @link TabPanel tabPanel } čiji se događaji miša obrađuju"
"* Vraća { @link Boolean } vrednost da li se naziv tab-a može menjati . * * @return { @link Boolean } - <code> true </code> može se menjati , * <code> false </code> ne ."
* { @link Map Mapa } koja sadrži panele
* Uklanja idikator sa kanvasa
@author Tim 2 *
* Predstavlja panel koji sadrži { @link ExGGraphicalComponent komponente }
"ako postoji , postavi njen tab kao aktivan"
* ( non-Javadoc ) * * @seejavax . swing . TransferHandler #importData ( javax . swing . TransferHandler . * TransferSupport )
* Odredišni čvor .
* Vraća prethodni izgenerisani ID. * @return
neusmerene grane
ne pazi se -> dodajemo sve .
* { @link tk . exgerm . core . model . IGraph Graf } kroz koji se trenutno iterira
* ima vishe slucajeva treba na sve obratiti paznju
pazi se na usmerenje
* Za rad sa eventovima
* DefaultIterator nikada ne brine o usmerenju grana .
* DefaultIterator nema mogucnost psotavljanja startnog noda .
* Kreira novu { @link tk . exgerm . core . model . IEdge granu } sa zadtim izvornim i * odredišnim čvorom . * * @param from Izvorni { @link tk . exgerm . core . model . INode čvor } * @param to Odredišni { @link tk . exgerm . core . model . INode čvor } * * @return Novokreiranu granu
* Vraća graf kome pripada * * @return Graf kome pripada
* Dodaje novi { @link tk . exgerm . core . model . INode čvor } u graf . * * @param node * Čvor koji se dodaje * * @throws ExGNodeAlreadyExsistException * Ukoliko nod sa istim imenom već postoji u grafu .
* Uklanja granu iz grafa . * * @param edge * Grana koja se uklanja
* Označava događaj da je izbačena grana iz grafa . * * Parametri : * <ol> * <li> graph : IGraph - graf iz koga je grana izbačena </li> * <li> edge : IEdge - grana koji je izbačena </li> * </ol>
* Vraća atribut tipa Object sa zadatim imenom . Odgovornost klijenta je da * ga cast-uje u odgovarajuću klasu . * * @param attr * Naziv atributa * @return Vrednost atributa
* Predstavlja čvoor u { @link IGraph grafu } .
@author Tim 2
"* Vraća sve atribute , kao { @link java . util . Map mapu } parova * { @link java . lang . String string } -> { @link java . lang . Object object } * * @return Mapa atributa"
* Dodaje novu { @link IEdge granu } na čvor . Grana mora da ima <em> to </em> * ili <em> from </em> na ovaj nod ili će biti bačen * ExGNodeNotConnectedException izuzetak . * * @param edge * Grana koja se kači na čvor .
"* Diretno povezuje dva { @link INode čvora } . Ovaj čvor će biti izvorni , a * <em> node </em> će biti odredišni . * * @param node * Čvor na koji ovaj čvor treba da se zakači . * * @throws ExGNodeDoesNotExsistException * Ukoliko zadati čvor nije deo grafa . * * @return Novo-kreiranu vezu ."
* Vraća listu svih grana koje su na ovaj čvor zakačene * * @return Lista grana
"* Ispituje da li je prosleđeni graf roditelj čvora , beskonačne dubine * * @param graph * za koji sumnjamo da je roditelj ovog čvora * @return true ako jeste roditelj"
"* <p> * Konstante koje određuju poziciju akcije u sklopu aplikacije . Jedna akcija * može da se pojavi na više mesta . * <p> * Konstante su tako napravljene da sve informacije mogu da se prenesu * jednim integer-om . Na primer , ako akcija želi da bude u meniju i * toolbar-u , treba da vrati integer MENU | TOOLBAR ."
* Oznaka da akcija treba da se ugradi u toolbar . Ugradiće se u * podrazumevani toolbar . Ako komponenta
* Oznaka glavnog toolbar-a koji podrazumevano postoji
* Izvršava komandu . * * @param command * Komanda za izvršavanje * @param params * Lista parametara komande * * @throws ExGCommandErrorException * Ukoliko postoji graška u prosleđenim parametrima * @return Rezultat izvršavanja komande . Ovo mora biti * { @link tk . exgerm . core . model . IGraph IGraph } * { @link ExGCommand #returnsGraph ( ) } vraća true .
* Označava konstantu pod kojom se čuva trenutna putanja u file sistemu .
* Označava događaj da je promenjen aktuelni FS dir u aktivnoj konzoli * * Parametri : * <ol> * <li> ps : PrintStream - odgovarajući stream putem kojeg prepoznajemo * odgovarajuću konzolu </li> * <li> path : String - string trenutno aktivnog patha </li> * </ol>
* Označava događaj da je promenjen aktivni graf u konzoli . * * Parametri : * <ol> * <li> ps : PrintStream - odgovarajući stream putem kojeg prepoznajemo * odgovarajuću konzolu </li> * <li> node : IGraph - referenca na graf koji se postavlja za aktivan ( null * za poništavanje aktivnog ) </li> * </ol>
* Označava ključ pod kojim se čuva aktivan čvor konzole u Core-u . * * Tip podataka : INode
* Vraća ključnu reč na koju se komanda odaziva . * * @return Ključna reč na koju se komanda odaziva
* Označava događaj da je tab zatvoren . * * Parametr : * <ol> * <li> component : JComponent - komponenta koja se prikazuje u tab-u </li> * </ol>
* Treba da vrati jednu od konstanti : * <ul> * <li> { @link ExGGraphicalComponent #CENTER } </li> * <li> { @link ExGGraphicalComponent #SOUTH } </li> * <li> { @link ExGGraphicalComponent #EAST } </li> * <li> { @link ExGGraphicalComponent #WEST } </li> * </ul> * i predstavlja poziciju unutar { @link tk . exgerm . core . gui . MainWindow * glavnog prozora } gde će se komponenta prikazati . * * @return Poziciju komponente
* Konstante koje treba da koriste grafičke komponente za određivanje * pozicije unutar { @link tk . exgerm . core . gui . MainWindow glavnog prozora }
* Označava događaj da je graf uklonjen iz registra . * * Parametri : * <ol> * <li> graph : IGraph - graf koji je uklonjen </li> * </ol>
* Uklanja graf iz registra na osnovu imena <em> name </em> . * * @param name * Ime { @link tk . exgerm . core . model . IGraph grafa } koji se uklanja . * @throws ExGGraphDoesNotExsistException * Ukoliko graf sa traženim imenom ne postoji .
* Metoda koju implementiraju samo neki iteratori kako bi omogućili čišćenje * podataka koje su stavili u graf . * Svaki iterator u opisu klase definiše da li je posle njega potrebno pozivati ovu metodu .
"* Uniforman interface za sve načine prolaska kroz * { @link tk . exgerm . core . model . IGraph graf } . Konkretna implementacija treba da * vodi računa o početku i kraju { @link tk . exgerm . core . model . IGraph grafa } . * Ukoliko je { @link tk . exgerm . core . model . IGraph graf } cikličan , treba da * odredi koji { @link tk . exgerm . core . model . INode Čvor } se prvi obrađuje i da * pazi da se iteracija zaustavi kad se dođe ponovo do istog * { @link tk . exgerm . core . model . INode čvora }"
@author Tim 2
* Vraća sledeći { @link tk . exgerm . core . model . INode čvor } u iteraciji . * * @return Sledeći { @link tk . exgerm . core . model . INode čvor }
Ovu * metodu ne treba pozivati nakon što { @link ExGIterator #hasNext ( ) } vrati * <em> false </em> * *
* Oznaka View menija
"* Metoda koja treba da vrati string sa imenom menija u koji akcija treba da * se ugradi . Ako takav meni ne postoji biće kreiran . Metoda će biti pozvana * samo ako { @link ExGAction #getActionPosition ( ) } označi akciju kao da treba * da bude dodata u meni , u suprotnom neće nikad biti pozvana . Ako se akcija * dodaje u neki od standardnih menija treba iskoristiti neku od konstanti * definisanih u ovom interface-u . * * @return Ime menija u koji treba da se ugradi akcija ."
"* <p> * Vraća poziciju na kojoj će se akcija ubaciti u meni . Ovo treba da bude * velik ceo broj , sa dosta razmaka između rednih brojeva akcija , da bi se * ostavio prostor drugim komponentama da se uglave između ove akcije i * prehodne ili sledeće . * <p> * Akcije sa istim rednim brojem će biti grupisane između dva separatora . * <p> * Metoda neće biti pozvana ako se ova akcija ne ugrađuje u meni . * * @return Redni broj pozicije u meniju ."
"* Ovaj iterface obuhvata zajedničke stavke koje mogu da se pojave u bilo kojoj * stavci u meniju . U ovom slučaju nasleđuju ga samo { @link ExGAction } i * { @link ExGSubmenu } . Ni jedna komponenta ne bi trebalo direktno da * implementira ovaj interface , neko nekog o njegovih naslednika . * * @author Tim 2"
* Vraća meni koji treba da se ugradi . * * @return Meni koji treba da se ugradi .
* Obaveštava osluškivača da se desio događaj i prosleđuje mu parametre koje * se događaj poslao . * * @param event * Događaj koji se desio * @param parameters * Parametri koje je događaj poslao .
* <p> * Način obrade { @link tk . exgerm . core . model . INode čvorova } ( VisitorPatern ) . * * Klijenti koji žele da obave neke radnje nad čvorom treba da implementiraju * ovaj interface i da pozovu * { @link tk . exgerm . core . model . INode #accept ( IVisitor ) accept metodu čvora } ili * { @link tk . exgerm . core . model . IEdge #accept ( IVisitor ) accept metodu grane } * <p> * Primer koda koji radi istu stvar nad svakim elementom kroz koji prolazi * { @link tk . exgerm . core . plugin . Iterator iterator } : <code> * <pre> * Iterator it ; * IVisitor v ; * while ( it . hasNext ()) { * it . next ( ) . accept ( v ) ; * } * </pre> * </code> * * @author Tim 2 *
* Vraća komandu * * @param command * Naziv komande * @return komanda
"ako postoji graf sa istim imenom u registru , pretpostavka je da je nas aktuelniji"
"* Jedan proxy može da ima više servisa ( na primer , jedan lokalni , jedan što * drži grafove na mreži . ) . Mi ćemo imati jedan ili ni jedan , ali ovo * ostavlja mogućnost da ih ima više ."
obavestavamo sve koji su zainteresovani
* Dodaje novi help u registar * @param component koja registruje help * @param help komponente
* Vraća help * * @param component * Naziv komponente * @return help komponente
* Vraća sve helpove koje su registrovane u sistemu . * * @return Svi registrovani helpovi
* Kontekst u kome se izvršava komponenta u okviru OSGI framework-a .
* Proxy za registre grafova .
* Registar svih komandi
* Izbacuje servis iz registra * * @param name * ime servisa
* Ovu metodu treba da koriste komponente koje hoće da dodaju nešto u glavni * prozor . * * @param position * <ul> * <li> ExGGraphicalComponent #CENTER </li> * <li> * ExGGraphicalComponent #SOUTH </li> * <li> * ExGGraphicalComponent #EAST </li> * <li> ExGGraphicalComponent #WEST </li> * </ul> * @param component * Komponenta koja se dodaje
* Koriste se za dodavanje akcija u menije i toolbar glavnog prozora . * * @param action * Akcija koja se dodaje
* Koristi se za uklanjanje akcije iz glavnog prozora . Akcija će biti * uklonjena sa svih mesta na koje je bila dodata metodom * { @link ICoreContext #addAction ( ExGAction ) } . * * @param action * Akcija koja se uklanja . Mora biti ista instanca kao ona koja * je prosleđena metodom * { @link ICoreContext #addAction ( ExGAction ) }
* Dodaje { @link tk . exgerm . core . model . IGraph graf } u registar * * @param graph * { @link tk . exgerm . core . model . IGraph Graf } koji se dodaje . * * @throws ExGGraphExsistException * Ukoliko graf sa istim imenom već postoji u registru * @throws ExGNotImplementedException * Ukoliko ne postoji registrovan graph register
* Vraća sve registrovane komande . * * @return Sve registrovane komande .
* <p> * Na ovaj način komponenta može da postavi neku vrednost pod određenim * ključem da bi je kasnije pokupila ili da bi je neka druga komponenta * pokupila . Pored mehanizma event-ova ovo je način na koji komponente mogu * da razmenjuju podatke . * @param key * Pod kojim ključem se čuva vrednost * @param value * Sama vrednost
"Ne treba mešati ovo i eventove jer ovde treba da * se ostavljaju podaci koji se mogu preuzeti bilo kad , a ne kad se desi * neki događaj . * <p> * Na primer , visualizer može da postavi active graph kad se on promeni , a * svi algoritmi mogu da ga preuzmu da bi znali nad čime da se izvrše . <br/> * Konzola može da postavi aktivan graf , a sve komande da ga preuzmu ."
"* Registruje novi iterator . * * @param iteratorClass * Klasa iteratora koji se registruje . Ovo se šalje , je novi * iterator mora da se instancira svaki put kad se zatraži . * @throws ExGIteratorAlreadyExsistException * Ukolik iterator sa istim imenom već postoji"
"* Određuje da li se { @link MainWindow glavni prozor } prikazuje . * * @return <code> true </code> ako je prikazan , <code> false </code> ako nije"
* Vraća stanje u kome se { @link MainWindow glavni prozor } nalazi * * @return stanje u kome se prozor nalazi * * @see Frame * @see java . awt . Frame . getExtendedState ( )
* Pokreće sve komande koje se dodate u pipeline metodom * { @link IPipeLine #addCommand ( ExGCommand command ) }
iterator pocinje od start noda
ispis ako nema
"* Generiše graf u obliku mreže kvadrata * * @param h - parametar , generiše se n ^ 2 čvorova * @param graphName - ime generisanog grafa"
* Metoda inicijalizuje imena svih tipova grafova koje će ova komponenta da * ponudi korisniku za generisanje
* Metoda inicijalzuje radio grupu na ovom prozoru . Za svaki uneti tip grafa * i njegovo objašnjenje generiše po jedno radio dugme i jednu labelu sa tekstom * objašnjenja .
* Ova konstanta predstavlja ime komponente i služi za lakše identifikovanje * komponente koja ispaljuje HELP_REQUESTED event .
samo ostavimo res na null
* Lista svih registrovanih komandi za čišćenje .
* Označava događaj da je kliknuto na graf na graphTree komponenti . * * Parametri : * <ol> * <li> graph : IGraph - graf na koji je kliknuto </li> * </ol>
* Označava događaj da se desio desni klik nad nodom na graphTree * komponenti . * * Parametri : * <ol> * <li> node : INode - nod nad kojim se desio desni klik </li> * </ol>
* Označava događaj da je na graphTree komponenti kliknuto na akciju za * dodavanje novog noda . * * Parametri : * <ol> * <li> graph : IGraph - graf u koji treba dodati novi nod . </li> * </ol>
* Metoda setuje svim potrebnim akcijama na popup meniju koji graph je * trenutno selektovan i za koji graph bi trebala da se izvrsi pokrenuta * akcija . * * @param graph - graph koji je trenutno selektovan na GraphTree komponenti
* Metoda inicijalizuje sve akcije ove komponente
uzimamo root graf i u zavisnosti od broja nivoa podgrafova nalazim graf u koji treba ubaciti prosledjeni IEdge
* Roditelj ovog Edgea odnosno EdgeSeparator u kom se Edge nalazi .
* Ikonica kojom je Graph predstavljen u GraphTree komponenti .
* Roditelj ovog Nodea odnosno NodeSeparator u kom se Node nalazi .
* Ime korenskog čvora odnosno ono šta će biti ispisano kao ime ovog * elementa u GraphTree-ju .
* Ikonica kojom je Workspace predstavljen u GraphTree komponenti .
Grafička komponenta helpa * SCrollPane koji sadrži u sebi JEditorPane koji parsira HTML stranice
* Kreira stringovsku reprezentaciju grafa . * @param graph Graf koji se serijalizuje
* Vraća reprezentaciju grafa . * @return Reprezentacija grafa u string-u .
* Čuva prosleđeni graf u zadati file pomoću zadatog buildera . * * @param graph * Graf koji se čuva * @param builder * Builder koji se koristi za pravljenje stringovske * reprezentacija grafa * @param f * File u koji se snima
"ako je prosleđen file , njega korisnimo"
ovo radimo samo ako nismo dosli do kraja sa vracanjem ugnjezdenih grafova
* Izbacuje sve sto nije validno slovo
uklanjanje escape znaka izpred navodnika u sred stringa
Next token .
Reinitialise .
RegularExpression Id.
Lexical state .
Token Manager .
* Apstrakcija parsera . Svaki parser treba da implementira ovaj interface radi * uniformnog pristupa iz { @link PersistanceService } .
* Parsira prosleđeni file . File treba da bude prosleđen drugim načinom ( u * zavisnosti od konkretnog parsera - ovako se ostavlja podrška za * parsiranje iz raznih izvora ) . * * @return { @link IGraph Graph } dobijen parsiranjem . * @throws InternalParseException * Ukoliko dođe do greške u toku parsiranja u zadatom fajlu .
"* Proverava da li je graf učitan iz fajla . * * @param graphName * Ima grafa za koji se vrši provera . * @return <em> true <em> ako je graf učitan iz fajla , <em> false <em> inače"
"* Vraća fajl iz koga je graf učitan . * * @param graphName * Graf za koga se traži file iz koga je učitan . * @return Putanju do fajla iz koga je graf učitan , ili <em> null </em> ako * graf nije učitan iz fajla ."
"na početku svi grafovi imaju dirty flag true , jer ni jedan nije učitan iz fajla ( Persistance se tek digao pa nije ni bilo moguće učitavanje iz fajla ."
"* Svi listeneri , za čišćenje"
* Otvara glavni prozor za rad sa pluginovima . *
* Komanda za instalaciju novog plugina . Prepoznaje putanju i prosleđuje je * glavnoj PluginManager klasi na dalju obradu . *
* Komanda pokreće instaliran plugin . *
* Tipovi ishoda update-a .
* JDialog kreiran sa http://w.instantiations.com/windowbuilder/
* Vrši prilagođavanje širina kolona spram podataka u njima . * * @param table * sa kojom radi * @param vColIndex * index kolone * @param margin * margina
Add margin
* Osvežava { @link UpdateStatus } određene komponente * * @param tableRow * red komponente čiji status osvežavamo * @param status * trenutno stanje { @link UpdateStatus }
* Uklanja vizelnu predstavu čvora iz visualisera . * * @param nodeName
* Prilagođena za korišćenje erasera . Proverava da li pogođena vizelna veza * i briše stvarn vezu iz grafa . * * @param point * - koordinata ( trenutna pozicija miša )
"* Proverava šta se nalazi ispod tačke point . Ako je tu čvor , vraća njegov * index u listi , ako nije , vraća -1. * * @param point * - koordinata ( trenutna pozicija miša ) * @return - index u listi ili -1"
TODO naci bolje resenje za ovo .
* Optimalna duzina opruge ( veze medju nodovima )
Drag na srednje dugme
skrol po X osi
* Vraća konstantu prethodnog stanja sistema * * @return konstantu prethodnog stanja sistema
* Dodaje osluskivace Viewer komponenti *
"NOTE : MouseWheelListener definisan u apstraktnoj klasi State , pa ga nije * potrenbno dodavati prilikom promene stanja . Dodaje se , mozda se kasnije * javi potreba"
"* Predstavlja rukovaoc stanjima u kojima se { @link Visualiser Visualiser * komponenta } može naći . Realizuje postavljanje aplikacije u naredno stanje , * dodaje osluškivače { @link VisualiserView Viewer } komponenti . <br> * <br> * Da bi se dodalo novo stanje potrebno je definisati novu konstantu u * { @link States } atributu klase { @link StateManager } i u konstruktoru pozvati * metodu { @link #addState ( States , State ) } . Ona kao parametre prima konstantu * koja reprezentuje stanje i konkretnu instancu klase koja nasleđuje apstraktnu * klasu { @link State } ."
* @see State * @see VisualiserView *
* Stanje u kome se sistem trenutno nalazi
NOTE : dodati instance stanja po potrebi
transform . getScaleX ( ) ;
* Skalira dijagram tako da se svi elementi budu vidljivi
* Singleton koji upravlja učitavanjem i upisom konfiguracionig parametara * visualiser komponente .
* Da li je dozvoljeno iscrtavanje navigatora
* Širina zoom kontrole
* Visina zoom kontrole
* Predstavlja indikator dirty-flag-a grafa .
* Vraca trenutno stanje prikaza * * @return stanje prikaza
* Setuje poziciju na kojoj će Navigator biti iscrtan * * @param position
* Vraća pociciju na kojoj se move kontrola iscrtava * * @return pociciju na kojoj se move kontrola iscrtava
* Konstante koje reprezentuju stanja u kojima se navigator može naći
* Vraća veličinu imaginarnog okvira oko navigatora * * @return veličinu imaginarnog okvira oko navigatora
* Vraća rastojanje od gornje ivice i navigatora * * @return rastojanje od gornje ivice i navigatora
* Setuje veličinu imaginarnog okvira oko navigatora * * @param gap * veličina imaginarnog okvira oko navigatora
* Setuje rastojanje između move i zoom kontrole * * @param gap * rastojanje između move i zoom kontrole
* Vraća faktor brzine skrivanja i prikazivanja navigatora * * @return faktor brzine skrivanja i prikazivanja navigatora
* Vraća visinu navigatora * * @return visinu navigatora
* Vraća viewer kontrolu na kojoj se Navigator iscrtava * * @return
* Iscrtava okvir u kome se nalazi Navigator *
* Vraća vrednost tačke u ortogonalnom koordinatnom sistemu * * @param position * tačka čika se ortogonalna projekcija traži * * @return projekciju tačke u ortogonalnom koordinatnom sistemu
* Vraća početnu poziciju zoomBar kontrole * * @return početnu poziciju zoomBar kontrole
* Reaguje na pomeraj miša iznad Navigaotra * * @param e događaj miša
* Kreira ikonu na osnovu naziva fajla zadatog relativno u odnosu na ovu klasu * @param fileName Naziv fajla slike sa relativnom putanjom * @return
"* Metoda za inicijalizaciju akcija , polja klase ."
trazimo maximalnu y vrednost tj y + height
* Akcija za redjanje elemenata po desnoj ivici. *
trazimo maximalnu y vrednost tj x + width
* Akcija za redjanje elemenata po gornjoj ivici. *
* Akcija za prikaz prozora sa osobinama { @link Argument Argumenta }
"* Metoda postavi dijagram node-a na kome se vrsi akcija da bude prikazan , * selektuje taj nod na radnoj povrsini i centrira radnu povrsinu na njega ."
* Klasa akcije za promenu tekuceg radnog okruzenja : { @link Workspace Workspace }
* Akcija za dodavanje nove { @link Decision Odluke }
"putValue ( SMALL_ICON , loadIcon ( """" images / decision . png """" )) ;"
* Klasa predstavlja akciju brsanja elementa .
* Klasa predstavlja akciju brisanja dijagrama iz projekta .
* Slektovani projekat
"Prvo brisemo sve dijagrame : sa Taba , iz Projekta , iz FS"
* Akcija za distribuciju elemenata po vertikali *
* Klasa predstavlja akciju za unos nove veze zavisnosti
* Akcija za dodavanje nove { @link Position Pozicije }
* Klasa predstavlja akciju ponavljanja prethodno zabeleze akcije u aplikaciji .
"ne treba ovako , ali ovako cemo za sada uraditi"
* Klasa predstavlja akciju prikazivanja svojstava selektovanog noda .
* Klasa predstavlja akciju zumiranja prikaza dijagrama .
* Klasa predstavlja akciju zumiranja tako da se svi postojeci nodovi na dijagramu vide . * Tzv Zumiranje na najbolji prikaz .
"treba nam workspace , podesava se u konfiguraciji"
iteriramo kroz sve fajlove
* Prolazi kroz sve dijagrame u svim projektima i trazi one koji su menjani * a nisu sacuvani . * * @return Sve nesacuvane dijagrame
"samo na requirement zanima , jer samo on moze da pozove ovo znam , znam , ruzno"
"UIManager . setLookAndFeel ( """" com . sun . java . swing . plaf . nimbus . NimbusLookAndFeel """" ) ;"
* Dodaje nod u model .
* Klasa za smestanje svih urađenih komadi .
* Model na koji se ovaj command manager odnosi
* Uklanja sve selektovane nodove iz modela * i stavlja ih na Clipboard .
* Početna pozicije prelomnih tačaka .
* Krajnje pozicije prelomih tačaka .
* Javlaja ovoj komandi da je pomeranje završeno da bi pokupila krajnje * pozicije .
* Sve počitne pozicije svih prelomnih tačaka svih pomerenih linkova .
* Stari i novi scale faktori .
* Razlikovanje prvog pokretanja od redo-a .
* Vraća veličinu noda na onu pre menjanja veličine .
* Postavlja stara svojstva na nodove .
* Singleton klasa za koja omogucuje eksterna podesavanja . Cita podesavanja iz * XML datoteke i ucitava ih u HashMapu .
* Podrazumevana konfiguracija
* Extenzija dijagrama .
* Vreme ( u milisekundama ) izmedju menjanja stanja progress bara pri * pokretanju programa ( samo zbog efekta )
* Vrednosti koje odredjuju gustinu grida u zavisnosti od zoom faktora .
* Klasa reprezentuje prozor sa informacijama o programu i njegovim autorima i * pomagacima na projektu
* Klasa predstavlja prozor za izbor boje nekog elementa
* Funkcija vrsi inicijalizaciju sadrzaja comboBoxa sa imenima svih postojecih projekata u trenutnom workspace-u
* Funkcija onemogucava menjanje sadrzaja comboBoxa sa projektima .
* Lista svih prethodnih upita za Replace nekog naziva noda . * Cuva se sve dok program radi .
* Lista svih prethodnih upita za Find nekog naziva noda . * Cuva se sve dok program radi .
* Klasa omogucava auto-complete opciju za combo boxove za Find i Replace imena nodova .
"@author WiktorNS - ma jok :D , kod je """" pozajmljen """" sa neta . *"
"* Funkcija prvo vrsi analizu stanja podataka vezanih za pretragu , i zatim u odnosu na zahteve pretrage * za pocinje iteraciju kroz sve nodove i svakom nodu koji odgovara pretrazi zamenjuje deo teksta u * Find comboBoxu sa delom teksta u Replace comboBoxu . Kada se iteracija zavrsi ispisuje se adekvatan poruka * sa informacijom o broju nodova kojima me uspesno izvrsena zamena ."
* Meni sa alatkama za dodavanje elemenata i veza .
* Panel u okviru koga su smesteni klizaci .
* Listener klasa koja reaguje na dogadjaje koje izazivaju scroll barovi
* Listener klasa koja reaguje na dogadjaje misa na klizacima za uvecanje .
* Vrsi inicijalizaciju { @link MainWindow #tabs tabs promenljive } Ukljucuje i * Listener klase za tabove .
* Klasa glavnog prozora aplikacije .
* Vrsi inicijalizaciju promenljivih : * <ul> * <li> { @link MainWindow #toolbarMain } * <li> { @link MainWindow #toolbarElements } * <li> { @link MainWindow #zoomSlide } * </ul>
undo-redo
cut-copy-paste-delete
* Čuva stanje prve labele status bara u statusBarBackup
* Vraća prethodno sačuvano stanje prve labele statusBara
* Help menu koji se nalazi u { @link MainWindow #menu } polju .
* Predlozene vrednosti pri izboru debljine noda .
* Trenutna primarna boja za gradijent noda .
* Trenutna sekundarna boja za gradijent noda .
* Trenutna debljina okvira noda .
* Lista chechBoxova - za svaki postojeci Zahtev na dijagramu po jedan
prva kolona
* Klasa predstavlja prozor za prikaz trenutnih svojstava Requirement-a
* Funkcija vrsi inicijalizaciju action listenera za dugme koje treba da napravi novi dijagram i ubaci ga * u Diagrams comboBox kao opciju za selektovanje . Ova funkcija se izvsava svaki put kada se pozove funkcija * getProperties nekog zahteva .
* Funkcija inicijalizuje imena svakom od postojecih radio dugmica .
* Funkcija puni cbAuthors svim postojecim Stakeholderima na dijagramu .
* Klasa predstavlja prozor za obavestenje o nesacuvanih dijagramima neposredno pre gasenja aplikacije .
* Lista svih nesacuvanih dijagrama u trenutku gasenja aplikacije .
* Lista svih dijagrama chekiranih za snimanje .
* Trenutno podesena boja kanvasa aplikacije
* Klasa predstavlja prozor za podesavanja svih generalnih svojstava programa .
* Funkcija postavlja u konfiguracioni menadzer sva nova podesavanja za * nodove koja se pokupe iz prethodno zatvorenog prozora za podesavanje * defaultnih vrednosti za nodove . * * @param dn * - prozor za podesavanje defaultnih vrednosti za nodove .
* Funkcija na osnovu vrednosti svih polja u prozoru popunjava * konfiguracioni menadzer novim vrednostima podesavanja .
* Lista raspolozivih tema za aplikaciju .
"* Metoda služi za relociranje elemenata ili ekrana ( bilo koje tačke ) pri * čemu pomeranje vrši u koracima kako bi se stvorio efekat animacije . * Metoda prilikom pomeranja uvažava , tj. odrežuje veličinu pomeraja na * osnovu trenutne udaljenosti trenutne pozicije i odredišta kao i trenutnog * zooma kanvasa . * * @param currentPos * trenutna pozicija tačke koja se pomera * @param destination * odredišna pozicija tačke * @param diffPos * diferencijalna tačka novog položaja"
* Završava pomeranje nodova ( šalje ih direktno na odredišnu lokaciju . Vrši * proveru da li takvi nodovi postoje . Predviđeno za upotrebu u slučaju * prekida animiranja ( recimo kod vezanih UNDO operacija ) .
animacija za skaliranje kanvasa
* Klasa predstavlja prozor za prikaz trenutnih svojstava Topic-a
"* Funkcija definise reakciju programa na pritisak entera ili """" ok """" dugmeta na prozoru . * Pre zatvaranja prozora ce se ukoliko unesena putanja za workspace ne postoji napraviti novi folder sa adekvatnim nazivom * i uneti nova podesavanja u kofiguracioni menadzer . * Rezultat dijaloga postaje potvrdan i dijalog se sakriva ."
otvaranje popupMenu-a na desni klik
uzimanje popup menu
za akciju CenterNodeAction je potrebno postaviti diagram i node prikaz menija
zbog bug-a sa center node ako dijagram nije otvoren
setuje dijagram potrebnim akcijama
za pogodjen Projekat
System . out . println ( logger . getHandlers ()) ;
* Događaj opisuje promenu nad modelom . Ovu klasu je moguće proširiti tako * da nosi informacije o tome šta je tačno u modelu promenjeno u cilju optimizacije * iscrtavanje .
* @author igor *
dodavanje ghost noda
* Vrši korekciju položaja selektovanog breakpointa . Prethodno vrši proveru * da li postoji selektovan breakpoint
"* Vrsi korekciju breakpointa linkova koji su povezani za nod koji se * pomera . Korekcija pozicije se vrsi samo za linkove čija se oba noda * pomeraju . Ukoliko je u tekućem koraku već izvršena korekcija pozicije * breaktpointova nekog linka , on će biti preskočen . * * @param node * koji je pomeren * @param offsetX * pomeraj X * @param offsetY * pomeraj Y *"
* Pronalazi indeks elementa koji se nalazi na zadatim logickim koordinatama * * @param point * @return
* alteredLinks je lista svih linkova cija lokacija je azurirana u tekucem * koraku . Sluzi kao zastita da se ne bi neki linkovi vise puta pomerili u * tekucem koraku .
"* Podrška za JTree komponentu , kod koje je bitno da elementi ne menjaju * poziciju prilikom promene selekcije . * * @param i * Indeks elementa * @return Element na zadatoj poziciji"
* Javljamo svim listenerima da se događaj desio
nakon sto smo sacuvali dijagram vise nije menjan
* Apstraktna klasa koja opisuje bilo koji element dijagrama .
ovo mora da redefinise svaka klasa naslednica za sebe
* @author igor *
* Instanciranje GraphObjectPainter-a obavljaju konkretni elementi * prilikom svoje konstrukcije
* Koristi se kao pomocna metoda koju ce korisiti svaka naslednica ove klase * da bi napisala svoju metodu <code> setProperties </code> . Ovde se konkterno * realizuje smestanje u ovaj objekat atributa poznatih na ovom nivou . * * @param properties * HashMapa sa atributima ( mora je metoda naslednjica kreirati )
* Datum kreiranja elementa .
* Lista veza koje za pocetak ili kraj imaju ovaj element .
* Menja ime projekta i menja ime direktorijuma u koji je projekat sacuvan * * @param newName * novo Ime projekta
* Enumeracija mogucih vrednosti argumenta . *
* Stanje Odluke * * { @link germ . model . nodes . DecisionValue }
* Finalna odluka
* Ponasanje koje se zahteva .
* Izvor ideje o zahtevu
* Reference na ostale zahteve
* Kompanija u kojoj je stakholder zaposlen .
* E-Mail stakeholdera .
* Autor teme .
pogodjen node
* Menja kursor ako se nadje iznad handla nekoh selektovanog noda . Kad se * kursor pomeri sa handla kursor se vraca na prethodni .
* Dodaje Pretpostavku na poziciju kursora ako na toj poziciji već * ne postoji nod .
"* Metoda vraca true ako je pogodjeni node validan zavrsetak linka , false * inace . * * @param link * link koji se kreira * @param node * pogodjen node * @return"
* Dodaje Zahtev na poziciju kursora ako na toj poziciji već * ne postoji nod .
* Isključuje laso i zumira na veličinu nacrtanog lasa .
* Kreira komandu koja se koristi za undo-redo .
TODO Ubaciavanje ghost nodova
* Javlja state mašini da se desio događaj povlačenja miša i updateuje * { @link GERMView #hanleMoving } i { @link GERMView #lastPosition }
* Metoda vrsi zumiranje tako da pravougaonik koji je prosledjen sigurno * bude vidljiv * * @param rect * koji mora biti prikazan
cranje lasa
crtanje ghostNodova
crtanje link-ova
crtanje okvira oko selektovanih nodova
crtanje breakpointova selektovanog linka
* Metoda vraca round rectangle oko zadatog elementa * * @param n * node * @return rectangle sracunat takod a bude oko node-a
* Metoda racuna pravougaonik koji predstavlja trazeni handle nad zadatim * nodom . * * @param handle * za koji se trazi Rectangle * @param n * node oko koga se nalazi handle * @return Rectangle2D koji predstavlja trazeni handle oko zadatog node-a
pravougaonik u zavisnosti od kvadranta
Iscrtavanje samog pravougaonika lasa
boja i alpha
"* Za zadatu tačku i element vraća hendl . * * @param node * @param point * @return Hendl ukoliko je """" pogođen """" , u suprotnom vraća null"
* Funkcija centrira pronadjeni nod na trenutno otvorenom dijagramu * * @param node * - pronadjeni nod koji odgovara upitu pretrage
vertikalne linije
"* Metoda vraca true ukoliko je na zadatoj poziciji link . Uvazava * translaciju source i destination noda ( koji se naleze u uglu noda , a ne u * centru ) ."
vracanje deformacije da ne bi uticala na tekst
vracanje ispod node-a ako je node flip-ovan
* Privatno polje neophodno za hvatanje klika misha na element .
potrebno radi provere pogadjanja argumenta .
* Konkretan painter je zadužen za definisanje Shape objekta koji predstavlja * Requirement .
* Konkretan painter je zadužen za definisanje Shape objekta koji predstavlja * Stakeholder
uzimamo sve podatke iz forme
"prebacimo sve u ArrayList , jer nam je bitan redosled"
i ispisujemo meni
* Pokrece akciju na ID-a naredbe ( uglavnom dobijenog od <link> menu ( ) </link> * metode * * @param action * ID akcije
* @param args * Kao opcione parametre program prima adresu na kojoj se nalazi * server i port
* Port na koji se klijent loguje
* Glavni logger u klijentu . Svi ostali loggeri nasledjuju ovog .
* Socket za komunikaciju sa serverom
JMBG
* @return Naziv komande ( iz protokola )
* Implementacije metode iz interfejsa Comparable zbog sortiranja stavki u * meniju * * Stavka sa manjim menuOrder poljem dolazi prva
* Samo skracenica sa <code> System . out . print ( ) </code> * * @param text * Tekst za stampu na ekran
"* Metoda koja odradjuje komunikaciju sa serverom za svaku komandu . * * @param args * Prima promenljiv broj argumenata jer svaka specifična komanda * traži različit broj parametara . * @return Ukoliko je komanda tipa ADD vraca null , a ako je tipa LIST vraca * ArrayList sa svim trazenim podacima . * @throws ClientException * Desava se ukoliko server vrati definisanu protokolom ."
* Odradjuje komunikaciju sa korisnikom i preuzima potrebne podatke . Kad * preuzme podatke pozuva execute sa odgovarajucim parametrima .
* @author del-boy * *
Apstraktna klasa koju moraju da naslede sve klase koje zele da dodaju neku * funkcionalnost klijentu .
* Tekst koji se pojavi u meniju iz koga korisnik bira opciju
* Redni broj koji odredjuje redosled pojavljivanja stavki u meniju
* Sam naziv komande iz protokola
TODO : Da svaka komanda u execute salje ovaj string umesto rucno napisanog * stringa
"* postavlja id , out i menuText na null , menuOrder na 0 i poziva * <link> init ( ) </link>"
"brisemo ekran ( mnogo je lose , ali u nedostatku bolje tehnike u javi . )"
* Konstruktor sa svim parametrima sem rezultata * * @param uid * jedinstveni identifikator utakmice * @param startTime * vreme pocetka utakmice * @param host * ime domaceg tima * @param guest * ime gostujuceg tima * @param tip_1 * koeficijent da ce domaci tim pobediti * @param tip_2 * koeficijent da ce gostujuci tim pobediti * @param tip_0 * koeficijent da ce biti nereseno
* @param prize * the prize to set
* Da li su svi mecevi zavrseni ili nisu
* Lista prognoza
* @author del-boy *
Klasa koja reprezentuje tip . Za razliku od klase rs.in . delic . WP . Server . Tip * ova klasa samo zadrzi podatke i sluzi samo za prenos podataka .
"* Postavlja match na "" i tim na -1"
* @author del-boy
Klasa koja reprezentuje korisnika
* @author del-boy
"Klasa za formatiranje izlaza prilikom logovanja . LogRecord je kratak , u * jednom redu , ispisuje nivo logovanja , ime klase koja je poslala record , ime * metode i samu poruku ."
* @author del-boy *
Klasa koja vrsi komunikaciju sa klijentom prilikom dodavanja meca
* Apstraktna metoda koju sve komande mojaju da preklope .
* @author del-boy *
* Apstraktna klasa koja koju nasledjuju sve klase koje dodaju neku * funkcionalnost serveru .
* Logger za upis akcija u fajl .
* Postavlja ulazni i izlazni stream * * @param in * Ulazni stream * @param out * Izlazni stream
* Klasa koja vrsi komunikaciju sa klijentom prilikom listanja tiketa
* Radi komunikaciju sa klijentom prilikom listanja svih meceva
Radi komunikaciju sa klijentom prilikom dodavanja rezultata meca
Radi komunikaciju sa klijentom prilikom registrovanja novog korisnika
* Dodaje novi mec . * * @param m * Mec koji se dodaje * @throws MatchException * Javlja se ukoliko mec sa istim UIDom vec postoji .
* * @param UID * meca koji je potreban * @return Mec sa trazenim UIDom * @throws MatchException * Javlja se ukoliko mec sa trazenim UIDom ne postoji
* Vraca korisnika na osnovu korisnickog imena . * * @param username * Korisnicko ime trazenog korisnika * @return Korisnik koji je trazen * @throws UserException * Ukoliko trazeni korisnik ne postoji
* * @return Vraca sve meceve u sistemu .
Istu stvar radi metoda * getAllMatches ( ) . Ne znam zasto postoje obe ( GRESKA ! )
* Proberava da li postoji ticket sa JMBG-om koji se trazi * * @param JMBG * korisnika za koga se proverava * @return Vraca true ako postoji JMBG korisnika u tiketima ili false ako ne * postoji
"* Metoda kojom ServerThread obavestava Kladionicu da se korisnik odlogovao . * Ne mora nista da radi , ali u nasem slucaju ce da upise sve promene u * fajl ."
* Radi upisivanje svih podataka u fajl .
* cita sve fajlove i inicijalizuje vrednosti
Klasa u kojoj se cuvaju svi podaci o radu servera . Klasa je singleton jer * treba da postoji samo jedna instace ove klasa za vreme rada servera .
* tabela svih meceva sa kojima server radi
* Generise XML element sa svim tiketima * * @param dom * @return
* Popunjava skup korisnika na osnovu podataka iz xml fajla * * @param userList
* tabela svih korisnika
* Uzima XML element i ime taga i vraca vrednost taga
result ako postoji rezultat kreiramo nod
* port na kom server slusa
* broj iznema na serveru pre pisanja u fajl
* ime konfiguracijonog fajla u koji su zapisane sve komande koje server * moze da primi
ignorisemo prazne redove
* Klasa kladionica
Klasa koja reprezentuje uplaceni tiket .
* kolicina uplacenog novca
* Da li je korisnik ulogovan ?
ako ulaz nije setovan spolja
dont learn the self connections moze cak i posle svakog prolaza da se primenjuje hebbianovo pravilo a ne samo nakon kupovine napravi vise varijanti ako kupuje onda moze da se primenjje winner takes all hebbian learning
"System . out . println ( key + """" -> """" + value ) ;"
return neuron ;
bias neuroni ne racunaju ulaz iz mreze jer
broj celija ka gore
broj celija ka dole
broj celija u levu stranu
broj celija u desnu stranu
else if ( j < ( i + g*d-rl )) return false ;
brojac celija sloja skupova ( fazifikacije )
brojac ulaza ( grupa fuzzy
slučaj kad čvor ima samo jedno dijete
"f1 ( x , y ) = 10 * ( x ^ 2-y ) ^ 2 + ( 1-x ) ^ 2"
"f2 ( x , y ) = ( x-4 ) ^ 2 + 4 ( y-2 ) ^ 2"
vratimo na staro
"dekodiranje - proces pretvaranja binarnog broja u realan ( u potencijalno rješenje ) , u granicama dg , gg"
max f7 ( xi ) = ( sumaxi ^ 2 ) ^ 0.25 * .
broj clanova populacije
racuna najgoru ( u ovom slucaju najvecu ) vrijednost funkcije
racuna index jedinke koja ima najmanju vrijednost funkcije
racuna potreban broj bitova na temelju preciznosti i intervala pretrazivanja
"Supstitucija unatrag ( U * x = y ) za i = n do 1 b [ i ] / = A [ i , i ] ; za j = 1 do i-1 b [ j ] - = A [ j , i ] * b [ i ] ;"
traži najveći elem
SetUpNFA ( ) ; Reset ( ) ;
clTab . mTipFunkcija . mParam ostavim na 0
ulazak u funkciju
ucitaj IDN
ucitaj <deklaracija>
ucitaj <ZAREZ>
ucitaj <inicijalizator>
morat ce bit null
< deklariranje nizova >
taman dosta da javi gresku ovdje dolje .
nije polje
nije niz znakova
<lista_izraza_pridruzivanja>
ucitaj <izraz_pridruzivanja>
ucitaj D_ZAGRADA
definiraj funkciju
pozivi funkcija
nemoguca pretvorba sa ` niz ( const char ) ` u ` niz ( char ) `
ali ipak treba ucitati ( PLUS | MINUS | OP_TILDA | OP_NEG )
"kaze uputa da <unarni_operator> ne treba provjeravati ,"
ucitaj <specifikator_tipa>
ucitaj <multiplikativni_izraz>
ucitaj ( OP_EQ | OP_NEQ )
ucitaj <bin_xili_izraz>
ispis u slucaju pogreske
for petlja ??
break i continue ??
TOCKAZAREZ
ucitaj <prijevodna_jedinica>
kad smo nasli onda :
odredjuje djelokrug deklaracija
"oct , upitno dali se koristi"
idemo od 1 do length ( ) - 1 jer navodnici su osigurani leksikom
nesmije zavrsit prefiksiran
doslo je do pridruzivanja pa makni nule sa stoga
"mIspisivac . DodajGlobalnuVarijablu ( """" TEMP_ """" + Izrazi_Sem . mBrojacLabela ++ , """" DW % D 0 """" ) ;"
vec dodano u izravnom deklaratoru
maknuli smo dva pa je razlika sljedeca :
makni sve stavljene argumente sa stoga
samo prvi rekurzivni poziv moze na stog stavit
u globalnom djelokrugu
makni 2 sa stoga i stavi novi
ucitaj TOCKA_ZAREZ
mStog . remove ( mStog . size ( ) -1 ) ;
makni return vrijednost sa stoga
ne brisemo
pretrazuje globalni djelokrug
jeli spremljena vrijednost ili adresa
mora biti jedan od ovih
ako nije
length mora biti 3
* @param prezime * the prezime to set
* @return the brzina
* @param brzina the brzina to set
* @param dodavanje the dodavanje to set
"* * To String metoda , za kompletan tim ."
* Funkcija dodajIgraca koja prima proslijedjenog igraca . * * @param noviIgrac
ok dugme kada se menja profil
ovde
dodaj da radi sa listom objekata Tura
"k. getOsoba ( ) . getIme ( ) + """" """" + k. getOsoba ( ) . getPrezime ( )"
"1 dvi """" """" ptdv """""
Postavimo format
Komparatori
Postavimo redosled
* Ova klasa sluzi za predstavljanje jednog kalendara iz kojeg se uzimaju podaci * za raspored .
@author Ivan Pribela
* Ova klasa sluzi za cuvanje liste vise kalendara iz kojih se uzimaju podaci za * raspored .
@author Ivan Pribela
"Nista , poruka o gresci je vec zapisana"
Prihvata englesku dvoslovnu skracenicu
"{ } < { P } < { P , V } < { P , V , RV } < { P , RV } < { V } < { V , RV } < { RV }"
* Ova klasa predstavlja vreme kao sat i minut .
* Pomocna klasa koja sluzi za zapisivanje poruka o graskama i drugim stvarima .
zapis funkcije u vidu liste ciji su elementi operandi i operatori
kao unarni operand se eventualno moze pojaviti minus
stek koji koristimo u pretvaranju infiksa u postfiks
postfiksni oblik
"ako nije unarni operand , samo ide dalje pret = priv ;"
pret = priv ;
"Ako posle unarnog operanda sledi """" ( """" , za podfunkciju uzimam sve sto je u zagradi"
"dodaj opciju da ako lista ima jedan element , vrati tu vrednost i ne zove evalExp"
"ako je unarni , dodajem unarni"
if ( akt ! = null ) akt . zavrsi ( ) ;
dodaje ga kao binarni minus
"@OneToMany ( cascade = { CascadeType . ALL } , fetch = FetchType . LAZY , mappedBy = """" akcijskiDogadjaj """" ) @JsonIgnore public Set <KategorijaDogadjaj> kategorijaDogadjaji ;"
public KategorijaArtikla nadkategorija ;
postavi poslednje pravilo za racun
pokreni pravila
"isprazni rezoner , kraj rada sa pravilima"
stavkaRacuna . setRacun ( racunService . findById ( stavkaRacunaDTO . getRacunDTO ( ) . getId ( ) ;
* Ćirilica *
"* Kapitalizuje slogotvorno R u zadatoj reči , ako postoji * <p> * * * @param word Reč koju treba obraditi * * @return Reč sa kapitalizovanim slogotvornim R *"
"* Proverava da li reč sadrži samoglasnik / slogotvorno R * <p> ** @param word Reč koju treba obraditi * * @return True ako reč sadrži samoglasnik / slogotvorno R , false u suprotnom *"
RULES
STOPSET
"* <p> * Ova klasa implementira stemer za hrvatski """" Simple stemmer for Croatian v0 . 1 """" Nikole Ljubešića i Ivana Pandžića . Originalna implementacija u Python-u je dostupna na adresi : * <br> * < a href = """" http://nlp.ffzg.hr/resources/tools/stemmer-for-croatian/ """" > http://nlp.ffzg.hr/resources/tools/stemmer-for-croatian/ </a> * </p> * <p> * Stemer predstavlja poboljšanje ranijeg algoritma opisanog u radu : * <br> * Retrieving Information in Croatian : Building a Simple and Efficient Rule-Based Stemmer , Nikola Ljubešić , Damir Boras , Ozren Kubelka , Digital Information and Heritage , 313 – 320 ( 2007 ) . * </p> *"
* @author Vuk Batanović *
"transformations . put ( """" naca """" , """" nca """" ) ;"
Batanović : Ponavljanja
Lista završetaka reči . * <p> *
"* Ako se naiđe na neku od stop-reči , ona se preskače . U suprotnom , sufiks reči se najpre transformiše a zatim i uklanja . * <p> * < * @param word Reč koju treba obraditi * <br> * @return Stemovana reč * <br>"
"* Konvertuje jedan karakter iz standardnog oblika ( ćirilice ili latinice ) u dual1 kodiranje . Miloševićev stemer ne implementira pun dual1 sistem kodiranja - izostavlja konvertovanje ' lj ' i ' nj ' u ' ly ' i ' ny ' , pa je ova funkcija blago drugačija u odnosu na onu korišćenu kod stemera Kešelja i Šipke . * <p> * * @param intCharacter Unicode kod karaktera koji treba prevesti u dual1 sistem ** @param oldChar Karakter koji je u tekstu prethodio trenutno zadatom karakteru * * @return String koji sadrži dual1 reprezentaciju zadatog karaktera *"
"* Ako se radi o karakteru ' j ' / ' J ' , onda je možda u pitanju deo slova Dj / dj * *"
Batanović : ispravio sa ' aća ' na ' acya ' *
* Stemuje sadržaj ulaznog fajla i upisuje stemovani sadržaj u izlazni fajl * <p> * * @param fileInput Ime ulaznog fajla * * @param fileOutput Ime izlaznog fajla * > * @throws IOException Označava grešku pri radu sa fajlom *
* Stemuje reč koja je napisana u standardnom obliku ( ćirilicom ili latinicom ) * <p> * @param word Reč koju treba stemovati ** @return Stemovana reč *
* Stemuje liniju teksta koja je napisana u standardnom obliku ( ćirilicom ili latinicom ) * <p> ** @param line Linija teksta koju treba obraditi * <br> * @return Linija teksta sa stemovanim rečima *
* Stemuje sadržaj ulaznog fajla napisanog u dual1 kodiranju i upisuje ga u izlazni fajl * <p> * @param fileInput Ime ulaznog fajla * * @param fileOutput Ime izlaznog fajla *
* Konvertuje zadati string ( reč ili liniju teksta ) iz standardnog oblika ( ćirilice ili latinice ) u dual1 kodiranje * <p> * <i> Converts the given string ( a word or a line of text ) from the standard form ( in the Cyrillic or Latin script ) into the dual1 coding system </i> * @param wordOrLine String napisan u standardnom obliku * <br> <i> A string written in the standard form </i> * @return String napisan u dual1 kodiranju * <br> <i> A string written in the dual1 coding system </i>
* Konvertuje sadržaj zadatog ulaznog fajla iz standardnog oblika ( ćirilice ili latinice ) u dual1 kodiranje i upisuje ga u zadati izlazni fajl * <p> * @param fileInput Ulazni fajl čiji je sadržaj zapisan u standardnom obliku * * @param fileOutput Izlazni fajl čiji sadržaj treba da bude zapisan u dual1 kodiranju *
klasican logisticki model
TODO pandas za ucitavanje . csv kina se izostavlja jer su podaci pomereni 2 meseca unazad pa bi to uticalo na rezultat regresije
TODO slajsovanje nizova
logisticka
snimanje slike u fajl
neuspelo parsiranje floatova u naucnoj notaciji
crtanje rezultata
cuvanje rezultata u fajlu
ovde se uzimaju prethodni rezultati regresije i koristi se weighted mean za predikciju sutrasnjeg broja zarazenih
TODO : ovde ima gresku da ne prepoznaje folder odakle treba da ucitava
Pravi npz i npy fajlove
"TODO : Preimenuj kolone A , B , C u neka smislena imena , izdvoj dataframe koji ima kolone slike i opis"
u ovom delu koda smo preimoenovali koline iz slova u img i description
TODO : sacuvaj tezine
"path = """" txt """""
os . mkdir ( path )
!/ usr / bin / env python
coding : utf-8
"data2 . to_csv ( ' / content / drive / My Drive / Colab Notebooks / kv_projekat ' , index = False )"
"x = tf . layers . conv2d_transpose ( x , kernel_size = 5 , filters = 128 , strides = 2 , padding = ' same ' , activation = activation )"
"x = tf . image . resize_images ( x , size =[ 28 , 28 ] )"
izbaceno klipovanje jer ne utice pozitivno
"clip_d = [ p. assign ( tf . clip_by_value ( p , -0.01 , 0.01 )) for p in vars_d ]"
if g_ls * 1.5 < d_ls :
train_g = False
train_d = False
Funkcija koja predstavlja diskriminator . Kao ulaz uzima originalne i generisane slike i pokusava da ih klasifikuje . Vraca skalarnu vrednost koja predstavlja 1 ako je slika prava i 0 ukoliko je generisana . Sastoji se od konvolucionih slojeva sa leakz-relu aktivacionom funkcijom .
importovanje biblioteka i baze podataka
Obrada prirodnih jezika
mapira functional podkomentare u samo functional
parametar C je 1 / lambda se automatski podesava u nizu param_c koji mora da je iste duzine
kao i broj foldova u unutrasnjoj unakrsnoj validaciji
"f1 za i-ti fold , jer se na kraju svega racuna statistika"
TODO OVDE IDE MODEL
resetovanje početnih kvaterniona orijentacije
Klasa za obradu podataka sa xsens senzora . Nasleđena QThread klasa komunicira sa klasom koja vrši akviziciju podataka i obrađuje podatke . Obrađeni podaci se zatim upisuju u dokument i šalju na strimovanje u glavni GUI .
signal koji služi za slanje podataka GUI-u
nasleđena metoda run klase QtCORE . QThread
računanje orijentacija u svim ravnima na osnovu kvaterniona
računanje orijentisanog ubrzanja na osnovu orijentacije i lokalnog ubrzanja senzora
path_acceleration =[ oriented_acc [ 0 ]]
detekcija pikova
detekcija lokalnog maksimuma na levoj nozi
Udaljenost u odbircima od prethodnog markera
slanje podataka u GUI
upisivanje podataka u fajl
čekanje 100 mikrosekundi
Metoda u okviru koje se vrši akvizicija podataka poslatih iz klase Reader_thread . Svaki tip podatka se čuva u odvojenom baferu klase .
Metoda koja resetuje proces segmentacije
QtCore signal koji služi za komunikaciju sa drugom klasom
"Metoda koju generiše QtDesigner , služi za generisanje GUI prozora . Na kraju metode se poziva metoda add_functionality koja uvezuje Widget-e GUI-a sa funkcijama ."
pri zatvaranju prozora pozovi destruktor klase
pokreće proces povezivanja xsens senzora
dugme koje resetuje orijentaciju senzora u prostoru
prostor u okviru kog će se naći grafici
uključivanje / isključivanje snimanja u fajl
podešavanje boje pozadine regije za grafike u belu
"Dodavanje struktura za iscrtavanje , format matrice 3 * 2"
grafik leve butine
grafik desne potkolenice
grafik levog stopala
grafik desnog stopala
todo - korekcija boja i izbacivanje tri
"popunjavanje struktura za prikaz frekvencije odabiranja , okvira i progress bar-ova"
dodavnja struktura za iscrtavanje linja na grafiku senzora koji odgovara levoj potkolenici
dodavnja struktura za iscrtavanje linja na grafiku senzora koji odgovara levom stopalu
strukture za iscrtavanje markera
Nasleđena metoda run klase QtCore . QThread . Ponavlja se do prekida programa i konstantno prikuplja podatke sa senzora . Ukoliko se prikupi previše podataka sa jednog senzora odnosno premalo sa drugih podaci se odbacuju . Veličina bafera do koje je dopušteno prikupljati podatke je deset paketa po senzoru .
dodavanje promenljvih za potrebe GUI-a
izbaciti nepotrebne promenljive
ponavlja dok ima barem 6 podataka u internom baferu sistema
paket koji sadrži sve podatke vezane za jedan obirak sa jednog senzora
U okviru ove metode se pozivaju strukture iz biblioteke koje je razvijena u okviru MT Software Suite-a
Ukoliko povezivanje sa senzorima ne funkcioniše ili prijavljuje grešku proveravati funkcije iz ove metode
Kreira se konstruktor
Ispisivanje trenutne verzije XDA strukture
"Ukoliko je dužina navedenog niza nula , ne postoji konektovan uređaj koji može da komunicira sa senzorima"
čuvanje početnih vrednosti kvaterniona orijentacije
"Ukoliko je nemoguće otvoriti port , ispisati grešku i obustaviti proces povezivanja"
Podešavanje uređaja za komunikaciju
podešavanje periode odabiranja sistema
određivanje radio kanala za komunikaciju odnosno frekvencijskog opsega na kome se komunikacija dešava
indikator završetka procesa konekcije
funkcija koja omogućava da se update-uje prikaz konektovanih senzora
odredi potomke uređaja za komunikaciju tj same senzore
pokreni proces akvizicije podataka
proveriti mogućnost čuvanja podataka na senzorima
print ( self . device . startRecording ())
pravljenje i povezivanje klasa za komunikacij sa senzorima i obradu podataka
self . alternative_reader . setPriority ( 6 )
uvećavamo brojač
self . thread_read . setPriority ( 5 )
Metoda koja prima podatke od strukture za obradu podataka sa senzora u realnom vremenu . U okviru ove metode se u lokalnoj memoriji GUI-a učitavaju podaci iz strukture za obradu koji se kasnije šalju na grafike .
podaci o orijentisanom ubrzanju
zasebna struktura koja obuhvata sve podatke koji će se iscrtavati
todo izbaciti koncept bilo kakve obrade iz GUI-dela
todo prebaciti računanje dužine koraka u strukturu za procesiranje
računanje dužine koraka
ukoliko je aktivan marker na levoj nozi desna noga će mirovati i računa se dužina koraka desne noge
index senzora koji se nalazi na desnom stopalu
računanje brzine prostom numeročkom integracijom
uklanjanje drifta iz brzine
računanje dužine koraka desne noge
"deo za upisivanje u fajl koji treba proveriti i izbaciti , prebačen je u strukturu za procesiranje"
menja stanje aktivnosti segmentacije
self . xsens_markers_left [ 0 ] = 2
pomoćna funkcija koja menja vrednost indikatoru za završetak procesa povezivanja senzora
"Resetovanje orijentacije senzora . Neophodno je senzore postaviti na ravnu površinu , orijentisane sve u istom smeru . Duža ivica senzora treba da se pruža duž pravca koji predstavlja x osu tj. osu kretanja . Smer x ose se prostire od priključka za punjenje senzora ka vrhu senzora . Z osa je orijentisana vertikalno od poda naviše . Y osa je orijentisana tako da koordinatni sistem bude desno orijentisan ."
funkcija koja menja stanje upisivanja u fajl
proveriti da li si counter koiristi i potencijalno ga izbaciti
self . reccording = False
pomoćna funkcija koja ispisuje dati string u prostor za text u okviru GUI-a
ukoliko nije moguće ispiši grešku
"Funkcija koja se koristi za vizualni prikaz podataka sa senzora postavljenog na levu butinu . Prikaz podrazumeva iscrtavanje orijentisanog ubrzanja i uglova u odnosu na ose sagitalnoj , frontalnoj i transferzalna ravan ."
provera da li se senzor namenjen levoj butini nalazi u spisku povezanih senzora
popunjavanje spiska indikatora koji se čitaju sa checkbox-ova i određuju šta se iscrtava
određivanje vremenskog intervala radi estimacije frekvencije odabiranja
"računanje procenta fekvencije odabiranja u odnosu na 100 Hz , dakle 1 odgovara feekvenciji od 100 Hz dok 0 odgovara potpunom prekidu prenosa podataka"
smatrajući da frekvencija odabiranja uglavnom ne pada ispod 90 Hz računamo koeficijent za prikaz koji će ići od 0 do 1 spram 90 - 100 Hz
podešavanje boje i veličine indikatora frekvencije odabiranja spram prethodno izračunatih parametara
Spram indikatora iscrtati odgovarajuće linije
analogni opis metodi update1 sa time što ova funkcija radi prikaz podataka vezanih za desnu butinu
de je izvod signala greske
svi signali imaju automatski dodeljene funkcije raspodele sa gausovom normalnom raspodelom
pravila za dobijanje izlaznog signala za kontrolisanje
normalizacija reference
model sistema
"difference = np . subtract ( reference , output )"
"crtanje reference , kontrolisanog signala i kontrolnog signala"
f-ja elipse
brisanje iz stare populacije
"reprodukcija ukrstanjem , roditelji se biraju tockom ruleta"
mutacija
crtanje grafika
"f-ja koja se maksimizuje ali koristi sharing , tako da se pretrazuje veci prostor"
"( ugao1 , ugao2 , ugao3 , fitness / sharing )"
pm = 0.001
racunanje ponovne fitness funkcije ukljucujuci i sharing
"( ugao1 , ugao2 , ugao3 , obican fitness , fitness sa sharing )"
ispis najbolje jedinke
zadatak gde se nalazi trougao sa najvecom povrsinom u elipsi
"print ( ' najbolji trougao je theta1 = { } , theta2 = { } , theta3 = { } , area = { } ' . format ( * population [ 0 ] ))"
ispis cele populacije
PAZNJA : podaci verovatno nece biti stratifikovani
"model . add ( k. layers . Dense ( units = 300 , activation = ' relu ' ))"
"model . add ( k. layers . Dense ( units = 200 , activation = ' softmax ' ))"
TEST
"implementacija neuralne mreze za klasifikaciju tacaka koje pripadaju krugu poluprecnika 1 , obodu sa njegove leve strane i obodu sa njegove desne strane ili prstenu koji okruzuje sve 3 klase"
print ( classes )
generisanje klase
print ( y_data )
funkcija koja se aproksimira
"Zadatak : Isprojektovati neuralnu mrezu sa ciljem da oponasa funkciju dve promenljive f ( x , y ) = e ^ - x*sin ( y ) . Izvrsiti analizu kvaliteta modeliranja za razlicite slozenosti mreze , i na odgovarajuci nacin ilustrovati dobijeni rezultat ."
f-ja sa 2 argumenta koja se aproksimira
generisanje 200 * 200 podataka
y_vals = [ ]
z_vals = [ ]
"print ( current_x , current_y )"
x_vals . append ( current_x )
model NN
u nastavku je deo koda gde sam pokusao da iscrtam funkciju da bi proverio rezultat ali nisam uspeo
"h = plt . contourf ( x_vals , y_vals , model . predict ( nn_input , batch_size = 1 )) plt . show ( ) ig = plt . figure ( ) ax = plt . axes ( projection = ' 3 d ' ) # ax . plot_surface ( original_x , original_y , original_func , cmap = ' viridis ' , edgecolor = ' none ' ) # ax . plot_surface ( nn_input [ : , 0 ] , nn_input [ : , 1 ] , model . predict ( nn_input , batch_size = 1 ) , cmap = ' viridis ' , edgecolor = ' none ' ) plt . show ( )"
f-ja koja se minimizuje
pm = 0.01
"selekcija tockom ruleta , NE RADI"
gb_grid . best_params_
"Sada ispitujemo kako learning rate utice na tacnost u zavisnosti od velicine ansambala , kao dodatne parametre ubacila sam min_samples_leaf i min_samples_split cije vrednosti sam uzela iz grid search-a ."
"Sto se tice learning rate-a vidimo da su najbolj irezultati na test skupu za lr = 0.1 , dok za lr = 0.5 tacnost raste na trening skupu , ali opada na test skupu-preobucavanje . Za lr = 0.05 tacnost na trening i test skupu je manja nego kada je lr = 0.1. U buducem razmatranju biramo lr = 0.1. Vidi se da sto je lr veci , potrebno je manje stabala da bi se dobila dobra tacnost"
Mesanje podataka i podela na ulaze i izlaze
Nalazenje optimalnih parametara preko GridSearch-a
TODO : Dodaj jos parametara u grid search za random forest klasifikator
"plt . plot ( n , scores_training )"
"plt . legend ( [ ' max_features = 1 ' , ' max_features = 2 ' , ' max_features = 4 ' ] )"
plt . title ( ' Tacnost na trening skupu ' )
Najveca tacnost na trening i test skupu je za max_features = 1
"y = X [ : , 6 ]"
"X = X [ : , 0:6 ]"
"Na osnovu ovih grafika mozemo zakljuciti da je najbolja dubina 5 , kako su rezultati na test skupu najbolji , a osrednji su na trening skupu ."
prek ogrid search-a nalazimo optimalne parametre
azurira tezine minimizacijom funkcije gubitka Parametri X : obelezja trening skupa y : izlazi trening skupa batch : indikator za batch
racuna funkciju gubitka Parametri : h : hipoteza y : izlaz
"vrsi regresiju , tj. predikciju Parametri : X_test : obelezja test skupa"
"treniranje model1 = LogRegression ( alpha = 0.01 , max_n = max_n )"
"model1 . fit ( X_train1 , y_train1 . reshape ( len ( y_train ) , 1 ))"
"Delimo ukupan skup podataka na trening i test skup 80:20 , potom su kreirana tri trening skupa gde izlaz y nema vrednosti 0 , 1 i 2 , vec treniramo samo da odvojimo prvu klasu od druge dve , potom treniramo da odvojimo drugu klasu od prve i trece i na kraju treniramo da odvojimo trecu klasu od prve i druge ."
"Kako su kolone predstavljene kao brojevi , njih ubacujemo u tabelu , potom mesamo skup podataka , gde prvih 6 obelezja pripadaju X-u , a 7. kolona je y. Na X dodajemo kolonu jedinica ."
print ( y_pred2 )
Testiranje na drugoj i trecoj klasi
"treniranje model2 = LogRegression ( alpha = 0.01 , max_n = max_n , lr = 0.1 )"
predikcija je model2 . predict ( X_test )
print ( lambd )
izdvajanje tri trening skupa tj. izdvajanje po klasama
"Sada gledamo koliko su korelisani nasi podaci , racunamo Pirsonov koeficijent korelacije za svaki feature iz X. Na osnovu dobijenih rezultata zakljucujemo da podaci nisu korelisani , stoga ne treba da zanemarujemo nijedan feature ."
TODO : promeni parametre recimo za krosvalidaciju da bude drugi broj podele
lambd_opt = lambdas [ np . where ( tacn == max ( tacn )) ]
print ( lambd_opt )
print ( max ( tacn ))
Kada smo primenili L1 regularizaciju za razlicite vrednosti lambda . Najbolja tacnost se dobija za lambda = 5.6 e-06 i iznosi 0.88185.
"lambdas = np . linspace ( 0.01,0.01,10 )"
"tacn . append ( crossvalidation ( cv = 5 , lambd = lambd , reg = ' L2 ' ))"
print ( tacn )
"TODO : kriva ne valja , tako da vidi sta ne valja u kodu"
Sada testiramo algoritam kada primenimo L2 regularizaciju za razlicite vrednosti lambda . Najbolja tacnost se dobija za lambda = 5.6 e-06 i iznosi 0.88185.
racuna fju gubitka Parametri : X : obelezja trening skupa y : izlaz trening skupa
"Sada proveravamo da li su podaci balansirani ili nebalansirani . Na osnovu rezultata posto nije znacajna razlika izmedju broja odbiraka klasa , zakljcuujemo da su podaci balansirani ."
racuna tacnost na osnovu prediktovanih i stvarnih vrednosti izlaza Parametri : X : obelezja test skupa y : stavrni izlazi test skupa
"print ( ' klasa 0 ima ' , np . sum ( y == 0 ) , ' odbiraka , klasa 1 ima ' , np . sum ( y == 1 ) , ' odbiraka , klasa 2 ima ' , np . sum ( y == 2 ) , ' odbiraka ' )"
model1 = Softmaks ( batch = 32 )
y_pred1 = model1 . predict ( X_test )
TODO : cuvaj rezultate u neki niz
poziv klase je model2 = Softmaks ( batch = 64 )
"tacnost je model2 . accuracy ( X_test , y_test )"
ovde je upozorenje za krosvalidaciju da su uneti vec parametri i da se samo unese broj podele
racuna srednju vrednost Parametri : X : vektor
racuna standardnu devijaciju Parametri : X : vektor
racuna fi ili verovatnocu pojavljivanja odredjene klase u celom skupu X : elementi odredjene klase X_tr : ceo trening skup
racuna parametre za predikciju Parametri : X_train : obelezja trening skupa y_train : izlazi trening skupa
"poziv za GDA je mi1 , mi2 , mi3 , sigma1 , sigma2 , sigma3 , fi1 , fi2 , fi3 = fit ( X_train , y_train )"
"predikcija za GDA je y_pred = predict ( X_test , y_test )"
"Ovaj algoritam se brzo izvrsava i tacnost iznosi 91,42 % ."
Gausovski naivni Bajesov klasifikator
Xn
"Xn =( np . column_stack (( np . ones ( len ( Xn )) , Xn )"
sada testiramo gotovu funkciju na normalizovanim podacima i racunamo tacnost i validacionu krivu
"Prvo radimo za gama = 1 , inicijalizujemo matricu Q na nule . Potom primenimo Belmanovu jednacinu za iterativno racunanje novog Q u svakoj iteraciji ."
"self . position =( self . position [ 0 ] , min ( np . size ( self . Q , 1 ) -1 , self . position [ 1 ] +1 ))"
state = mpo . train ( )
Q ucenje
"Ovde ne znamo verovatnoce unapred i celu mapu , poznate su nam nagrade za svaku poziciju u Q i iznose -0.04 i za tacan kraj 1 ili pogresan kraj -1."
"Biramo sa verovatnocom epsilon da li cemo akciju izabrati nasumicno ili gramzivom pretragom kao argmax ( Q ( s , a ))"
"self . Q [ self . state [ 0 ] , max ( 0 , self . state [ 1 ] -1 ) ] , self . Q [ self . state [ 0 ] , min ( self . state [ 1 ] +1 , np . size ( self . Q , 1 ) -1 ) ] )"
Markovljev proces odlucivanja Atributi : gamma : parametar u belmanovim jednacinama num_iter : broj iteracija Metode : take_action : odredjivanje sledece akcije train : resavanje Belmanovih jednacina za nova stanja plot_states : iscrtavanje stanja po iteracijama
mpo = Q_learning ( )
"Na osnovu datih grafika , mozemo zakljuciti da ako sa vecim epsilon odnosno vecom verovatnocom biramo gramzivu strategiju , to ce nam rezultati biti vise sumoviti"
mpo = Q_learning ( alpha = 0.3 )
"Ako uporedimo ova dva grafika , mozemo videti da sto je manji learning rate , to su manje sumoviti rezultati , ali se sporije konvergira , stoga zadrzavamo vrednost $ \ alpha $ = 0."
poziv Q learning modela mpo = Q_learning ( adaptive = 1 )
"Optimalna putanja je gore , gore , desno , desno , desno , posle otprilike 50 serija potrebno je da se dostigne optimalna putanja , odnosno da se ustale krive na grafiku ."
odlucivanje koja je sledeca akcija i prelazak u novo stanje Parametri : s : stanje a : akcija
"self . next =( s [ 0 ] , min ( s [ 1 ] +1 , np . size ( self . Q , 1 ) -1 ))"
"Imamo 4 x3 tabelu sa poljima i treba da naucimo model da dodje optimalnom putanjom od starta ( 1,1 ) do kraja , nagrade za pozicije ( 4,2 ) i ( 4,3 ) su -1 i 1 respektivno , dok su nagradeu ostalim slucajevima -0.04. Takodje , imamo zid na poziciji ( 2,2 ) . Agenta mozemo da pomeramo napred , nazad , levo i desno i ako dodje do zida ostaje u istoj poziciji ."
resavanje Belmanovih jednacina i na taj nacin generisanje koje je novo stanje na osnovu odredjene akcije Parametri : nema
TODO : umesto moje funckije za racunanje polinoma iskoristi onu iz scikit-learn-a
linearna bez regularizacije i sa krosvalidacijom
linearna sa krosvalidacijom i bez regularizacije
racunanje stohastickog gradijentnog spusta Parametri : w : tezina za lokalno ponderisanu regresiju teta : tezine max_n : broj iteracija alpha : stopa ucenja reg : tip regularizacije lambd : koeficijent regualrizacije
predikcija lokalno pinderisane regresije Parametri : X_train : obelezja trening skupa X_test : obelezja test skupa y_train : izlaz trening skupa y_test : izlaz test skupa max_n : broj iteracija alpha : stopa ucenja reg : tip regularizacije lambd : koeficijent regularizacije
Weight Parametar
index = np . where ( error == min ( error ))
"primer predikcije za lokalno ponderisanu linearnu regresiju y_pred = lwlr_predict ( X_train , X_test , y_train , y_test , tau , epsilon , max_n , alpha , reg , lambd )"
tau iz regularizacije
"ovaj deo koda koji racuna polinome nije tacan , tako da treba koristiti ugradjenu funkciju iz sklearn-a"
"kod Q learning-a nisu dobri uslovi sto se vidi po graficima , tako da ove rezultate ne treba uzimati u obzir"
"pozivanje srednje kvadratne greske error . append ( mse ( y_pred , y_test ))"
racunanje srednje kvadratne greske 2 Parametri : y_pred : prediktovane vrednosti y_test : stvarni izlaz
"val . append ( crossvalidation ( cv , ' lwlr_predict ' , lambd , reg = reg , tau = tau )"
print ( val )
polinomijalna regresija Parametri : X_train : obelezja trening skupa y_tr : izlaz trening skupa y_t : izlaz test skupa X_t : obelezja test skupa dg : stepen polinoma lambd : koeficijent regularizacije reg : tip regularizacije
"print ( min ( error ) , min ( val ))"
val [ 1 ]
cv = 5
"krosvalidacija Parametri : cv : broj jednakih delova trening skupa function : vrsta regresije da li je linearna , polinomijalna ili lokalno ponderisana lambd : koeficijent regularizacije reg : tip regularizacije tau : parametar tau za racunanje lokalno ponderisane regresije"
Parametri : kernel : tip kernela C : koeficijent regularizacije sigma : standardna devijacija
"racuna kernel Parametri : X : prvi vektor Y : drugi vektor kernel_type : tip kerela , gausovski ili linearni"
"G = cvxopt . matrix ( np . vstack (( np . identity ( len ( X )) * -1 , np . identity ( len ( X )"
"h = cvxopt . matrix ( np . hstack (( np . zeros ( len ( X )) , np . ones ( len ( X )) * self . C )"
racunanje matrice konfuzije Parametri : y_test : izlaz test skupa y_pred : predikcija
Menjamo sigma za fiksno C
"pozivanje SVM modela clf = SVM ( C = 2 , kernel = ' rbf ' , sigma = sigma )"
"clf . fit ( X_train , y_train ) treniranje modela"
mozemo kada pozovemo konstruktor klase da pristupimo tezinama kao clf . teta
sigmas [ idx ]
Menjamo C za prethodno odredjeno sigma = 1.112
kolone su ucitane kao neki brojevi
"precision1 , recall1 , f11 , precision2 , recall2 , f12 , acc , conf_mat1 , conf_mat2 = clf . matrix_confusion ( y_test , y_pred )"
X = X. to_numpy ( )
np . random . shuffle ( X )
"Kako se vidi da su vrednosti feature-ova razlicite , potrebno je normalizovati podatke"
"__copyright__ = """" Copyright 2007 , The Cogent Project """""
Sada kreiramo klasu SVM za izvrsavanje support vector machine-a .
ovde sada pisi detaljnije
najbolji parametri za random forest rf_grid . best_params
"racunanje tacnosti za random forest je rfc . score ( X_test , y_test )"
percent = data . isnull ( ) . sum ( ) . sort_values ( ascending = False ) / len ( data )
"missing = pd . concat ( [ total , percent ] , axis = 1 , keys =[ ' Total ' , ' Percent ' ] )"
"data = data . drop ( columns =[ ' Survived ' , ' PassengerId ' ] )"
scatter_matrix ( X )
"clf_sets = [ ( LinearSVC ( penalty = ' l1 ' , loss = ' squared_hinge ' , dual = False , parameters = { ' kernel ' :( ' linear ' , ' rbf ' ) , ' C ' :[ 1 , 10 ] } )"
"X_train , y_train ) ]"
"for clf , parameters in clf_sets :"
cv = 5 )
"grid . fit ( X_test , y_test )"
Standardizacija i normalizacija
Normalizacija je kada uzme x i podeli sa sumom aps vrednosti ili korenom sume kvadrata rez je od 0 do
"norm2 = normalize ( X , norm = ' l2 ' )"
"print ( ' 2 ' , norm2 [ 0:5 , :] )"
"predstavlj kao razliku izmedju objekata , objekti koji su slicni su blizi na grafiku"
Metode za vizuelizaciju podataka
ax = sns . boxplot ( x = data [ ' EstimatedSalary ' ] )
"paramgrid = [ { ' nestimators ' : [ 100,500,10 ] , ' learning"
Mesh grid i contourf
mesh grid mora da se uradi pre contourf a contourf dobija parametre iz grida i granicu prediktora i moze da se doda scatter da se vidi gde su odbirci npr.
"np . arange ( X_train [ : , 1 ] . min ( ) -1 , X_train [ : , 1 ] . max ( ) +1 , step = 0.01 ))"
"plt . scatter ( X_test [ y_test == 1,0 ] , X_test [ y_test == 1,1 ] , color = ' red ' )"
"plt . scatter ( X_test [ y_test == 0,0 ] , X_test [ y_test == 0,1 ] , color = ' blue ' )"
xgb . plot_importance ( xg_reg )
koliko filmova ima po zanru
genre_occurences = movies [ genre_cols ] . sum ( ) . to_dict ( )
Kreiranje dataframea za svim podacima iz Movielens
Podela na trening i test skup Parametri : df : DataFrame holdout_fraction : velicina podele
"TODO : uradi neku analizu podataka i predobradu , kako ove baze su korelisane"
movies_ratings = movies . merge (
". agg ( { ' rating ' : [ ' count ' , ' mean ' ] } )"
on = ' movie_id ' )
Filmovi sa najboljim ratingom ali da je vise od 20 ljudi glasalo
"movies_ratings [[ ' movie_id ' , ' rating count ' , ' rating mean ' ]] . mask ( ' rating count ' , lambda x : x > 20 ) . sort_values ( ' rating mean ' , ascending = False ) . head ( )"
Prikaz broja glasova po zanrovima filmova
"mr = movies_ratings [[ ' movie_id ' , ' rating count ' , ' rating mean ' , ' genre ' ]] . sort_values ( ' rating count ' , ascending = False )"
"mr1 = mr. groupby ( ' genre ' , as_index = False ) . agg ( { ' rating count ' :[ ' sum ' ] } )"
mr1
import tensorflow as tf
filtriranje u okviru ove fje
"pravljenje matrice faktorizacije Parametri : ratings_df : veliki dataframe koji sadrzi rejting , korisnike i filmove"
return df [ function ( df [ key ] ) ]
"def train ( self , num_iterations = 100 , learning_rate = 1.0 , plot_results = True , optimizer = tf . train . GradientDescentOptimizer ) :"
azuriranje tezina Parametri : num_iterations : broj iteracija learning_rate : stopa ucenja plot_results : indikator da li rezultati treba da se iscrtaju optimizer : tehnika optimizacije-gradijentni spust
TODO : probaj da napravis bez TensorFlowa model
! pip install -- upgrade - q gspread
from google . colab import auth
mod =( model . metrics_vals [ 0 ] )
plt . title ( ' Greska na trening i test skupu ' )
plt . ylabel ( ' MSE ' )
plt . legend ( leg )
from oauth2client . client import GoogleCredentials
Pretraga ID-ja filma za dati podstring Parametri : model : istreniran model title_substring : podstring titla measure : metrika slicnosti k : koliko najslicnijih se ostavlja
"Za movie recommendation system koristimo Movielens bazu , koja ima movies , rating i users tabele . Rating je u opsegu od 0 do 5."
metrike mod =( model2 . metrics_vals [ 0 ] )
"Ucitaj svaku bazu podataka ( korisnici , filmovi , rejtinzi ) ."
Baza sa filmovima ima kolonu sa zanrovima
genre_cols = [
"ratings , regularization_coeff = 0.1 , gravity_coeff = 0.1 , embedding_dim = 35 ,"
"reg_model . train ( num_iterations = 700 , learning_rate = 20. )"
"Crime , """" Documentary """" , """" Drama """" , """" Fantasy """" , """" Film-Noir """" , """" Horror """" ,"
"Musical , """" Mystery """" , """" Romance """" , """" Sci-Fi """" , """" Thriller """" , """" War """" , """" Western """""
mne biblioteka koja može da učita format EEG snimaka
učitavanje fajlova i izlistavanje po direktorijumima
Potrebno promeniti spram repozitorijuma na svom računaru
izdvajanje frekvencije odabiranja
izdvajanje usrednjenog kanala
korišćene vrednosti parametara za welch funkciju su preporučene
uticaj primene različitih vrednosti parametara za welch estimator može biti veliki na izlaznu estimaciju spektra
traženje individualizovane frekvencije alfa talasa se traži pomoću otežinjene srednje vrednosti
ispitati druge metode izvlačenja IAF frekvencije
slika koja predstavlja skup obeležja
"u okviru ove baze se to opravdava činjenicom da zadnja 4 kanala predstavljaju ne-EEG signale , spram tipa snimaka bi se odbacivalo više ili manje kanala u drugim slučajevima"
iščitavamo podatke za dati kanal iz sirovog snimka
welch estimator spektra
pogledati napomenu u liniji koda 47
Tražimo snagu aktivnosti različitih moždanih talasa
potrebno je ispitati na koji način promene opsega moždanih talasa u frekvencijkom opsegu utiču
navedeni opsezi su pronađeni u literaturi korišćenoj u okviru projekta
normirane vrednosti aktivnosti talasa se postavljaju na 3 kanala boje u okviru slike koja predstavlja obeležja
Program za izvlačenje obeležja iz EEG signala
prikaz slike
čuvanje slike
učitavanje baze podataka
izvlačenje slika koje predstavljaju EEG obeležja
U daljem radu obeležja mogu biti mali video snimci
prolazimo kroz sve slike
interpoliramo
Program za interpolaciju slika koja predstavlju EEG obeležja
potencijalno izbaciti
IAF predstavlja individualizovanu alfa frekvenciju i računa se u programu feature_extraction . py
u ovom delu koda se posebno izdvaja 28. dokument iz razloga što je na njemu kanal koji nosi podatke o statusu specifičan
učitava se sirovi fajl
ovaj kod koriguje odsustvo naziva kanala
izaberi podatke sa statusnog kanala
izdvajamo indekse koji predstavljaju početak snimanja
podešavanje periode odabirnaja
podešavanje standarda
učitavamo i biramo minut snimka
filtriramo snimak u opsegu od 2 do 40 Hz
Ovaj deo koda se najduže izvršava
ICA analiza razdvaja snimak na nezavisne komponente i služi za odbacivanje onih komponenti koje su odgovorne za EOG artefakte
ica . plot_scores ( scores_eog )
biblioteka koja čita format u kome su zapisani EEG signali
Funkcija koja predstavlja neuralnu mrežu koja vrši klasifikaciju na osnovu izvučenih obeležja u formi slike . Mreža je realizovana kao niz konvolucionih i maks pooling slojeva . Funkcija uzima na ulazu sliku kao obeležje i izbacuje klasu .
"one_hot_y [ np . arange ( y. size ) , y ] = print ( ' Acc train : ' , acc_train [ i ] , ' Acc test : ' , acc_test [ i ] ) acc_train [ i ] = sum (( np . argmax ( output , axis = 1 ) == np . argmax ( one_hot_y , axis = 1 ) / len ( train_df )"
"k = k output = sess . run ( classes_output , feed_dict = { input_placeholder : get_data ( table , batch_size ) , output_placeholder : output_values , is_training : False } ) acc = sum (( np . argmax ( output , axis = 1 ) == np . argmax ( output_values , axis = 1 ) / batch_size if ( k % 20 == 0 ) : #loss_value = sess . run ( loss , feed_dict = { input_placeholder : get_data ( table , batch_size ) , output_placeholder : output_values , is_training : False } ) output = sess . run ( classes_output , feed_dict = { input_placeholder : get_data ( table , batch_size ) , output_placeholder : output_values , is_training : False } ) acc = sum (( np . argmax ( output , axis = 1 ) == np . argmax ( output_values , axis = 1 ) / batch_size print ( ' accuracy after : ' + str ( k ) + ' iterations ' + str ( acc ) + ' ( on random sample ) ' ) #print ( output [ random . randint ( 0,30 ) ] ) print ( ' accuracy after : ' + str ( acc ) + ' ( ' + str ( k ) + ' iterations needed ) ' ) #saver.save ( sess , ' ./ model . ckpt ' ) saver . save ( sess , ' ../ input / model . ckpt ' ) y = y. astype ( ' int ' ) one_hot_y = np . zeros (( y. size , y. max ( ) +1 ))"
"one_hot_y [ np . arange ( y. size ) , y ] = stored_outputs [ : , current_network_index ] = np . squeeze ( sess . run ( classes_output , feed_dict = { input_placeholder : converted_x , output_placeholder : y , learned_features : learned } )) print ('#') print ( np . mean (( np . mean ( stored_outputs , axis = 1 ) > 0 ) == ( y > 0 ) print ('#') saver . save ( sess , ' D :/ Neuralno_inzenjerstvo / Projekat / trained_ensemble / model ' + str ( current_network_index +1 ) + ' . ckpt ' ) y = y. astype ( ' int ' ) one_hot_y = np . zeros (( y. size , y. max ( ) +1 ))"
Trenutna verzija koda predviđa slike kao ulaze a sledeće verzije će potencijalno imati nizove slika
"input_layer = tf . reshape ( input_values , [ -1,9,9,3 ] )"
"conv2 = tf . layers . conv2d ( inputs = pooling1 , filters = 6 , strides =[ 1,1 ] , kernel_size =[ 3 , 3 ] , padding = """" same """" , activation = tf . nn. tanh , kernel_regularizer = tf . contrib . layers . l1_regularizer ( 0.001 ) , kernel_initializer = tf . random_normal_initializer , bias_initializer = tf . random_normal_initializer )"
"pooling2 = tf . layers . max_pooling2d ( inputs = conv2 , pool_size =[ 5,5 ] , strides =[ 2,2 ] , padding = """" same """" )"
"conv3 = tf . layers . conv2d ( inputs = conv2 , filters = 5 , strides =[ 3,3 ] , kernel_size =[ 3 , 3 ] , padding = """" same """" , activation = tf . nn. tanh , kernel_regularizer = tf . contrib . layers . l1_regularizer ( 0.001 ))"
print ( flat . shape )
"combined = tf . keras . layers . concatenate ( [ flat_input , flat ] )"
drop2 = tf . keras . layers . Dropout ( rate = 0.6 ) ( dense_layer1 )
"dense_layer2 = tf . layers . dense ( inputs = dense_layer1 , units = 10 , activation = tf . nn. tanh , kernel_regularizer = tf . contrib . layers . l1_regularizer ( 0.001 ) , kernel_initializer = tf . random_normal_initializer )"
Tensorflow verzija 1.15
@author : tijanav
Promeniti direktorijum po potrebi
frequency prikazuje koliko puta se javlja rec word u celoj bazi
Projekat iz predmeta obrada prirodnih jezika
Učitavanje baze
Po potrebi dodati parametar header = None ukoliko nisu upisani nazivi kolona u dokument
baza podataka u kojoj će se nalaziti enkodovani komentari i klase komentara
prolazak kroz bazu radi enkodovanja komentara i upisivanja u novu bazu
pronađi indekse na kojima se nalaze reči iz komentara i postavi jedinice u enkodingu na odgovarajuća mesta
Provera enkodovanja komentara
Projekat iz Obrade prirodnih jezika
Predprocesiranje za običan bag of words model
Nova baza podataka
proveri da li je komentar validan
Ukoliko komentar sadrži barem dve reči izdvajati bigrame
prolazak kroz celu bazu radi enkodovanja
dodavanje novog komentara u bazu
izdvanjanje podataka iz baze u formi niza za potrebe dalje analize
Predprocesiranje komentara u formi bigrama
po potrebi menjati direktorijum dokumenta
"tf_df = pd . DataFrame ( [ ] , columns =[ ' comment ' , ' label ' ] )"
Rečnik koji sadrži unikatne vrednosti iz baze
tf_idf je kada pomnozimo tf i idf
"tf_df = tf_df . append ( { ' comment ' : tf , ' label ' : df . loc [ i ] [ 6 ] } , ignore_index = True )"
"tf_idf_df = tf_idf_df . append ( { ' comment ' : tf_idf , ' label ' : df . loc [ i ] [ 6 ] } , ignore_index = True )"
Izmenjati po potredbi direktorijum
promeniti naziv nove baze da se uklapa sa tipom predprocesiranja
Created on Thu Jun 25 21:41:30 2020
jesam
glagol moći
"Tokenize only words larger than 2 characters , apart from modal verbs"
pravi gresku kod pevasmo
bilo ik
"mozda treba az , pokazati , pokazxe"
Created on Thu Jun 25 22:31:59 2020
@autor : ivanv Projekat iz obrade prirodnih jezika
atomicni write u vec otvoren fajl
nasumicna raspodela duzine posla
"x = [ 1,1,2 ]"
iterativni postupak
funkcija solveGN formira Godon-Newell-ove jednacine i resava ih tako da se normalizacija vrši prema prvom resursu koji je procesor
funkcija koja određuje G ( n ) Bjuzenovom metodom
"p00 = 0 , p01 = 0.15 , p02 = 0.15 , p0 [ range ( 3 , k +4 ) ] = 0.7 / k p10 = 0.5 , p11 = 0 , p12 = 0 , p1 [ range ( 3 , k +4 ) ] = 0.5 / k p20 = 0.5 , p21 = 0 , p22 = 0 , p2 [ range ( 3 , k +4 ) ] = 0.5 / k p [ range 3 , k +4 ] 0 = 1 , p [ range 3 , k +4 ] * = 0"
eksponencijalna raspodela duzine posla
blokirajuci fifo bafer u kojem se cuvaju neopsluzeni poslovi
klasni flag koji obavestava da li je proesor zavrsio tj da li je gotova simulacija
"cela simulacija je gotova , prolazenje kroz poslove u redu"
redefinise se u klasi koje izvode resurs
0.7 > rand > 0
formatiranje za id uniform ( 0 to k ) +3
50 % cpu 50 % some of user discs
pronalazenje procesora ciji je id = 0
100 % cpu
globalni prosek vremena trajanja poslova
ne treba da se racuna u inicijalnom stanju
racunanje prosecnog trajanja opsluzivanja poslova
work se startuje u run ( ) metodi
prosecan broj poslova u resursu
samo kod procesora
dummy poslovi postoje da bi svi poslovi obisli ceo krug u sistemu i zavrsili kod procesora
procesor je zavrsio
dohvatanje procesorskih parametara nakon simulacije
id sistemskog diska
id drugog sistemskog diska
ciscenje parametara resursa i rezultata simulacije za ponovno pokretanje
povezivanje resursa
ucitavanje poslova
inicijalizacija
"params = { ' max_depth ' :[ 3,5,8,12 ] }"
dtr = DecisionTreeRegressor ( max_depth = 8 )
"dtr . fit ( X_train , y_train )"
"mapa . resize (( 172,172 ))"
"mapa . resize (( 2 , 1 ))"
img . thumbnail ( size )
mapa = np . array ( img )
"window_sum = _window_sum_2d ( image , window_shape )"
"window_sum = np . cumsum ( window_sum , axis = 2 )"
"window_sum = ( window_sum [ : , : , window_shape [ 2 ] : -1 ]"
return window_sum
"frames = np . intersect1d ( jointframes , bbframes )"
xbb = bboxes [ ' frames ' ] [ i ] [ ' bounding_boxes ' ] [ j ] [ ' bounding_box ' ] [ ' x ' ]
print ( matches )
"for j in range ( i +1 , len ( occurCount )) :"
if ( len ( occurCount [ list ( occurCount . keys ()) [ i ]] ) == len ( occurCount [ list ( occurCount . keys ()) [ j ]] ) and ( occurCount [ list ( occurCount . keys ()) [ i ]] == occurCount [ list ( occurCount . keys ()) [ j ]] ) . all ())
niz . append ( list ( occurCount . keys ()) [ j ] )
if niz :
same [ i ] = niz
"print ( ' uniqueValues , ' , matches )"
del matches [ list ( uniqueValues . keys ()) [ j ]]
del uniqueValues [ list ( uniqueValues . keys ()) [ j ]]
if ( uniqueValues [ list ( uniqueValues . keys ()) [ i ]] > = uniqueValues [ list ( uniqueValues . keys ()) [ j ]] [ 0 ] and i ! = j )
uniqueValues [ list ( uniqueValues . keys ()) [ j ]] = uniqueValues [ list ( uniqueValues . keys ()) [ j ]] [ 1 :
matches [ same [ list ( same ) [ i ]] [ j ]]
same [ list ( same ) [ i ]] [ j ]
for j in range ( len ( bboxes [ ' frames ' ] [ ind ] )) :
"x =[ 1,2,5 ]"
"y =[ 1,3,5 ]"
"f = interp1d ( x , y , fill_value = """" extrapolate """" )"
f ( 6 )
if ( np . shape ( joints [ ' frames ' ] [ j ] [ ' joints ' ] )) :
if ( joints [ ' frames ' ] [ j ] [ ' joints ' ] [ k ] [ ' identity ' ] == i ) :
for i in matches . keys ( ) :
bboxes [ ' frames ' ] [ j ] [ ' bounding_boxes ' ] [ k ]
for j in solo_joint . keys ( ) :
if ( solo_bb [ i ] == solo_joint [ j ] [ ' frames ' ] ) :
s + = matches [ i ]
"s + = """" : """""
s + = i
print ( s )
for i in index . keys ( ) :
niz = np . argsort ( fr1 [ same [ 1 ] [ j ]] [ 0 : len ( same [ 1 ] ) ] )
np . sort ( fr1 [ same [ 1 ] [ j ]] [ 0 : len ( same [ 1 ] ) ] )
import matplotlib . pyplot as plt
"features [ i , j , 0 ] = np . mean ( map_img [ i +20 : i +40 , j : j +20,0 ] )"
"features [ i , j , 0 ] = np . mean ( map_img [ i : i +20 , j +20 : j +40,0 ] )"
funkcija koja proverava da li okvir obuhvata datu tačku
učitavanje okvira
prolazak kroz frejmove
for i in range ( 26 ) :
poziv funkcije animacije
Kreiraj ose
Kreiraj pravougaonike
kreiraj tačke #
funkcija inicijalizacije
"Klasa koja služi za animaciju okvira . Sastoji se od konstruktora , funkcije inicijalizacije , funkcije animacije i funkcije za poziv animacije ."
plt . imshow ( mask_display > 2 )
izdvajanje fajlova
lista dokumenata
prolaz kroz sva dokumenta
odgovori
izlaz
"img_features [ 1 ] = np . mean ( img [ 0 : patch_h , patch_w // 4 : patch_w // 2 , 1 ] )"
"Postoji vise metoda za pretvaranje u numericke promenljive : One Hot Encodding ( sa pd . get_dummies ) , Custom Binary Encoding , Find and Replace ( manje vise ovo je rucno ) ."
Metode koje ce se koristiti u ovom projektu su :
"Random Forest , autoenkoder i korelacija izmedju obelezja"
1. Random Forest
"Napravimo random forest regresor koji se istrenira na trening podacima ( ulazu i izlazu ) , potom se odredi pomocu ugradjene funkcije koliko su bitna obelezja i na osnovu grafika koji iscrtavamo odredimo koliko obelezja zelimo da zadrzimo . U ovom slucaju odlucila sam se da zadrzim 9 obelezja ."
random forest regresija Parametri : train2 : trening skup max_depth : najveca dubina stabla br : koliko najboljih obelezja se zadrzava
"encoded1 = Dense ( 30 , activation = ' relu ' ) ( input_dim )"
"encoded3 = Dense ( 2500 , activation = ' relu ' ) ( encoded2 )"
"encoded7 = Dense ( 1500 , activation = ' relu ' ) ( encoded6 )"
"encoded8 = Dense ( 1250 , activation = ' relu ' ) ( encoded7 )"
"encoded10 = Dense ( 750 , activation = ' relu ' ) ( encoded9 )"
"encoded11 = Dense ( 500 , activation = ' relu ' ) ( encoded10 )"
3. Izbacivanje korelacijom izmedju feature-a
Selektovanje gornjeg trougla matrice korelacije
Nalazenje indeksa obelezja sa korelacijom vecom od 0.95
"Izdvajamo obelezja sa sve 3 metode redukcije dimenzija , potom delimo na trening i test skup 80:20."
Nalazenje feature-a sa korelacijom vecom od 0.95
ako zelimo regresiju ne koristimo ove kvantile
print ( np . sqrt ( - grid_rf . best_score_ ))
1. Random Forest redukcija
2. Redukcija autoenkoderom
3. Redukcija korelacijom
"koriscenje korelacije nbc_obicno . update ( [ ( ' Korelacija ' , tacn_corr ) ] )"
4. Bez redukcije
TODO : logaritamski skaliraj obelezja
"plt . xticks ( range ( len ( nbc_log )) , list ( nbc_log . keys ( )"
plt . title ( ' Naive Bayes klasifikator i obelezja logaritamska ' )
zamena ' NaN ' sa ' None '
row_count = sum ( 1 for row in csv_reader )
"print ( """" row_count is """" , row_count )"
"print ( """" batch_size is """" , batch_size )"
"data . shape [ 0 ] = 20 , data . shape [ 1 ] = 160"
"print ( """" len of lines should be """" , batch_size , """" and is """" , len ( lines ))"
"deljenje 160 odlika u 4 puta po 40 , ukupno 20 uzoraka se povecava na 80"
print ( data [ 0 ] )
za rucno testiranje
print ( data )
plt . plot ( normalized . tolist ())
mesanje podataka
pisanje u csv izmesane podatke za obucavanje
"data = np . reshape ( data , ( data . shape [ 0 ] / 2 , 2 , data . shape [ 1 ] ))"
returns list of batch_size elements
", validation_split = 0.01"
"model . add ( k. layers . LSTM ( units = 200 , return_sequences = True , )) model . add ( k. layers . LSTM ( units = 300 , return_sequences = True )) model . add ( k. layers . BatchNormalization ()) model . add ( k. layers . Activation ( ' sigmoid ' )) model . add ( k. layers . Dropout ( 0.2 )) model . add ( k. layers . TimeDistributed ( k. layers . Dense ( units = 300 ) model . add ( k. layers . TimeDistributed ( k. layers . Dense ( units = 50 ) model . add ( k. layers . Dense ( units = 30 , activation = ' sigmoid ' )) model . add ( k. layers . Dense ( units = 21 , activation = ' softmax ' )) model . add ( k. layers . LSTM ( units = 21 , return_sequences = False ))"
"balansirani model , stateful je sa 4 beceva po jednom podatku"
"input_shape =( 40 , 1 ) ,"
self . distribution . load_freq_from_text ( self . ciphertext )
glavna funkcija koja pomocu opsianog algoritma dekriptuje tekst kriptovan supstitucijom
step
"TODO swap e sa e daje net == 0 , swap q sa q daje net ! = 0"
inicijalizacija celog algoritma
"parsiranje frekvencija pojavljivanja simbola u engleskom jeziku , fajl sadrzi onegrame i bigrame"
relativna frekvencija za temp_key u tekstu
parsiranje bigrama
dekripcija jednok kriptovanog karaktera k sa supstitucijskim kljucem k
import cryptanalysis . monoalphabetic . freq_matrix as freq_matrix
enkriptovanje plaintexta sa kljucem key
def analize_plaintext ( plaintext ) : plaintext = transform ( plaintext ) expected = freq_matrix . FreqMatrix ( ) expected . load_expected_bigram_file ( ) distribution = freq_matrix . FreqMatrix ( )
funkcija koja izdvaja samo alfabetske karaktere
print ( key )
karakter iz cipher [ i ] se koristi da se dobije pozicija plaintext karaktera u kljucu
"plain = """" Lorem Ipsum is simply dummy text of the printing and typesetting industry . """" key = """" key """" c = encrypt ( plain , 1 ) print ( c ) print ( decrypt ( c , 1 ))"
"print ( """" reading line """" )"
glavni tip podatka u kojem se cuva matrica sa frekvencijama pojavljivanja bigrama
ucitavanje bigramskih frekvencija iz fajla
zamena redova i kolona u matrici
"self . swap_indexes ( char1 , char2 )"
ucitava tekst i racuna frekvenciju
"self . matrix [ map . mapping [ k [ 0 ]] , map . mapping [ k [ 1 ] = v / len ( text )"
"diff + = abs ( self . matrix [ self . indexes . find ( decrypt_mono ( char1 , key )) , self . indexes . find ( decrypt_mono ( char2 , key )) ] - expected_matrix . matrix [ expected_matrix . indexes . find ( char1 ) , expected_matrix . indexes . find ( char2 ) ] )"
"t = FreqMatrix ( ) t. load_freq_from_text ( transform ( """" etaoatotoatataotteoataetoaotoatoeoteotatet """" )) t. print_indexes ( ) t. print_matrix ( ) print ('*') t. swap_cols_rows ( ' e ' , ' t ' ) t. print_indexes ( ) t. print_matrix ( ) e = FreqMatrix ( ) e. load_expected_bigram_file ( ) e. print_matrix ( ) e. print_indexes ( )"
zamena karaktera u kljucu
sadrzi mapiranje iz karaktera u redne brojeve i obrnuto
alfabet
TODO : probaj i numericko resenje
"ako se bira kao loss = categorical_crossentropy to znaci da smo primenili one hot encoding , inace biramo ovo drugo"
"kako da sacuva tensor neku random uniformnu raspodelu , pravi . npz file gde cuva tensor"
"xs = np . random . uniform ( -10,10 , ( br , 1 ))"
"inputs = np . column_stack (( xs , zs ))"
"np . savez ( ' Audio_train ' , inputs = train_inp , targets = train_tar )"
"trenira se jako sporo , tako da treba promeniti batch size ili smanjiti trening skup"
"np . savez ( ' TF_intro ' , inputs , target )"
"pozivanje modela model . compile ( loss = ' sparse_categorical_crossentropy ' , optimizer = ' adam ' , metrics =[ ' accuracy ' ] )"
"tensor moze biti konstanta ili niz , shape za jedan broj je empty tupple"
x = tf . constant ( 3 )
"target = target . reshape ( br , )"
"tf . auto_reuse kreira avrijablu ako vec ne postoji , inace je vraca"
fig = plt . figure ( )
"var2 = tf . get_variable ( ' var2 ' , initializer = 5 , dtype = tf . int32 )"
"var3 = tf . get_variable ( ' var3 ' , initializer = var2 . initialized_value ( ) +1 )"
sess . run ( tf . global_variables_initializer ()) inicijalizuje globalne var
pprint ( tf . get_collection ( tf . GraphKeys . GLOBAL_VARIABLES ))
"six , seven = sess . run ( [ var2 , var3 ] )"
"ax = fig . add_subplot ( 1 , projection = ' 3 d ' )"
"a = tf . get_variable ( """" var_a """" , 1 )"
print ( a. name )
ax . set_xlabel ( ' xs ' )
grafovi i sesije
c = tf . constant ( 4.0 )
assert c. graph is tf . get_default_graph ( )
cvorovi grafa su operacije a inputi i izlazi su kao grane
"x = tf . get_variable ( ' x ' , shape =[ 5,2,3 ] )"
"y = tf . get_variable ( ' y ' , shape =[ 5,3,1 ] )"
"assert z. shape == ( 5,2,1 )"
z = tf . get_collection ( ' my_coll ' ) [ 0 ]
input_size = 2
) ] )
"model . fit ( train [ ' inputs ' ] , train [ ' target ' ] , epochs = 100 , verbose = 1 )"
model . layers [ 0 ] . get_weights ( ) prvo je w drugo je b
"plt . plot ( np . squeeze ( model . predict_on_batch ( train [ ' inputs ' ] )) , np . squeeze ( train [ ' target ' ] ))"
plt . xlabel ( ' predikcija ' )
plt . ylabel ( ' target ' )
skaliranje slike
map pravi transformaciju na nekom skupu
scaled = train . map ( scale )
test = test . map ( scale )
racunanje vrednosti bacenih kockica
"elif get_full ( dices ) ! = 0 : print ( """" Full """" ) elif get_three ( dices ) ! = 0 : print ( """" Three of a kind """" )"
"elif has_straight ( dices ) : print ( """" Straight """" ) for dice in dices : print ( dice . get_val ())"
za minimalnu vrednost zdravorazumski je izostaviti kockicu sa najvecom vrednostu
Fajl koji pruza pomocne funkcije
"neocekivana greska , redovi u tabeli imaju opseg od 0 do 12"
funkcija za normalizovanje
funkcija koja proverava da li kockice imaju kentu
funkcija dohvata vrednost trilinga
funkcija dohvata zbirnu vrednost 4 iste kockice
"dodavanje torke ( val , col , row )"
sortiraj po ogranicenjima rastuci
"ako je ponderisana vrednost manja od maksimalne , bacaj ponovo"
ruzno konvertovanje u binarni kod zbog pritiska sa vremenom
igranje igre i istovremeno obucavanje
upisano
ulazni neuroni su hard kodovani zbog prirode problema
odlucivanje da li kockica treba da se baca
": return : lista sa : vrednostima polja , is_unlocked atribut polja , vrednosti kockica"
odozgo
odozdo
sredina gornja sekcija
sredina donja sekcija
krajevi donja sekcija
setovanje maksimalnih vrednosti
ful
kare
"trainer = Trainer ( 200 , 2 , 2 , 50 )"
"while random_int == i : print ( """" rand is """" , random_int , """" population size is """" , ( len ( self . population ) random_int = randint ( 0 , ( len ( self . population )"
radi
prvi prolaz
selekcija bolje dve trecine populacije
klasa trainer upravlja celom populacijom neuralnih mreza
reprodukcija
"Levo - tabela jamba koju igra neuralna mreza obucavana genetskim algoritmom koristeci selekciju , mutaciju i ukrstanje gena"
inicijalizuje se sa nulama
ispis genetskog algoritma
ispis nn sa csp
"while True : gui . paint_tables ( gui . csp , gui . ga ) root . update ( )"
leve kolone
"kolone ( 1 to 6 , min , max , straight . )"
desna kolona
redovi
zaglavlja
10 % mutacija
"hidden_neurons = lista neurona primer neuron_list = [ 15 , 10 5 ] znaci da neuralna mreza ima 3 sloja ; 15 neurona za ulaz , 10 skrivenih , 5 izlaz ulazni neuroni ( Hard coded ! ) : ulazni neuroni primaju vrednosti koje odgovaraju 6 kolona puta po 13 redova , svako polje nosi 2 informacije 6 vrednosti za kockice 1 vrednost koja oznacava broj bacanja 78 * 2 + 6 + 1 = 163 ulaznih neurona"
funkcija game . make_decision osigurava maksimalno 3 bacanja u jednom potezu
svakako se nastavlja sa igrom
igra je gotova
neuron_list [ 0 ] = 163
"print ( """" length of new bias and weigth is """" , len ( new . get_genes ( ) [ 0 ] [ 1 ] ) , len ( new . get_genes ( ) [ 1 ] [ 1 ] ))"
"skriveni neuroni : lista , primer : [ 500 , 200 , 100 ]"
kockice koje se bacaju
tabela je lista kolona
"tabela je puna , igra je gotova"
"decoded = [ 1 , column index , row index ]"
"glavna funkcija , upisuje vrednost u matricu koja predstavlja tabelu"
gornja sekcija
ones * ( max-min )
donja sekcija
gornja sekcija se racuna sa 6 kockica
krajevi
"otkljucavaju se polja samo koja su trenutno zakljucana , prazna i susedna"
"ako je index u gornjoj sekciji , otkljucaj samo gornja polja"
analogno i za donju sekciju
Unos podataka u tabelu ISPIT
Prijavljivanje na bazu podataka mstud
Unos podataka u tabelu PREDMET
Pravljenje baze podataka mstud
Pravljenje tabele ISPITNI_ROK
Unos podataka u tabelu ISPITNI_ROK
' 1 ' - samo predmeti iz 1. semestra
' 2 ' - samo predmeti iz 2. semestra
' B ' - predmeti iz oba semestra
"' X ' - samo po jedan predmet , ako je poslednji nepolozen"
Pravljenje tabele KURS
Pravljenje tabele SEMESTAR
Pravljenje tabele SMER
Pravljenje tabele NIVO_KVALIFIKACIJE
Pravljenje tabele USLOVNI_PREDMET
Pravljenje tabele UPIS_GODINE
update dosije set ime = ' Vlastimir ' where indeks = 20061107 ;
"broj registra [ 0,99 ]"
"[ 0,499 ]"
kontrolni broj
Pravljenje JMBG brojeva studenata
Ulazni parametri
Object : StoredProcedure [ dbo ] . [ CopyTable ] Script Date : 10/09/2015 09:21:45
Provera @@ FETCH_STATUS da bi se videlo ima li jos redova
Verbose Mode
Izvrsava iskaz
Omogucava promenu naprednih opcija .
Azurira trenutno konfigurisanu vrednost za xp_cmdshell
Azurira trenutno konfigurisanu vrednost za napredne opcije .
Omogucava xp_cmdshell
Napomena : Morate imati sysadmin-role za pokretanje ove skripte .
DROP TABLE #DatabaseOwners ;
Copyright ( c ) Microsoft Corporation . All rights reserved .
Ova skripta kreira upozorenja i poslove koji se zahtevaju kako bi se izvelo ciscenje baze podataka .
Napomena : Poslovi moraju biti kreirani pre upozorenja jer ih upozorenja referenciraju
select * from sys . master_files
Autor : Mayur jh . Sanap Datum : 30 - 12 - 2012
Skripta dostavlja status svih sql poslova .
Izlistava aktivni trace na lokalnom serveru
Naslov : Skripta koja cita SQL Trace informacije Opis : Ova skripta analizira informacije SQL Trace na odredjenoj SQL instanci
"Kompatibilne i testirane SQL Verzije : 2005 , 2008 , 2008 R2 , 2012 , 2014 , 2016 & 2017 Upotreba : 1. Otvoriti Open SQL Server Management Studio ( SSMS ) i povezati se na SQL server . 2. Otvoriti “ New Query ” prozor , iskopirati ceo kod tamo i pokrenuti ga 3. Uneti vrednosti parametara po potrebi SELECT @Trace_File_id = 1 , @Trace_Event = ' % ' --> Filtrira odredjeni Trace Event , @Db_Name = ' % ' --> Filtrira odredjeni DB , @Search_Text = ' % ' --> Filtrira odredjeni T-SQL Query , @Search_By_User = ' % ' --> Filtrira odredjenog korisnika"
Dohvata podatke iz xml poruke
Loguje pocetak operacije
Enkapsulacija u TRY .. CATCH za resavanje izuzetaka u odredjenom zahtevu
Izvrsava zahtev
Loguje neuspeh u toku operacije
commit
reset xml poruke
Uvecava brojac gresaka
Ceka 5 sekundi
reset promenljivih
Ukljucivanje servisnog brokera
Odbacivanje postojecih objekata
Kreira objekte servisnog brokera
maksimalan broj konkurentnih instanci
Ova procedura popunjava queue za asinhrone okidace
gradi xml poruku
slanje poruke
"Koriscenje : 1. Pokrenite ovu skriptu na bazi na kojoj zelite da koristite asinhrone okidace 2. Napravite uskladistenu proceduru koja prima sledeca dva parametra : @inserted XML , @deleted XML Ova procedura je odgovorna za parsiranje podataka kojima se manipulise i izvrsavanje stvarne logike okidaca na osnovu tih podataka . 3. Unutar stvarnog okidaca na tabeli , koristite sledeci kod : DECLARE @inserted XML , @deleted XML ; SELECT @inserted = ( SELECT * FROM inserted FOR XML PATH ( ' row ' ) , ROOT ( ' inserted ' ) ) ; SELECT @deleted = ( SELECT * FROM deleted FOR XML PATH ( ' row ' ) , ROOT ( ' deleted ' ) ) ; EXECUTE SB_AT_Fire_Trigger ' { YourProcedureName } ' , @inserted , @deleted ; Ali zamenite { YourProcedureName } imenom procedure koju ste kreirali u koraku 2."
Postavlja da se verbose mode za statusne poruke pre i nakon svake operacije
dozvoljava do 10 gresaka u slucaju problema sa Service Broker
obrada jedne po jedne poruke
"Zakomentarisati sledecu liniju da bi se prikazali svi poslovi , inace se prikazuju samo poslovi od juce"
"AND sjh . run_date > CONVERT ( varchar ( 8 ) , GETDATE ( ) -1,112 )"
SSAS moze da loguje informacije o izvrsavanju upita u relacionu bazu . Ova Transact-SQL skripta pruza prosti upit koji razdvaja putanju do objekta u : - ime servera - database ID - cube ID - ID merne grupe
SELECT * FROM qry ORDER BY StartTime DESC ;
"SELECT ObjPath , Dataset , MAX ( Duration ) AS MaxDuration , AVG ( Duration ) AS AvgDuration , SUM ( Duration ) AS SumDuration , COUNT (*) AS Executions , MAX ( StartTime ) AS LastExection FROM qry GROUP BY ObjPath , Dataset ORDER BY MaxDuration DESC ;"
Koliko cesto upit dobija rezultat iz cache-a
"Parametri @ToCollation - Destinacioni collation @Tablename - Ime tabele za koju se menja collation Podrazumevano je '' , tada ce sve tabele biti razmatrane @ColumnName - Ime kolone za koju se menja collation Podrazumevano je '' , tada ce sve kolone biti razmatrane @SchemaName - Ime sheme za koju se menja collation Podrazumevano je '' , tada ce sve kolone biti razmatrane @FromCollation - @GenerateScriptsOnly - Generise skripte za promenu collation Podrazumevano je 1"
Sortira po vrednosti stranog kljuca
Backup pogledi
Backup sracunate kolone
Backup statistika
AND SchemaName = @SchemaName
Backup provera ogranicenja
Backup ogranicenja vezanih za strani kljuc
", @SQL = ' IF ' + ExistsScript + CHAR ( 13 ) + DropScript + CHAR ( 13 )"
Primena promenjenih collation vrednosti
Unutranja petlja - vracanje odbacenih objekata
AND BK . [ type ] = ' D '
Cisti poruke iz redova cekanja
Cisti transmisioni red
Ovde se moze dodati uslov po potrebi
Zavrsava konverzaciju ciscenjem
Parametri @SourceDBName = Ime izvorne baze @DestDBName = Ime destinacione aze sa kojom se vrsi poredjenje @ObjectName = Za poredjenje imena objekata
"Normal """" / validne vrednosti"
Maksimalna velicina CSV fajla
Ciscenje temp tabele
Odbacuje staru verziju ako postoji
"U odredjenim situacijama podaci su sacuvani kao CSV ( comma separted values ) u jednoj koloni jer isprva ne deluju toliko vazno . Kasnije moze da zatreba da se omoguci select tih podataka kao odvojenih vrednosti iz """" 1 : n """" tabele ."
"Ova Transact-SQL skripta deli CSV u odvojene vrednosti i vraca ih kao tabelu . Za ovo se koristi jednostavni rekurzivni CTE ( common table expression ) , koji trazi naredni delimiter i vraca vrednost koja je pronadjena i ostatak CSV stringa . Zbog ogranicene maksimalne duzine ulanog parametra @csv , limit za rekurziju nece biti premasen . Skripta takodje ukljucuje unit test za TVF radi validacije rezultata ."
Parametar @csv : CSV kao jedan string @delimiter : Karakter koji se koristi kao delimiter u csv Return table id : trenutni id value : pojedinacna vrednost
Vraca rezultat
NULL / empty vrednosti za testiranje validacije parametara
WHERE IC2 . Object_id = object_id ( ' Person . Address ' )
Zakomentarisati za sve tabele
AND I. Object_id = object_id ( ' Person . Address ' )
AND I. name = ' IX_Address_PostalCode '
"Porast velicine baze podataka u obliku liste Transact-SQL skripta za analizu porasta velicine baze podataka koristeci backup . Ova Transact-SQL skripta koristi backup za analizu porasta velicine baze podataka za dati period . Pored minimalne , maksimalne i prosecne velicine za odredjeni mesec , izracunat je i porast prosecne velicine u odnosu na prethodni mesec . Vrednosti su korisne za buduce planiranje resursa sistema za skladistenje i backup sistema . Transact-SQL skripta za analizu porasta velicine baze podataka koristeci backup ."
Ova Transact-SQL skripta koristi backup istoriju za analizu rasta velicine baze u proteklih 12 meseci i izlaze prosecno velicinu u toku svakog meseca u pivot tabeli . Vrednosti su korisne za buduce planiranje potrebnih resursa .
Radi sa MS SQL Server 2005 i novijim verzijama u svim edicijama . Zahteva access i select dozvole za msdb sistemsku bazu
Opis : Ova skripta analizira sve dostupne DATABASEPROPERTYEX vrednosti za sve baze koje su hostovane na nekoj SQL instanci
Pregled procesa na bazi
"Ova Transact-SQL skripta daje kratak pregled sledeceg : - broj procesa - broj jedinstvenih korisnika i hostova - podaci o izvrsavanju poslednjeg batch-a - podaci o koriscenju cpu , IO i memorije - otvorene transakcije"
Minimalno stanje za izvestavanje
Izvrsavanje CheckDB i dodavanje rezultata u privremenu tabelu .
Izbor detalja u izvestaju
Konfiguracione vrednosti za izvestaje .
WHEN ' SQL Server 2008 R2 ' THEN
+ CHAR ( 13 ) + ' 12.0.2381 ( SQL Server 2014 RTM QFE ) https://support.microsoft.com/en-us/kb/2977316 '
Rezultat skripte : Informacije o trenutno instaliranom Microsoft SQL Server information :
"Ako je slobodan prostor u procentima manji od @alertvalue , poslace poruku"
Prikazuje ocekivani izlaz
"Pomocu ove Transact-SQL skripte moguce je dobiti informacije o nedostajucim indeksima , poput informacija o poboljasanju performansi ukoliko bi oni postojali . Pomocu ove Transact-SQL skripte mozete testirati upit prema postojecim cached planovima da biste dobili sve SQL iskaze sa nedostajucim indeksima ."
Radi sa SQL Server 2005 i novijim verzijama u svim edicijama . Zahteva VIEW SERVER STATE dozvole .
Za konvertovanje datuma iz IST-Indian Standart Time u EGT-East Greenland Time
Za konvertovanje datuma iz IST-Indian Standart Time u PST-Pacific Standard time ( US i Kanada ) sa pomeranjem sata Prepostavlja da sat biva pomeren kasnije za 1 sat od ' 01-Apr ' do ' 31-Aug ' Godina se odredjuje na osnovu currentdate .
Parametri @InputString -- String iz kog se vrsi ekstrakcija vrednosti @Extracttype -- N = Ekstracija iskljucivo brojeva C = Ekstracija iskljucivo alfabeta NC = Ekstracija alfanumerickih karaktera @AdditionalChars -- Dodatni posebni karakteri za ekstrakciju pored navedenih gore
"SELECT @Extracttype , @OutputStr"
Primer ekstracije samo brojeva
"Primer ekstracije brojeva i specijalnih karaktera Ispod se vrsi ekstrakcija """" . """" iz stringa ."
"Primer ekstracije alfabetskih i specijalnih karaktera Ispod se vrsi ekstrakcija """" @ . """" iz stringa ."
Primer koriscenja sa tabelama
Primer ekstracije samo alfabetskih karaktera
Dohvata prvi red od kursora
While petlja dok kursor vraca nove redove
Prikazuje poruku sa imenom trenutne tabele
Ovo vrsi konkatenaciju svih poruka
Resetuje izlaznu tabelu i promenljivu
"Opis : Skripta pronalazi sve tabele u bazi ( samo one sa primarnim kljucem ) i generise . sql fajl za svaku tabelu koja sadrzi MERGE iskaz koristeci zapise koji su dostupni u tabeli . Nakon izvrsavanja generisanih skripti , tabela ce sadrzati samo zapise koji su bili prisutni pre ."
Promene ispod su na vasu odgovornost
"Inicijalizacija kursora za prolazak kroz sve tabele u bazi Tabele su dohvacene kroz hijerarhijski upit radi zadrzavanja reda unosenja podataka , obzirom na FK ogranicenja ( parent tabela ce biti generisana pre child tabele )"
Dohvata samo tabele sa primarnim kljucem
"Primer koriscenja : EXEC usp_Generate_Merge_For_Table ' tbl_forms ' , ' dbo '"
"Ako nista nije pronadjeno , odustani ( tabela nije podrzana )"
zapocinje sa prvom kolonom
"iteracija kroz sve kolone , da bi se dohvatili njihova imena i tipovi podataka koje sadrze"
Formatira vrednost kolone na osnovu tipa
"Opis : Ova skripta generise MERGE iskaz za tabelu koja se prosledi kao parametar , koristeci zapise koji su trenutno u tabeli . MERGE iskaz se vraca u upitu kao jedan red kolona . Ako nema redova u tabeli , jednostavni DELETE iskaz ce biti generisan ."
Dohvata sledecu kolonu po redu
Izvrsava komandu i dobija @Values parametar kao izlaz
Vazna napomena : Tabele bez primarnog kljuca nisu podrzane !
dozvoli / zabrani UPDATE redova
dozvoli / zabrani INSERT redova
dozvoli / zabrani debug mod
ukljuci timestamp kolone ili net
"Ukoliko se ne menja fajl u kome se cuvaju podaci , Set @MovePath = ''"
SELECT * FROM @PKTable
"WHEN STY . NAME IN ( ' Nchar ' , ' Nvarchar ' ) AND SC. max_length < > -1 THEN ' ( ' + CONVERT ( VARCHAR ( 4 ) , SC. max_length / 2 ) + ' ) '"
ELSE ''
Za nekoliko biznis aplikacija potrebne su najnovije kursne stope za nekoliko valuta . Evropska centralna banka ( ECB ) objavljuje na internetu na dnevnom nivou kursne stope za preko 33 valute u obliku XML fajlova i to besplatno .
Import kursnih stopa ECB
Ucitati XML fajl kao XML promenljivu .
Izbor stopa ; dodati samo vrednosti koje nedostaju .
"Sa ovom Transact-SQL skriptom , XML fajlovi Evropske centralne banke mogu se importovati u obliku tabele ; skript CREATE za tu tabelu je dodat kao atacment ."
Autor : Aasim Abdullah http://connectsql.blogspot.com
"IO operacije su usko grlo za SQL Server . Da bi se dobio najbolji uciak , dobra strategija za HW je neophodna . U procesu planiranja , mora se razmotriti dobro gde locirati koju bazu . Pomocu ove Transact-SQL skripte , moguce je analizirati IO statistiku sveukupno ili na nivou fajla . Zbog CTE , jenostavno je modifikovati postojeci upit ili kreirati sopstvene statisticke upite ."
Detalji za svaki fajl
Pregled po tipu fajla
"SELECT IOF . FileType , CONVERT ( numeric ( 5,2 ) , SUM ( 100.0 * IOF . num_of_reads / IOT . Reads )) AS [ Reads % ] , CONVERT ( numeric ( 5,2 ) , SUM ( 100.0 * IOF . num_of_bytes_read / IOT . BytesRead )) AS [ BytesRead % ] , CONVERT ( numeric ( 5,2 ) , SUM ( 100.0 * IOF . io_stall_read_ms / IOT . IoStallReadMs )) AS [ IoStallReadMs % ] , CONVERT ( numeric ( 5,2 ) , SUM ( 100.0 * IOF . num_of_writes / IOT . Writes )) AS [ Writes % ] , CONVERT ( numeric ( 5,2 ) , SUM ( 100.0 * IOF . num_of_bytes_written / IOT . BytesWritten )) AS [ BytesWritten % ] , CONVERT ( numeric ( 5,2 ) , SUM ( 100.0 * IOF . io_stall_write_ms / IOT . IoStallWritesMs )) AS [ IoStallWritesMs % ] , CONVERT ( numeric ( 5,2 ) , SUM ( 100.0 * IOF . io_stall / IOT . IoStall )) AS [ IoStall % ] , CONVERT ( numeric ( 5,2 ) , SUM ( 100.0 * IOF . size_on_disk_bytes / IOT . SizeOnDisk )) AS [ SizeOnDisk % ] FROM IOF CROSS APPLY IOT GROUP BY IOF . FileType ORDER BY IOF . FileType ;"
Pregled po drive-u
", ISFULLTEXTINSTALLED = CONVERT ( BIT , SERVERPROPERTY ( ' ISFULLTEXTINSTALLED ' ))"
", FILESTREAMEFFECTIVELEVEL = CONVERT ( TINYINT , SERVERPROPERTY ( ' FILESTREAMEFFECTIVELEVEL ' ))"
", PRODUCTVERSION = CONVERT ( NVARCHAR ( 128 ) , SERVERPROPERTY ( ' PRODUCTVERSION ' ))"
", SQLCHARSETNAME = CONVERT ( NVARCHAR ( 128 ) , SERVERPROPERTY ( ' SQLCHARSETNAME ' ))"
", SQLMEMORY = ( SELECT VALUE_IN_USE FROM SYS . CONFIGURATIONS WHERE NAME = ' MAX SERVER MEMORY ( MB ) ' )"
", EDITION = CONVERT ( NVARCHAR ( 128 ) , SERVERPROPERTY ( ' EDITION ' ))"
", ISCLUSTERED = CONVERT ( BIT , SERVERPROPERTY ( ' ISCLUSTERED ' ))"
"Heap tabela je tabela koja nema klasterizovani indeks . Obicno , koriscenje heap tabela nije najbolja praksa , ali u nekim scenarijima je prihvatljivo . U SQL Azure , heap tabele nisu dozvoljene , svaka tabela mora imati klasterizovani indeks ."
Izlistava sve heap tabele
Pomocu ove jednostavne Transact-SQL skripte se mogu pronaci sve heap tabele .
Radi sa SQL Server 2005 i novijim verzijama . Linkovi : - MSDN SQL Server Best Practices Article : http://msdn.microsoft.com/en-us/library/cc917672.aspx - MSDN Heap Structures http://msdn.microsoft.com/en-us/library/ms188270.aspx
Radi sa SQL Server 2005 i novijim verzijama u svim edicijama . Izlistava samo poglede za koje trenutni korisnik ima view metadata dozvole . Linkovi : sys . views : http://msdn.microsoft.com/en-us/library/ms190334.aspx
Izlistava sve indeksirane poglede
Ova Transact-SQL skripta izlistava sve indeksirane poglede sa detaljnim informacijama o indeksu i indeksiranim kolonama .
Izlistava sve otvorene kursore
Radi sa SQL Server 2005 i novijim verzijama . Zahteva VIEW SERVER STATE dozvolu na serveru . Linkovi : sys . dm_exec_cursors : http://technet.microsoft.com/en-us/library/ms190346.aspx
Ova Transact-SQL skripta izlistava sve role u trenutnoj bazi sa pripadajucim clanovima . Dodatno se izlistava i trenutni SQL login .
Izlistava role i clanove sa server loginom
ON DRM . role_principal_id = ROL . principal_id
ON DRM . member_principal_id = MEM . principal_id
ON MEM . [ sid ] = SP . [ sid ]
Radi sa SQL Server 2005 i novijim verzijama u svim edicijama . Linkovi : sys . database_role_members : http://msdn.microsoft.com/en-us/library/ms187328.aspx sys . database_principals : http://msdn.microsoft.com/en-us/library/ms187328.aspx
Izlistava sve objekte i njihove zavisnosti
Ova Transact-SQL skripta izlistava sve objekte stvarne baze i njihove direktne zavisnosti prema drugim objektima ( referencirani objekti ) . Za tabele / poglede se takodje izlistavaju referencirane kolone .
"Radi sa SQL Server 2005 i novijim verzijama u svim edicijama . Od verzije SQL Server 2008 R2 korisceni sistemski pogled """" sys . sql_dependencies """" je oznacen kao zastareo . Izlistava samo objekte za koje korisnik ima dozvole ."
Ritam rasta loga
"Velicine log fajlova bi trebalo da budu adekvatno odredjene da bi se izbegla cesta promena tih podesavanja jer ona izaziva nepotrebne IO operacije i fragmentaciju fajlova . Log fajlovi bi trebalo da budu dovoljno veliki da prihvate sve podatke izmedju 2 backup-a , a vrednost za koju se velicina fajla moze uvecati takodje treba biti adekvatno postavljena . Ova Transact-SQL skripta izlistva sve podatke vezane za log fajlove iz WMI performance counter statistike da bi pokazala koji su log fajlovi adekvatne velicine ."
Radi sa SQL Server 2005 i novijim verzijama u svim edicijama . Zahteva VIEW SERVER STATE dozvole na serveru . Linkovi : sys . dm_os_performance_counters : http://technet.microsoft.com/en-us/library/ms187743.aspx
Korisnici i role u bazi
Nedostajuci indeksi sa CREATE iskazom
U toku rada SQL Server prikuplja informacije o nedostajucim indeksima i to pruza kroz DMV sys . dm_db_missing_index_X .
"Pomocu ove Transact-SQL skripte mogu se izlistati nedostajuci indeksi sortirani po uticaju , a dodatno se pruza i CREATE iskaz za dodavanje predlozenog indeksa ."
Broj strana po objektu u baferu
Zahteva VIEW SERVER STATE dozvole . Radi sa Microsoft SQL Server 2005 i novijim verzijama u svim edicijama .
Izlistava sumu strana po korisnickom objektu u SQL Server buffer-u .
Na osnovu DMV sys . dm_os_buffer_descriptors ova skripta izlistava sumu broja strana po korisnickom objektu u baferu . Lista je sortirana na osnovu ukupnog broja strana u baferu . Ova vrednost je indikacija najcesce koriscenih korisnickih objekata i indeksa .
update ## abc
"broj indeksa u bazi , ukupno"
alter table ## bbc
alter table ## abc
Dohvata ukupan broj objekata ukljucujuci indekse i sheme za drugi server
Dohvata ukupan broj objekata ukljucujuci indekse i sheme
broj sistemskih objekata u odabranoj bazi
update ## bbc
set discription = ' User Table ' where discription iS null
Putanja do fajla verzije 1 RDL
"EXEC RDL_Compare ' C :\ Users \ Sathya \ Documents \ Visual Studio 2010 \ Projects \ Report1 \ Report1 \ Version1 . rdl ' , ' C :\ Users \ Sathya \ Documents \ Visual Studio 2010 \ Projects \ Report1 \ Report1 \ Version2 . rdl '"
"Upotreba : 1. Otvoriti Open SQL Server Management Studio ( SSMS ) i povezati se na SQL server . 2. Otvoriti “ New Query ” prozor , iskopirati ceo kod tamo i pokrenuti ga Kompatibilno i testirano sa SQL verzijama : 2005 , 2008 , 2008 R2 , 2012 , 2014 & 2016 Parametri @DB_Backup_File = ' * . bak ' <-- Ime backup fajla @Backup_File_id = <-- Ako odredjeni backup fajl sadrzi vise razlicitih backup-a , moze se preko id odrediti koji se obradjuje"
Tabela za skladistenje fragmentiranih objekata
Kursor za reorganizaciju
Autor : Ron Ratzlaff Naziv : CFP Custom Query - Systems Vulnerable to WannaCrypt Ransomware Malware Datum kreiranja : 5/15/2017
ovde dodati parametre za uskladistenu proceduru
Object : StoredProcedure [ dbo ] . [ Check_Memory ] Script Date : 09/14/2017 12:03:37
Object : StoredProcedure [ dbo ] . [ SQLServer_Wait_Statistics ] Script Date : 09/14/2017 12:03:37
SET NOCOUNT ON je dodat kako bi se sprecilo da se dodatni setovi podataka mesaju sa SELECT iskazima
Object : StoredProcedure [ dbo ] . [ SQLServer_Memory_Manager ] Script Date : 09/14/2017 12:03:37
Object : StoredProcedure [ dbo ] . [ Active_Process ] Script Date : 09/14/2017 12:03:37
Object : StoredProcedure [ dbo ] . [ SQLMonitorFULL_QueryMonitor ] Script Date : 09/14/2017 12:03:37
Monitor Active Process - nadgledanje memorije SQL servera
Object : StoredProcedure [ dbo ] . [ SQLMonitorFULL_Indicators ] Script Date : 09/14/2017 12:03:37
Object : View [ dbo ] . [ V_SQLMonitorQueryTOP50_EXPENSIVE ] Script Date : 09/14/2017 12:03:36
Object : Table [ dbo ] . [ DW Running Query ] Script Date : 09/14/2017 12:03:35
Object : View [ dbo ] . [ V_SQLMonitorQueryTOP100_POOR ] Script Date : 09/14/2017 12:03:36
Object : View [ dbo ] . [ V_SQLMonitorQueryCPUBenchMark ] Script Date : 09/14/2017 12:03:36
Object : View [ dbo ] . [ V_SQLMonitorIndicators ] Script Date : 09/14/2017 12:03:36
table_value je ciljna tabela privremena tabela tmp_table_value je izvorna tabela
COMMIT TRAN ;
Kreira privremene tabele potrebne za drzanje strukture baze podataka
Indeksi koji se ne slazu
Kljucevi koji se ne slazu
"DECLARE @SourceDB SYSNAME = ' DB1 ' , @TargetDb SYSNAME = ' DB2 '"
"Parametar @Tablenames Dostaviti ime jedne tabele ili vise imena razdvojenih zarezom . Ako je parametar prazan , provera se vrsi nad svim tabelama u bazi ."
"EX : ' % tbl % , Dim % ' -- Ovo pretrazuje tabele sa imenima koja sadrze """" tbl """" i one koje pocinju sa """" Dim """""
Parametar @SearchStr Proslediti string za pretragu . Koristiti ' % ' za podesavanje pretrage .
"EX : X % - daje podatke koji pocinju sa X % X - daje podatke koji zavrsavaju sa X % X % - daje podatke koji sadrze X % X % , Y % - daje podatke koji sadrze X ili pocinju sa Y"
Parametar @GenerateSQLOnly Proslediti 1 za generisanje SQL iskaza bez pretrage baze . Podrazumevano je 0 i bice pretrazena baza .
"Parametar @SchemaNames Proslediti ime jedne sheme ili vise shema cija su imena razdvojena zapetama . Ako je prazno , trazi sve tabele u bazi ."
"EX : ' % dbo % , Sales % ' -- Ovako se pretrazuju sheme sa imenima koja sadrze """" dbo """" ili pocinju sa """" Sales """""
"Za trazenje podataka u tabeli EXEC SP_SearchTables @Tablenames = ' T1 ' , @SearchStr = ' % TEST % ' Uzorak iznad vrsi pretragu u tabeli T1 sa stringom koji sadrzi TEST ."
"Za trazenje zapete u tabelama koristiti duplu zapetu """" ,, """" EXEC SP_SearchTables @Tablenames = ' % T1 % , Dim % ' , @SearchStr = ' % ,, % ' , @GenerateSQLOnly = 0 EXEC SP_SearchTables @Tablenames = ' % T1 % , Dim % ' , @SearchStr = ' % with ,, comma % ' , @GenerateSQLOnly = 0"
"Za pretragu pomocu SchemaName EXEC SP_SearchTables @Tablenames = ' % T1 % , Dim % ' , @SearchStr = ' % ,, % ' , @GenerateSQLOnly = 0 , @SchemaNames = ' % dbo % , Sales % '"
"Za pretragu koristeci Collation EXEC SP_SearchTables @Tablenames = ' % T1 % , Dim % ' , @SearchStr = ' % ,, % ' , @GenerateSQLOnly = 0 , @SchemaNames = ' % dbo % , Sales % ' , @SearchCollation = ' sql_latin1_general_cp1_cs_as '"
Dodaje broj obrisanih redova delete brojacu za APPLICATION_USAGE .
"Komituje otvorenu transakciju , a onda otpocinje novu ."
Copyright ( c ) Microsoft Corporation . All rights reserved . File : sp_SFTcleanupusage . sql
podesavanje sesije
Dodaje broj obrisanih redova delete brojacu za MESSAGE_LOG .
"Opis : Cisti poruke i podatke o koriscenju iz tabela MESSAGE_LOG i APPLICATION_USAGE . Parametar koji se koristi kao cutoff datum sluzi kako bi se odredilo gde ciscenje pocinje . Sve pre tog datuma biva ocisceno . Proces ce ocistiti samo zatvorene sesije . Nece cistiti otvorene transakcije , osim ako ne moze zasigurno da odredi da su te transakcije """" orphaned """" ."
Brise sve netransakcione poruke ( iz MESSAGE_LOG tabele ) koje su zabelezene pre cutoff datuma .
NAPOMENA : Samo transakcije vezane za sesije i licence treba da ostanu .
Brise netransakcione poruke iz MESSAGE_LOG tabele
transakcije sesije
transakcije licence
Brise sve transakcije iz MESSAGE_LOG i APPLICATION_USAGE tabela koje su kompletirane pre cutoff datuma .
NAPOMENA : Ovo su transakcije vezane za sesije i licence koje sada brisemo .
Brise podatak o pocetku zavrsene sesije iz MESSAGE_LOG tabele
Brise podatak o zavrsetku sesije iz MESSAGE_LOG tabele .
Brise podatak o zavrsenoj transakciji iz APPLICATION_USAGE tabele .
Izvrsava se samo ako korisnik ima odredjene dozvole
NAPOMENA : Ovo je neophodno jer BACKUP i DBCC komande moraju biti pokrenute van transakcije
Iteracija kroz zapise .
Umanjuje velicinu fajla koliko je moguce
Obezbediti da fajl nije read-only
NAPOMENA : Koristiti [ ] oko imena baze da bi se obezbedila kompatibilnost sa nestandardnim nazivima baza poput onih koje sadrze crticu ili broj
"Petlja je zavrsena , zatvara se kursor ."
"Ako se desila greska u petlji , razresiti je ."
Proglasava kursor za iteraciju kroz log fajlove koji imaju podesavanje autogrow
Inicijalizacija okruzenja .
"Proveriti da li je cutoff date NULL . Ukoliko jeste , preskocen je proces ciscenja , ali transakcioni log ostaje izbrisan ."
Autor : Microsoft -- Datum : 2010 - 02 - 06
"Odabira samo baze koje su online u slucaju da se backup odnosi na sve baze Ako je odabrana samo jedna baza , onda se onda pokupi"
Filtrira baze za koje nije trazen backup
Postavlja trenutni datum i vreme
Kreira ime fajla za backup
Izvrsava SQL komandu
Koriscenje SUBSTRING i CHARINDEX
Koriscenje PARSENAME
privremena tabela u kojoj se cuvaju rezultati
promene u DBCC loginfo izlazu od SQL2012 znace da moramo odrediti verziju
pre SQL2012
privremena tabela za iteriranje kroz vise baza
ispisuje celokupnu listu
Ovde se unosi nalogi iz domena
Kreiranje logina
Kreiranje korisnika za login u svakoj bazi podataka
EXECUTE sp_executesql @command1 ;
Moze se promeniti ime baze podataka
Autor : Abdullah ALTINTA Datum : 11/21/2016
"U svakom sistemu tempdb baza je najcesce koriscena . Pored internih funkcija sistema kao sto su verzionisanje , takodje privremene tabele koje korisnik kreira povecavaju velicinu tempdb i kolicinu IO operacija . Ova Transact-SQL skripta izlistava stvarno postojece privremene tabele i njihovu velicinu ."
Radi sa SQL Server 205 i novijim verzijama u svim edicijama .
Privremene tabele i njihova velicina
sekcija 1 :
"Postojanje svakog od indeksa ne nosi samo benificije , vec i troskove . Kada indeks nije u upotrebi , predstavlja nepotrebno trosenje resursa . Ova Transact-SQL skripta izlistava sve indekse koji nisu bili korisceni od poslednjeg pokretanja servera , samo tabele i pogledi se razmatraju . U ovu listu nisu ukljuceni neodobreni indeksi , heap , primarni kljucevi i unique indeksi , jer su oni deo biznis logike i neophodni su za FK ogranicenja ."
Neiskorisceni indeksi .
U obzir uzima korisnicki definisane tabele i poglede
Ignorise heap
Neodobreni indeksi se svakako ne koriste
"Unique indeksi se ne razmatraju , deo biznis logike su"
proverava da li tempdb fajlovi imaju isti tempo rasta
proverava da li je tempdb trace flag postavljen i neophodan na osnovu SQL verzije
Rad sa tipovima podataka :: DEMO 1
UNIQUEIDENTIFIER tip podataka
DECLARE @a UNIQUEIDENTIFIER SET @a = NEWID ( ) PRINT @a DECLARE @b UNIQUEIDENTIFIER SET @b = ' ABCDE ' PRINT @b DECLARE @c UNIQUEIDENTIFIER SET @c = ' C50F5FB8-8D4D-4581-BEE4-46C5B24FB5C0 ' PRINT @c
DECLARE @i SMALLINT SET @i = 40 PRINT @i DECLARE @j SMALLINT SET @j = -40 PRINT @j DECLARE @k SMALLINT SET @k = 40 PRINT @k
DECLARE @i INT SET @i = 40 PRINT @i DECLARE @j INT SET @j = -40 PRINT @j DECLARE @k INT SET @k = 40 PRINT @k
DECLARE @i TINYINT SET @i = 150 PRINT @i DECLARE @j TINYINT SET @j = 260 PRINT @j DECLARE @k TINYINT SET @k = -150 PRINT @k
DECLARE @DateEx1 DATETIME SET @DateEx1 = GETDATE ( ) PRINT @DateEx1 DECLARE @DateEx2 DATETIME SET @DateEx2 = ' 12/15/1800 ' PRINT @DateEx2 DECLARE @DateEx3 DATETIME SET @DateEx3 = ' 12/15/1400 ' PRINT @DateEx3
"DECLARE @a DECIMAL ( 3,3 ) SET @a = 3.10 PRINT @a DECLARE @b DECIMAL ( 4,3 ) SET @b = 3.10 PRINT @b DECLARE @c DECIMAL ( 3,3 ) SET @c = 0.310 PRINT @c DECLARE @d DECIMAL ( 6,3 ) SET @d = 0.36 PRINT @d DECLARE @e DECIMAL ( 6,3 ) SET @e = 20.36 PRINT @e DECLARE @f DECIMAL ( 6,3 ) SET @f = 9.36 PRINT @f DECLARE @g DECIMAL ( 6,3 ) SET @g = 19.3 PRINT @g DECLARE @h DECIMAL ( 5,3 ) SET @h = 33.16 PRINT @h DECLARE @i DECIMAL ( 5,0 ) SET @i = 133.1 PRINT @i"
"USE tempdb ; GO CREATE TABLE dbo . TestCharacter2 ( CIdata varchar ( 10 ) COLLATE Latin1_General_CI_AS , CSdata varchar ( 10 ) COLLATE Latin1_General_CS_AS ) ; GO INSERT INTO dbo . TestCharacter2 VALUES ( ' Test Data ' , ' Test Data ' ) ; GO SELECT * FROM dbo . TestCharacter2 GO SELECT * FROM dbo . TestCharacter2 WHERE CIdata = ' test data ' ; GO SELECT * FROM dbo . TestCharacter2 WHERE CSdata = ' test data ' COLLATE Latin1_General_CI_AS ; GO SELECT * FROM dbo . TestCharacter2 WHERE CIdata = CSdata ; GO SELECT * FROM dbo . TestCharacter2 WHERE CIData = CSData COLLATE Latin1_General_CI_AS ;"
VARCHAR tip podataka
"DECLARE @name1 VARCHAR ( 4 ) SET @name1 = ' AB ' SELECT @name1 , DATALENGTH ( @name1 ) DECLARE @name2 VARCHAR ( 4 ) SET @name2 = ' ABCD ' SELECT @name2 , DATALENGTH ( @name2 ) DECLARE @name3 VARCHAR ( 4 ) SET @name3 = ' ABCDE ' SELECT @name3 , DATALENGTH ( @name3 ) -- VARCHAR ( max ) DECLARE @name4 VARCHAR ( max ) SET @name4 = ' AB ' SELECT @name4 , DATALENGTH ( @name4 )"
CHAR tip podataka
UNICODE vs . NON-UNICODE karakteri
KONVERZIJA podataka
"SELECT 1 + ' 2 ' AS result ; GO SELECT 1 + ' abc ' AS result ; GO SELECT CAST ( 1 AS VARCHAR ( 10 )) + ' abc ' AS result ; GO DECLARE @int1 int = 1 ; DECLARE @int2 int = 2 ; DECLARE @char char ( 1 ) = 3 ; DECLARE @numeric numeric ( 18,2 ) = 1.0 ; SELECT @int1 / @int2 ; SELECT @numeric / @int2 ; SELECT @int2 * @char ; SELECT @char / @int2 ; GO"
"USE tempdb ; GO CREATE TABLE dbo . Orders ( OrderID int NOT NULL IDENTITY ( 1,1 ) , OrderDate date NOT NULL , SalespersonID int NULL , Concurrency rowversion NOT NULL ) ; GO INSERT dbo . Orders ( OrderDate ) VALUES ( SYSDATETIME ()) , ( SYSDATETIME ()) ; GO SELECT * FROM dbo . Orders ; GO UPDATE dbo . Orders SET Concurrency = Concurrency + 1 WHERE OrderID = 1 ; GO INSERT dbo . Orders ( OrderDate , Concurrency ) VALUES ( SYSDATETIME ( ) , 0 x07E4 ) ; GO SELECT * FROM dbo . Orders WHERE OrderID = 1 ; GO UPDATE dbo . Orders SET SalespersonID = 35 WHERE OrderID = 1 ; GO SELECT * FROM dbo . Orders WHERE OrderID = 1 ; GO"
Kreiranje baza :: DEMO 1
"USE [ master ] GO CREATE DATABASE Test2 ON ( NAME = N'Test2 ' , FILENAME = N'C :\ Program Files \ Microsoft SQL Server \ MSSQL14 . SQL2017 \ MSSQL \ DATA \ Test2 . mdf ' , SIZE = 4096 KB , MAXSIZE = UNLIMITED , FILEGROWTH = 1024 KB ) LOG ON ( NAME = N'Test2_log ' , FILENAME = N'C :\ Program Files \ Microsoft SQL Server \ MSSQL14 . SQL2017 \ MSSQL \ DATA \ Test2_log . ldf ' , SIZE = 1024 KB , MAXSIZE = 2048 GB , FILEGROWTH = 10 % ) ; GO"
pregled svih postojećih baza na SQL serveru
"SELECT * FROM sys . databases GO SELECT database_id , name , state_desc FROM sys . databases ; GO"
pregled podataka o Test2 bazi
2. nacin - pomoću SQL koda
kreiranje šeme sa uključenim objektom
brisanje tabele
brisanje šeme
kreiranje šeme
Kreiranje tabela :: DEMO 3
kreiranje schema PetStore - Vlasnik šeme je DBO
Dodavanje kolone u Owner tabelu
3. nacin - pomoću dijagrama
Privremene tabele :: DEMO 4
Pretrazivanje
Izračunate kolone :: DEMO 5
Kreiranje tabele PET sa PERSISTED izračunatom kolonom
SQL upitni jezik :: DEMO 1
Korak 6 : Pretrazivanje tabele uz upotrebu WHERE klauzule
Korak 7 : Pretrazivanje tabele uz upotrebu funkcije u WHERE klauzuli
Korak 9 : Brisanje kreirane tabele kao ilustracija DDL komande
Kreiranje tabele Sales . Customers
Kreiranje tabele Sales . Shippers
Kreiranje tabele Sales . OrderDetails
"Skript kreira bazu TSQL Originalno , bazu je kreirao Itzik Ben-Gan"
Kreiranje tabele Stats . Tests
Popunjavanje tabela podacima
Ubacivanje podataka u Sales . OrderDetails
Kreiranje sema
Ubacivanje podataka u Production . Suppliers
Ubacivanje podataka u Production . Products
Kreiranje tabele HR . Employees
Ubacivanje podataka u Sales . Customers
Kreiranje i popunjavanje tabele dbo . Nums
Ubacivanje podataka u Stats . Tests
Ubacivanje podataka u Stats . Scores
Ubacivanje podataka u Sales . Orders
SQL upitni jezik :: Zadatak 2
Izvrsiti skript klikom na Execute ( ili pomocu F5 dugmeta ) . Obratite paznju na dobijeni rezultat .
USE TSQL ; GO
Izvrsiti skript klikom na Execute ( ili pomocu F5 dugmeta ) Zasto je dobijen prazan rezultujuci skup podataka ?
"SELECT firstname , lastname , city , country FROM HR . Employees WHERE country = ' USA ' ORDER BY lastname ;"
"Selektujte i izvrsite sledeci upit , koji vraca sve kolone i sve redove tabele Sales . Shippers"
"Selektujte i izvrsite napisani upit ORDER BY sortira redove po sifri zaposlenog , i u okviru sifre , po godini"
"Selektujte i izvrsite sledeci upit , koji vraca duple redove iz Sales . Orders tabele Upit vraca 830 redova"
Korak 3 : Izbacivanje duplih redova
"Selektujte i izvrsite sledeci upit , koji vraca jedinstvene redove iz Sales . Orders tabele Upit vraca 89 redova"
Korak 4 : Select Disctinct
Korak 2 : Alijasi za kolone
"Selektujte sledeci upit , koji pokazuje koriscenje alijasa za tabele"
Korak 2 : Jednostavni CASE izraz
Selektujte i izvrsite sleci upit za prikaz koriscenja jednostavnog CASE izraza
"Selektujte i izvrsite sleci upit za prikaz koriscenja jednostavnog CASE izraza , koji za odredjeni ID dodeljuje ime Ipak , bolje resenje bi bilo da se koristi JOIN !"
"Selektujte i izvrsite sledeci upit , koji vraca samo kolone productid , productname , categoryid , unitprice columns iz Production . Products tabele"
"Selektujte i izvrsite sledeci upit , koji manipulise kolonama iz Production . Products tabele Obratite paznju na poslednju kolonu koja se vraca ( nema ime )"
Korak 1 : Promena aktivne baze na TSQL
Korak 2 : Pretrazivanje tabele
Selektujte i izvrsite napisani upit Upit vraca 830 redova
Selektujte i izvrsite napisani upit Upit vraca 31 red
Korak 5 : Pretrazivanje tabele pomocu neispravno napisanog SELECT upita
Selektujte i izvrsite napisani upit * u SELECT listi zamenjena je kolonama koje se nalaze ili u GROUP BY izrazu ili su agregatne funkcije Upit vraca 16 redova
"Selektujte i izvrsite napisani upit HAVING klauzula filtira grupe Upit vraca 9 redova , bez unapred poznatog redosleda"
SELECT naredba :: ZADACI
"Napisati SELECT naredbu , koja vraca kolone contactname , address , postalcode , city , country iz Sales . Customers tabele . Koliko redova se vraca kao rezultat ?"
"Napisati SELECT naredbu , koja vraca kolonu productname iz Production . Products tabele . Koristiti """" P """" kao alijas za tabelu , i """" Product Name """" kao alijas za kolonu . Izvrsiti upit i pogledati rezultat ."
Korak 2 : LEFT OUTER JOIN
Selektujte i izvrsite naredni upit Upit vraca 832 reda
Selektujte i izvrsite naredni upit
"Selektujte i izvrsite naredni upit , koji vraca fakture bez podataka o kupcima"
Korak 2 : SELF JOIN sa 2 tabele
Selektujte i izvrsite naredni upit za prikaz zaposlenih sa siframa i imenima njihovih menadzera
"Selektujte i izvrsite naredni upit za prikaz SVIH zaposlenih , kao i sifre i imena njihovih menadzera , ukoliko ih imaju"
Selektujte i izvrsite naredni upit za generisanje svih kombinacija imena i prezimena iz tabele HR . Employees
"Selektujte i izvrsite naredni upit , koji ilustruje ANSI SQL-89 sintaksu za JOIN sa 2 tabele Upit ne sadrzi WHERE klauzulu , zbog cega se kreiraju sve moguce kombinacije redova za 2 tabele ( Kartezijanski proizvod ) Upit vraca 75530 redova"
"Selektujte i izvrsite naredni upit , koji ilustruje ANSI SQL-92 sintaksu za JOIN sa 2 tabele Greska je namerno napravljena !"
Pretrazivanje vise tabela - INNER JOIN :: DEMO 2
"Selektujte i izvrsite naredni upit , koji demonstrira INNER JOIN sa 2 tabele Upit vraca 77 redova"
"Selektujte i izvrsite naredni upit , koji demonstrira kompozitni INNER JOIN sa 2 tabele Upit vraca 27 redova ( bez koriscenja DISTINCT )"
Korak 5 : JOIN sa vise tabela
"Selektujte i izvrsite naredni upit , koji demonstrira INNER JOIN sa 2 tabele Treca tabela je izostavljena iz upita Upit vraca 830 redova"
JOIN Sales . OrderDetails od
ON o. orderid = od . orderid ;
Korak 6 : JOIN sa 3 tabele
Korak 2 : JOIN sa 2 tabele
Pretrazivanje vise tabela - OUTER JOIN :: DEMO 3
Izvrsite napisani upit i obratite paznju na rezultat . Zasto se javila greska ?
"Napisati upit ispravno , kako bi se izvrsio bez poruke o greski ."
"Kopirajte ispravno napisani upit , i dodajte alijas """" C """" za Sales . Custumers tabelu i """" O """" za Sales . Orders tabelu . Izvrsite upit . Promenite prefiks kod kolona u SELECT listi , tako da sadrzi puno ime tabele i izvrsite upit . Dobijena je greska . Zasto ? Napisite ispravno upit ."
"Kopirajte ispravno napisanu SELECT naredbu , i dodajte kolone iz Sales . OrderDetails tabele : productid , qty , unitprice . Izvrsite upit i pogledajte rezultat ."
"Napisite SELECT upit , koji ce vratiti kolone empid , lastname , firstname , title , mgrid iz HR . Employees tabele . Izvrsite napisani upit ."
"Napisite SELECT upit , koji ce vratiti custid i contactname kolone iz Sales . Customers tabele i orderid kolonu iz Sales . Orders tabele . Upit treba da vrati SVE redove iz Sales . Customers tabele . Izvrsite napisani upit . Obratite paznju na kolonu orderid . Da li ova kolona sadrzi NULL ? Zasto ?"
"Napisati SELECT naredbu koja koristi INNER JOIN , i koja treba da vrati productname kolonu iz Production . Products tabele ( koristiti alijas “ p ” ) i categoryname kolonu iz Production . Categories tabele ( koristiti alijas “ c ” ) Izvrsiti napisanu naredbu Koju kolonu ste koristili kao predikat u ON klauzuli ? Zasto ?"
Filtiranje pomoću TOP i OFFSET-FETCH :: DEMO 3
Upit vraća 5 najnovijih faktura
Obratite pažnju na korišćenje ORDER BY
Korak 6 : Korišćenje OFFSET / FETCH za filtiranje rezultata
Upit vraća samo 50 redova - alternativa za SELECT TOP ( 50 )
"Upit preskače prvih 50 redova , i vraća narednih 50 redova ( 51 - 100 )"
Korak 3 : Korišćenje ORDER BY za sortiranje rezultujućeg skupa podataka Sortiranje po alijasu
"Obratite pažnju na kolonu region , koja nema uvek unešenu vrednost NULL-ovi su sortirani zajedno i na početku"
"Korak 3 : Upravljanje NULL-ovima Upit isključuje regione , koji nemaju vrednost ili imaju vrednost ' SP '"
Korak 4 : Upravljanje NULL-ovima Upit ukjučuje samo regione koji imaju vrednost ' SP '
Korak 5 : Upravljanje NULL-ovima
Testiranje jednakosti sa NULL neće vratiti tačan rezultat
Upit isključivo prikazuje regione koji imaju vrednosti
Korak 4 : Korišćenje ORDER BY za sortiranje rezultujućeg skupa podataka Sortiranje po imenu kolone u opadajućem redosledu
Korak 4 : Korišćenje ORDER BY za sortiranje rezultujućeg skupa podataka Sortiranje po različitom redosledu ( opadajućem i rastućem ) za više kolona
Korak 3 : Korišćenje WHERE za filtiranje rezultata WHERE klauzula ne može da koristi alijas iz SELECT liste
"Upit se neće izvršiti , jer se javlja greška . Zašto ?"
Korak 5 : Korišćenje WHERE za filtiranje rezultata Filtiranje po datumu
Korak 6 : Korišćenje WHERE za filtiranje rezultata Korišćenje logičkog operatora
Korak 8 : Korišćenje WHERE za filtiranje rezultata Korišćenje NOT sa IN operatorom
Korak 9 : Korišćenje WHERE za filtiranje rezultata - Korišćenje logičkih operatora za filtriranje po opsegu datuma
"Napisati SELECT naredbu , koja će vratiti kolone custid i contactname iz tabele Sales . Customers , i kolone orderid i orderdate iz tabele Sales . Orders . Rezultujući skup podataka treba da sadrži samo fakture kreirane posle 1. aprila 2008. godine . Sortirajte rezultate u opadajućem redosledu po orderdate koloni i rastućem redosledu po custid koloni ."
"Napisati SELECT naredbu , koja će vratiti kolone orderid i orderdate iz tabele Sales . Orders . Upit treba da vrati poslednjih 20 faktura , na osnovu njihovog datuma kreiranja ."
"Napisati SELECT naredbu , koja će vratiti isti rezultat kao prethodno napisan upit , ali korišćenjem OFFSET-FETCH klauzule ."
"Napisati SELECT naredbu , koja će vratiti kolone custid , companyname , contactname , address , city , country , phone iz tabele Sales . Customers . Rezultujući skup podataka treba da sadrži samo kupce iz Brazila ."
Korak 2 : Provera podataka za zaposlenog 7
Korak 3 : Promena 1 podatka za zaposlenog 7
Korak 3 : Ubacivanje 1 reda u HR . Employees tabelu
Korak 8 : Provera podataka za zaposlenog 13
Korak 10 : Truncate tabele dbo . NorthwindCustomers
Korak 4 : Provera podataka
Korak 5 : Ubacivanje više redova u HR . Employees tabelu pomoću jedne INSERT naredbe
Korak 7 : Kreiranje i popunjavanje tabele dbo . NorthwindCustomers
Korak 8 : Ubacivanje svih redova iz tabele dbo . NorthwindCustomers u tabelu Sales . Customers
Korak 2 : Pregled zaposlenih
Modifikovanje podataka :: ZADACI
"Napisati INSERT naredbu , koja će dodati novi red u tabelu Production . Categories . Koristiti sledece vrednosti : categoryname : Mleko i jaja description : Kategorija obuhvata mleko , proizvode od mleka i jaja . Posle unosa , prikazati samo podatke o novoj kategoriji ."
"Napisati INSERT naredbu , koja će dodati 3 nova red u tabelu Production . Products , koja propadaju prethodno unesenoj kategoriji . Koristiti sledece vrednosti za 1 novi red : productname : AB jogurt 1 kg supplier : Supplier SWRXU unitprice : 114.99 discontinued : 0 Koristiti sledece vrednosti za 3 novi red : productname : ABC krem sir sa povrćem 100 g supplier : Supplier VHQZD unitprice : 64.99 discontinued : 0 Koristiti sledece vrednosti za 3 novi red : productname : Bello kisela pavlaka organic 15 % 150 g supplier : Supplier STUAZ unitprice : 49.99 discontinued : 0 Posle unosa , prikazati samo za nove proizvode , sledece vrednosti : ' Sifra proizvoda ' , ' Naziv proizvoda ' , ' Naziv kategorije ' , ' Naziv dobavljaca ' , ' Cena ' , ' Aktivan proizvod ' . Kolona [ discontinued ] treba da ima vrednost ' Da ' , ako je vrednost za [ discontinued ] = 0 , ili ' Ne ' , ako je vrednost za [ discontinued ] = 1"
"Napisati INSERT naredbu , koja će dodati novi red u tabelu HR . Employees . Koristiti sledece vrednosti : Title : Sales Representative Titleofcourtesy : Mr FirstName : Laurence Lastname : Grider Hiredate : 04/04/2013 Birthdate : 10/25/1975 Address : 1234 1 st Ave . S. E. City : Seattle Country : USA Phone : ( 206 ) 5 - 0105"
Object : Table [ dbo ] . [ NorthwindCustomers ] Script Date : 10/25/2016 1:33:50 PM
Agregatne funkcije :: DEMO 1
Obratite paznju na MAX ( qty )
Filtriranje grupa pomoću HAVING :: DEMO 3
Korak 2 : Koriscenje HAVING klauzule
"Zbog logickog redosleda izvrsavanja SELECT naredbe , javlja se greska Alijas count_orders ne moze da se koristi u HAVING"
Upit prikazuje razliku izmedju filtriranja u WHERE i HAVING Filtriranje pomocu WHERE
"Izvrsiti naredni upit , koji prikazuje upotrebu agregatnih funkcija sa karakter tipovima podataka"
"Upit koristi HAVING za filtriranje kupaca , koji su kupili nesto vise od 1 broj redova = 88"
Upit prikazuje proizvode i broj njihovog pojavljivanja u fakturama broj redova = 77
Obratite paznju na kraj liste
"Upit vraca samo proizvode , koji su kupovani najmanje 10 puta -- broj redova = 71"
"Izvrsiti naredni upit , koji prikazuje upotrebu DISTINCT sa agregatnim funkcijama"
"Izvrsiti naredni upit , koji prikazuje uticaj NULL na agregatne funkcije . Prvo , provera postojanja NULL"
"Drugo , agregatne funkcije ignorisu NULL , izuzev COUNT (*)"
Korak 3 : Ilustracija ponasanja NULL sa agregatnim funkcijama
Popunjavanje tabele
Korak 2 : Upotreba ugradjenih agregatnih funkcija
Pregled sadrzaja nove tabele
obratite paznju na NULL
Izvrsite naredni upit i uporedite ponasanje funkcije AVG sa aritmetickom sredinom ( SUM / COUNT )
Kreiranje tabele t2 Primer ilustruje zamenu NULL pre agregacije
"Izvrsiti naredni upit , koji , pored standardnih kolona , koristi i agregatne funkcije u SELECT listi . Prilikom izvrsavanja upita , javlja se greska . Obratite paznju na poruku ."
Grupisanje i agregacija :: Zadatak 1
Dopunite napisanu SELECT naredbu sledećim kolonama za svaku grupu kategorija : ukupni iznos prodaje ( alijas totalsalesamount ) broj faktura ( alijas nooforders ) prosečan iznos po fakturi ( alijas avgsalesamountperorder )
"Napisati SELECT naredbu , koja će prikazati 10 najboljih kupaca , koji su potrošili više od $ 10. Prikazati kolonu custid iz tabele Sales . Orders i izračunatu kolonu sa alijasom totalsalesamount , koja sadrži ukupan iznos prodaje ."
"Iskopirajte prethodno napravljeni SELECT i modifikujte ga da u SELECT listu uključi city kolonu iz Sales . Customers tabele . Izvršite upit . Zašto se javlja greška ? Ispravite upit , tako da se može izvršiti bez greške ."
"Iskopirajte prethodno napisanu SELECT naredbu i u nju dodajte filter za prikaz grupa , koje su ostvarile prodaju veću od $ 10. Filtrirajte sve redove , tako da sadrže samo podatke za zaposlenog sa šifrom 3."
"Napišite SELECT naredbu , koja treba da prikaže samo kupce koji su napravili više od 25 faktura . SELECT treba da sadrži informacije o datumu poslednje fakture ( alijas lastorderdate ) i ukupan iznos prodaje ( alijas totalsalesamount ) ."
Napisati SELECT koji će kreirati grupe na osnovu categoryid i categoryname kolona iz Production . Categories tabele . Filtirajte rezultate tako da uključe samo kategorije koje su naručivane 2008. godine .
"Napisati SELECT naredbu , koja će prikazati orderid i orderdate kolone iz Sales . Orders tabele i ukupnu prodaju po orderid . Ukupna prodaja se dobija množenjem kolona qty i unizprice iz Sales . OrderDetails tabele . Koristiti alijas salesmount za izračunatu kolonu . Sortirajte rezultate u opadajućem redosledu po ukupnoj prodaji ."
"Napisati SELECT naredbu , koja će prikazati ukupan iznos prodaje za svaki mesec . SELECT treba da uključi izračunatu kolonu yearmonthno u obliku YMM , a koja se dobija na osnovu orderdate kolone iz the Sales . Orders tabele . SELECT treba da uključi i ukupan iznos prodaje po godinama i mesecima u okviru godine . Sortirati rezultate po yearmonthno izračunatoj koloni ."
"Napisati SELECT naredbu , koja će prikazati za sve kupce sledeće podatke : custid i contactname kolone ukupni iznos kupovina po kupcu , alijas totalsalesamount maksimalni iznos po stavki fakture , alijas maxsalesamountperorderline ukupni broj stavki , alijas numberofrows ukupni broj faktura , alijas numberoforderlines Sortirati rezultate po totalsalesamount ."
Napisana SELECT naredba prikazuje ukupan broj faktura ( alijas nooforders ) i ukupan broj kupaca ( alijas noofcustomers ) po godinama ( alijas orderyear ) .
Izvršite upit . Zašto je broj kupaca isto kao i broj faktura ?
Samostalni podupiti :: DEMO 1
Podupiti sa EXISTS :: DEMO 3
"Korak 2 : Upotreba EXISTS Upit vraća podatke o kupcima , koji su obavili bar jednu kupovinu"
"Korak 3 : Upotreba NOT EXISTS Upit vraća podatke o kupcima , koji nisu obavili ni jednu kupovinu"
Korak 4 : Poređenje COUNT (*) > 0 sa EXISTS : Upotreba COUNT (*) > 0
"Upit koristi podupit da bi vratio detalje o fakturi , koja je poslednja kreirana"
Upotreba EXISTS
Izvedene tabele :: DEMO 4
Korak 4 : Korišćenje lokalnih varijabli
Korak 2 : CTE primer
Korak 3 : Više-vrednosni podupiti
"Upit vraća sve fakture , koje su kreirane za kupce iz Meksika Obratite pažnju na IN operator"
Korak 2 : Korelativni podupiti Upit prikazuje podatke o poslednjoj kreiranoj fakturi za svakog kupca
Korak 2 : Skalarni poduputi : SELECT naredba vraća fakturu sa najvećim brojem ( poslednju kreiranu )
"Upit vraća podatke o kupcima i najvećoj količini proizvoda , koji su kupili u nekom mesecu"
Podupiti :: Zadatak 1
"Napisati SELECT naredbu , koja će vratiti custid i contactname kolone iz Sales . Customers tabele . Rezultat treba da uključi samo kupce , koji su nešto kupili posle 1. aprila 2008. godine i ako je vrednost unitprice kolone veća od 100."
"Napisati SELECT naredbu , koja vraća productid i productname kolone za proizvode čija je cena veća od 100 , a na osnovu izvedene tabele . Izvedena tabela treba da iz tabele Production . Products uključi sledeće kolone : productid , productname , supplierid , unitprice , discontinued , kao i kolonu pricetype , koja se dobija na sledeći način : ukoliko je cena veća od 100 , tada kolona treba da sadrži vrednost high , u suprotnom , kolona treba da sadži vrednost normal . Izvedena tabela treba da uključi samo proizvode , koji pripadaju kategoriji 1."
"Napisati SELECT naredbu , koja je vratiti orderid , orderdate , empid , custid kolone iz Sales . Orders tabele . Filtrirajte podatke , tako da budu uključene samo fakture , kod kojih je datum jednak datumu poslednje kreirane fakture . POMOĆ : Koristite prethodno napisan upit kao podupit ."
"Napisati SELECT naredbu , koja će vtatiti custid kolonu i 2 izračunate kolone : totalsalesamount , koja vraća ukupan iznos prodaje po kupcu avgsalesamount , koja vraća prosečnu vrednost kupovine po kupcu Da bi se ispravno izračunala prosečna vrednost kupovine po kupcu , potrebno je prvo da se izračuna ukupna prodaja po kupcu i fakturi . Definišite izvedenu tabelu , koja će spojiti Sales . Orders i Sales . OrderDetails tabele"
CTE :: Zadatak 5
"Napisati SELECT naredbu , koja vraća iste rezultate kao task 1 u zadatku 4 , samo što treba da koristi CTE ."
"Napisani upit prikazuje fakture kupaca , čiji kontakt počinje slovom I. Izvršiti upit i pogledati rezultate . Modifikovati upit tako da prikazuje fakture kupaca , čiji kontakt počinje slovom B. Izvršiti upit . Zašto se desila greška ? Napravite potrebne promene , kako bi se upit izvršio bez poruke o greški ."
"Upit 2 Napisati upit , koji će vratitit kolone custid i contactname iz Sales . Customers tabele . Rezultat upita treba da uključi samo kupce , koji nisu ništa kupili ( koristiti podupit )"
"Napisati SELECT naredbu , koja će vratiti datum poslednje kreirane fakture ."
"Napisani upit ubacuje novi red u the Sales . Orders tabelu . Novi red nema vrednost za custid kolonu . Izvršiti upit . Iskopirajte prethodno napisati upit ( upit 2 ) i pogledajte rezultate . Koliko redova se pojavljuje u rezultatu . Zašto ? Promenite iskopirani upit 2 , tako da prikazuje isti broj redova , kao i upit 2 ( POMOĆ : Isključite redove koji imaju NULL u custid koloni ) ."
"Napisati SELECT naredbu , koja će vratiti custid i contactname kolone iz Sales . Customers tabele . Dodati izračunatu kolonu lastorderdate , koja treba da sadrži poslednji datum fakture iz Sales . Orders tabele za svakog kupca . ( POMOĆ : Koristiti korelisani podupit . )"
100 redova
Korak 3 : Korišćenje UNION UNION vraća sve redove iz obe tabele ( isključuje duplikate )
"3 zajednička , različita reda"
Promenjen redosled tabela ( vraćaju se jedino redovi iz Sales . Customers )
Korak 3 : Korišćenje OUTER APPLY Korišćenje OUTER APPLY za uključivanje i kupaca bez ordera
Korak 2 : Korišćenje UNION ALL UNION ALL vraća sve redove iz obe tabele ( uključuje duplikate )
SET operatori :: Zadatak 1
"Iskopirajte prethodno napisan upit , i zamenite CROSS APPLY operator sa OUTER APPLY operatorom . Koliko ima rezultujućih redova ?"
"Iskopirajte prethodno napisan upit , i modifikujte ga tako da prikazuje samo kupce bez proizvoda . POMOĆ : u WHERE klauzuli , proverite da li je productid NULL ."
"Napisati SELECT naredbu , koja će vratiti productid i productname kolone iz Production . Products tabele . Rezultati treba da uključe samo proizvode , čija vrednost prodaje je veća od 50.0 Vrednost prodaje se dobija tako što se saberu svi proizvodi ( qty * unitprice ) iz tabele Sales . OrderDetails"
Brisanje kreirane funkcije .
"Napisati SELECT naredbu koja će kombinovati rezultate iz prethodna 2 upita . Koristiti i UNION i UNION ALL operatore . Koliki je ukupan broj redova kod korišćenja UNION , i koliko se vraća redova kod korišćenja UNION ALL operatora ?"
"Iskopirajte naredbu koja sadrži EXCEPT operator . Dodati INTERSECT operator . Posle ovog operatora , dodajte naredbu iz prethodnog koraka ."
"Napisati SELECT naredbu , koja će vratiti productid i productname kolone iz Production . Products tabele . Za svaki proizvod . prikazati 2 poslednja kreirana reda ( na osnovu orderid broja ) iz Sales . OrderDetails tabele Koristiti CROSS APPLY operator . Sortirati redove po koloni productid ."
Integritet podataka :: DEMO 1
Korak 4 : Unos nepostojećeg kupca u CustomerOrder
"Korak 5 : Brisanje kupca , koji je obavio kupovinu"
Naziv ograničenja treba da se kopira !
Korak 2 : Kreiranje dbo . Opportunity tabele
Korak 3 : Dodavanje 2 reda u dbo . Opportunity tabelu
Korak 5 : Proba da li može da se unese određena vrednost za OpportunityID Javlja se greška !
Korak 8 : Kreiranje 3 tabele sa IDENTITY kolonama
Korak 9 : Dodavanje podataka
Korak 10 : Prikaz podataka preko jednog rezultujućeg seta
Obratite pažnju na više istih IDENTITY vrednosti ( u različitim tabelama )
Korak 11 : Brisanje tabela
"Korak 12 : Kreiranje sekvence , koje će koristiti sve 3 tabele"
Korak 14 : Unos istih podataka
Korak 17 : Kreiranje novih sekvenci će uzeti u obzir prethodno kreirane vrednosti !
Korak 2 : Kreiranjee Customer i CustomerOrder tabela i popunjavanje tabela podacima
Obrišite tabelu STUDENT
"Kreirati tabelu STUDENT , koja treba da sadrži podatke o upisanim studentima . U tabeli treba da se nalaze sledeće kolone : BrojIndeksa : obavezna kolona , primarni ključ JMBG : nije obavezna kolona , provera da li je unešeno 13 karaktera , jedinstveni ključ Ime : obavezna kolona ImeRoditelja : nije obavezna kolona Prezime : obavezna kolona DatumRodjenja : nije obavezna kolona , student u momentu upisa mora imati najmanje 18 godina MestoRodjenja : obavezna kolona ZemljaRodjenja : obavezna kolona , ako se ne unese , podrazumevano ' Srbija ' Studije : nije obavezna kolona Definišite za kreiranu tabelu PK i UK , kao i DEFAULT i CHECK ograničenja ."
Indeksi :: DEMO 1
Korak 5.1 : Obratite pažnju na kolone avg_fragmentation_in_percent i avg_page_space_used_in_percent
( uočite brzinu kojom se izvršava promena podataka )
Korak 8 : Rebuild tabele i njenih indeksa
Korak 10 : Brisanje tabele
Indeksi :: DEMO 3
Korak 3 : Pretraživanje sys . indexes za pregled strukture tabele
Indeksi :: DEMO 4
Korak 1 : tempdb je aktivna baza
Korak 2 : Kreiranje tabele
Korak 3 : Kreiranje neklasterovanog indeksa nad kolonama PublisherID i ReleaseDate u opadajućem redosled
Korak 4 : Pregled estimated execution plana za napisani upit
Korak 5 : Uključivanje Title kolone u indeks
"Korak 6 : Ponovo , pregled estimated execution plana za napisani upit"
Korak 5 : Promena podataka u tabeli
Korak 6 : Provera fragmentacije pomoću sys . dm_db_index_physical_stats
tempdb je aktivna baza
Korak 6.1 : Obratite pažnju na forwarded_record_count kolonu u rezultatu
Korak 7 : Rebuild tabele
Korak 9 : Brisanje tabele
Indeksi :: DEMO 2
Korak 2 : Kreiranje table sa definisanjem primarnog ključa
( obratite pažnju na ime koje daje SQL Server daje ograničenjima i indeksima )
Korak 2 : Kreiranje tabele kao HEAP
Pogledi :: DEMO 2
Korak 2 : Jednostavan pogled
Korišćenje prethodno kreiranog pogleda
Korak 3 : ( Malo ) složeniji pogled
TSQL je aktivna baza
Korak 4 : Brisanje pogleda
SELECT * FROM sys . views
Pogledi :: Zadatak 1
Testirajte kreirani pogled
"Napisati SELECT naredbu , koja će vratiti kolone productid i productname iz pogleda Production . ProductsBeverages . Filtirati podatke , tako da rezultati uključe samo proizvode , čiji je supplierid = 1."
"Promeniti definiciju prethodno napisanog pogleda ( bez ORDER BY ) , tako da uključi novu , izračunatu kolonu . Nova kolona treba da vrati vrednost ' high ' , ako je unitprice kolona veća od 100 , i u suprotnom , vrednost ' normal ' . Testirajte izmenjeni pogled ."
Obrišite kreirani pogled .
"U okviru baze TSQL , kreirajte pogled Sales . FaktureIzPoslednjeGodine Pogled treba da vrati fakture kreirane u prethodnoj godini ( poslednjih 12 meseci u odnosu na trenutni datum ) , koje su imale više od 1 stavke . Pogled treba da prikaže sledeće kolone : orderid , custid , empid , orderdate , requireddate ."
"Napisati SELECT naredbu , koja će vratiti productid , productname , supplierid , unitprice i discontinue kolone iz Production . Products tabele . Filtrirati podatke , tako da rezultati uključuju samo proizvode koji pripadaju kategoriji Beverages ( categoryid = 1 ) . Zapamtite napisanu naredbu kao pogled , sa imenom Production . ProductsBeverages ."
Korak 2 : Kreiranje procedure sa 1 ulaznim parametrom ( bez OUTPUT parametra )
Korak 3 : Testiranje procedure Sales . GetCustPhone
Korak 3 : Izvršavanje nekih sistemskih procedura
Korak 5 : Izvršavanje nekih proširenih sistemskih procedura
Korak 2 : Kreiranje procedure sa 1 ulaznim parametrom
Korak 3 : Testiranje procedure Production . ProductsbySuppliers sa različitim vrednostima za ulazni parametar
"Korak 4 : Modifikovanje procedure Dodaje se još 1 parametar , koji određuje broj rezultujućih redova Obratite pažnju na podrazumevanu vrednost za @numrows , koja se koristi u slučaju da se ne prosledi vrednost za ovaj parametar"
Korak 2 : Pregled sistemskih procedura Object Explorer - Databases - System Databases - master - Programmability - Stored Procedures
Procedure :: Zadatak 1
"Kreirati proceduru Production . Products_INSERT , koja treba da omogući unos novog proizvoda u tabelu Production . Products . Proveriti da li proizvod postoji , i u tom slučaju , prikazati poruku : Proizvod već postoji u tabeli . Ukoliko je proizvod uspešno unešen u tabelu , vratiti njegov IDENTITY ."
"Kreirati proceduru Sales . GetOrders , koja treba da vrati kolone orderid , orderdate , shippeddate , custid , empid , shipperid iz tabele Sales . Orders Procedura treba da ima 4 opciona ulazna parametra : orderid , orderdate , custid , empid . Ukoliko korisnici specificiraju vrednost za ulazni parametar , koristiti vrednost parametra za filtriranje resultujućeg seta . Ukoliko korisnik ne prosledi vrednost za ulazni parametar , njegova vrednost treba da bude NULL , i u tom slučaju , rezultujući set ne treba da se filtrira po tom parametru . POMOC : potraziti na vebu pojam """" stored procedure with dynamic search filter """""
kreirati procedure
Testirati procedure
"Kreirati proceduru Sales . GetTopCustomers , koja treba da vrati 10 najboljih kupaca , njihov id , contactname i vrednost kupovine . Izračunati procenat kupovine za svakog najboljeg kupca u odnosu na ukupnu vrednost kupovine . Podatke sortirati tako da najbolji kupac bude na vrhu rezultujućeg seta . Testirati izvršavanje procedure ."
Obrisati procedure
Obrada grešaka :: DEMO 1
Vrednost @@ ERROR varijable resetuje se posle izvršenja svake naredbe
Korak 8 : Pokušaj da se podigne sistemska greška
Korak 3 : Greška koja nastaje kod razrešavanja imena objekata . Naredba je sintaksno ispravna .
Korak 2 : Korišćenje TRY CATCH bloka sa ERROR funkcijama Greška se dešava ako se varijabli @num dodeli vrednost 0
"DECLARE @num varchar ( 20 ) = ' 0 ' ; BEGIN TRY PRINT 5 / CAST ( @num AS numeric ( 4,2 )) ; END TRY BEGIN CATCH SELECT ERROR_NUMBER ( ) AS errnum , ERROR_MESSAGE ( ) AS errmsg , ERROR_SEVERITY ( ) AS errsev , ERROR_PROCEDURE ( ) AS errproc , ERROR_LINE ( ) AS errline ; -- THROW ; END CATCH ; GO"
"Korak 4 : Run-time greške Ukoliko se klikne na poruku u Message tab-u , selektuje se mesto gde se desila greška"
Korak 4 : TRY / CATCH ne hvata greške koje nastaju kod razrešavanja imena objekata
Korak 5 : TRY / CATCH ne hvata greške koje su sintaksne
"Korak 6 : Pregled grešaka opisanih engleskim jezikom , čiji nivo ozbiljnosti je veći od 18"
"SELECT * FROM sys . messages WHERE language_id = 1033 AND severity > = 19 ORDER BY severity , message_id ; GO"
Severity .
State
zamena za prvi parametar
zamena za drugi parametar
Korak 5 : Dodavanje nove greške pomoću sistemske procedure sp_addmessage
"Izvršite napisani kod . Zašto se ne podiže greška , iako se izvršava deljenje sa nulom ? Modifikujte napisani kod , tako što ćete dodati 2 PRINT naredbe . 1. PRINT naredba treba da prikaže broj greške . 2. PRINT naredba treba da prikaže poruku o greški . Promenite vrednost varijable @num na A , i izvršite kod ponovo . Zatim , promenite vrednost varijable @num sa A na 10 , i izvršite kod ponovo ."
"Izvršiti napisani kod . Obratite pažnju na pojavu greške . Za obradu greške , napišite TRY CATCH block ."
Korak 4 : MULTI-STATEMENT UDF
testiranje
Brisanje kreiranih objekata
rezultat je 4.472135954958
Korak 6 : test sa korišćenjem f-je ( ulaz je kolona iz tabele ) bez definisane šeme
Korak 7 : test f-je ( ulaz je sistemska f-ja )
Korak 2 : Primer MAX sistemske skalarne funkcije
Testiranje f-je : prikazuje se 5 poslednjih porudžbina za kupca 79
Korak 3 : INLINE F-JA - 2. primer
prvo VIEW
poziv
"Kreirati skalarnu funkciju dbo . udf_IPtoNumber , koja će da datu IP adresu konvertovati u njen decimalni ekvivalent ."
Korak 2 : Testiranje IP adrese 95.215.220.0
"Korak 3 : Testiranje sa GeoIPCountryWhois podacima Korak 3.1 : Koristeći Export-Import wizard kreirati tabelu GeoIPCountryWhois sa podacima iz GeoIPCountryWhois . csv , koja se nalazi na Materijalima . Korak 3.2 : Proveriti podatke u tabeli GeoIPCountryWhois Korak 3.3 : Pronaći kojoj državi propada adresa 217.24.20.10"
"Kreirati skalarnu funkciju , koja treba da vrati broj godina . Broj godina se računa kao razlika 2 datuma u godinama pomoću funkcije DATEDIFF . Testirati 3 situacije : 1. razlika između određenog datuma rođenja i trenutnog datuma 2. razlika između 2 fiksna datuma : 20101231 i 20151215 3. razlika između 2 fiksna datuma : 20161231 i 20161201"
Korak 3 : Izvršavanje više naredbi
Korak 5 : Brisanje tabela kreiranih u 2. koraku
"Korak 2 : Kreiranje tabele za ilustraciju transakcija Prvo , brisanje tabela , ukoliko postoje"
podrazumevano podešavanje
FK greška
"Pošto je XACT_ABORT podešeno na ON , nije dodata nijedna vrednosti ( 1 i 3 su već bile u tabeli )"
Korak 6 : Izvršavanje naredbi sa greškom ( kako bi se testiralo upravljanje transakcijama )
Transakcije - READ COMMITTED :: DEMO 4.1
"Koraci u ovoj demonstaciji se izvršavaju kombinovano sa koracima u DEMO 4.2 ( u jednom prozoru se otvori DEMO 4.1 , u drugom prozoru DEMO 4.2 )"
"Korak 6 U konekciji 2 se , posle COMMIT naredbe u konekciji 1 , mogu videti promenjeni podaci"
Dobijaju se 2 reda sa vrednošću 0.00 za discount kolonu
Transakcije - REPEATABLE READ :: DEMO 5.1
"Koraci u ovoj demonstaciji izvršavaju se kombinovano sa koracima u DEMO 5.2 ( u jednom prozoru otvori se DEMO 5.1 , u drugom prozoru DEMO 5.2 )"
"Korak 6 posle koraka 5 , transakcija je odblokirana"
Transakcije - SERIALIZABLE :: DEMO 6.1
"Koraci u ovoj demonstaciji izvršavaju se kombinovano sa koracima u DEMO 6.2 ( u jednom prozoru otvori se DEMO 6.1 , u drugom prozoru DEMO 6.2 )"
Korak 7 ( Brisanje ubačenog reda )
Korak 8 Vraćanje izolacionog nivoa na podrazumevanu vrednost
Korak 4 Pokušaj ubacivanja reda u Sales . OrderDetails tabelu sa istom orderID vrednošću ( kao u upitu u konekciji 1 ) Obratite pažnju na blokadu !
"Kod nižih nivoa izolacije ( READ UNCOMMITTED , READ COMMITTED , REPEATABLE READ ) , ova INSERT naredba ne bi bila blokirana"
Transakcije - SNAPSHOT :: DEMO 7.1
"Koraci u ovoj demonstaciji izvršavaju se kombinovano sa koracima u DEMO 7.2 ( u jednom prozoru otvori se DEMO 7.1 , u drugom prozoru DEMO 7.2 )"
"Korak 5 : Obratite pažnju da podaci nisu blokirani , ali se dobijaju vrednosti koje su postojale kada je transakcija počela ( discount = 0.00 )"
Transakcije :: Zadatak 1
"Modifikovati napisani kod tako da sadrži TRY . CATCH block . Ukoliko su obe INSERT naredbe uspešno izvršene potvrditi transakciju . Ukoliko se desi neka greška , poništiti transakciju . U okviru TRY bloka napisati naredbu za prikaz teksta """" Commit the transaction … """" U okviru CATCH bloka napisati naredbu za prikaz teksta """" Rollback the transaction … """" Izvršiti napisani kod . Napisati SELECT naredbu za prikaz svih zaposlenih ."
"Izvršite napisani kod , koji briše prethodno dodate zaposlene ."
"Izvršite SELECT naredbu . Koliko zaposlenih se nalazi u rezultujućem skupu ? Zatim , izvršite kod koji počinje sa BEGIN TRAN i završava se sa COMMIT TRAN . Zbog greške u konverziji , podiže se greška . Izvršite ponovo SELECT naredbu . Obratite pažnju , bez obzira što se greška desila u okviru transakcionog bloka , dodat je 1 red u tabelu HR . Employees ."
Korak 3 : Kreiranje AFTER UPDATE okidača
pa tek onda kreiranje
Korak 4 : test AFTER UPDATE trigera
Korak 3 : Kreiranje INSTEAD OF okidača
Korak 4 : test INSTEAD OF trigera
DELETE FROM dbo . Zaposleni ; GO
Okidači - Alternative korišćenju okidača :: DEMO 5
Korak 4 : Testiranje okidača
Korak 5 : Brisanje tabele i njeno kreiranje sa izračunatom kolonom
Korak 6 : Testiranje tabele
Korak 3 : Kreiranje DDL trigera
Korak 4 : test DDL trigera
"Korak 4 : Kreiranje 2 indeksa , da bi se testirao rad DDL trigera"
Korak 5 : Brisanje kreiranih objekata
Korak 5 : Brisanje okidača
Korak 6 : Uklanjanje dodatih redova
"Korak 3 : Kreiranje AFTER DELETE okidača kada se briše kategorija , okidač postavlja kolonu Discontinued na 1 za sve proizvode koji pripadaju obrisanoj kategoriji )"
provera podataka
Korak 5 : Brisanje kreiranih tabela ( ujedno se brišu i postojeći okidači )
Trigeri :: Zadatak 1
"Kreirajte triger za INSERT u tabelu Sales . Customers , koji će ubaciti novi red u tabelu dbo . CustomerLogs sa odgovarajućim podacima"
Testirajte triger za INSERT u tabelu Sales . Customers Proverite da li je novi kupac ubačen u tabelu dbo . CustomeLogs
"Kreirajte tabelu dbo . CustomerLogs , sa sledećim kolonama : CustID int NOT NULL Action varchar ( 20 ) NOT NULL ActionDate datetime2 NOT NULL ( DEFAULT CONSTAINT = SYSDATETIME ( )"
WHEN last_active_at IS NULL THEN 4
View structure for view__detalji_o_agentima
Triggers structure for table article
Navicat Premium Data Transfer Source Server : localhost Source Server Type : MariaDB Source Server Version : 100129 Source Host : localhost : 3306 Source Schema : idb_2008213514 Target Server Type : MariaDB Target Server Version : 100129 File Encoding : 65001 Date : 08/01/2020 13:03:25
Triggers structure for table sale_article
Table structure for article
Table structure for sale
Table structure for sale_article
Function structure for get_account_id_by_account_number
Procedure structure for withdraw
Navicat Premium Data Transfer Source Server : localhost Source Server Type : MariaDB Source Server Version : 100129 Source Host : localhost : 3306 Source Schema : ir2_banka Target Server Type : MariaDB Target Server Version : 100129 File Encoding : 65001 Date : 12/12/2019 11:37:54
Table structure for account
Records of transaction
Records of type
Procedure structure for deposit
"Napraviti funkciju koja vraca saldo racuna na osnovu broja racuna koji je dat kao ulazni argument funkcije . Saldo je DECIMAL ( 10 , 2 ) . Vodite racuna o tome da suma ulaznih ili izlaznih transakcija tog racuna moze da bude NULL , tako da moramo da koristimo IFNULL funkciju da takve vrednosti tretiramo kao 0 pre aritmeticke obrade ."
SELECT get_saldo_by_account_number ( ' 100 - 1244707 - 78 ' ) ;
Table structure for user_login
View structure for view__latest_activities_by_user
View structure for view__latest_logins_by_user
Records of message
Table structure for user
Records of user
` year ` > = 2001 AND ` year ` < = 2008
Ovo je alternativno
AND imaju prioritet nad OR
Vezivanje actor i film_actor
Vezivanje film i film_actor
sortira rastuce
grupise po ID aukcije
bira maksimumalnu cenu iz skupa
"SELECT getTotalAmountByAgentBetweenDates ( 1 , ' 2020 - 01 - 02 ' , ' 2020 - 01 - 08 ' ) ;"
View structure for view__detalji_o_aukcijama
View structure for view__spisak_aukcija_za_stopiranje
Event structure for e_sii2_aukcije_stopiranje_neaktivnih_aukcija
Table structure for auction
Records of auction
Records of offer
Napisite izraz koji ce aukcije koje odgovaraju kriterijumu koji je prethodno opisan da stopiraju postavljanjem is_stopped polja na vrednost 1.
STARTS ' 2020 - 01 - 20 11:00:00 '
STARTS CURRENT_TIMESTAMP + 1 DAY
ENDS ' 2020 - 02 - 20 11:00:00 '
ENDS CURRENT_TIMESTAMP + 7 DAY
Deaktiviranje
Pravljenje naloga korisnika
Oduzimanje prava korisniku nad tabelom
Oduzimanje svih prava nad svim elementima baze
Kreiranje i dodela svih prava korisniku nad svim bazama i tabelama
Dodela svih prava korisniku nad tabelama u bazi
STUDENT
Check ko je od studneata na predmetu
i na kraju obrisi Grupu
GRUPA
obrisi sve studnete za grupu koju brises
Pri promeni Predmeta moraju su liste Updateovati
LAB VEZBE
PROJEKAT / DOMACI
Enable pitanja predmet
"provera usaglasenosti inicijala , indeksa i username-a"
uloguj zaposlenog
sortiranje obavestenjaPredmet
update sifre
vratiti korisnika na ekran za prijavljivanje na siste izloguj ga pre toga
registracija
upload slike
~ IZMENA STUDENATA ~
~ IZMENA ZAPOSLENOG ~
~ DODAVANJE PREDMETA I IZMENA PREDMETA ~
~ FAJLOVI ~
"OMOGUCI MULTIPLE SELECTION U HTML , I LOGIKU IZA"
"zvanje , postoje predefinisana"
"jedinstveno , kako mu definisati format ?"
"status i br. kabineta mu dodeli neko , valjda admin"
"ovo stavi post u moj licni niz , to je ok sto se tice frontenda"
"ponovo , prosledjuje se kopija niza posts iz nekog sad optimizacija klinacpalac razloga"
"sledi samo jedna pokazna f-ja , ne treba mi u projektu"
hajde da probam da getujem usera iako podatak na server strani ima samo tri polja
ovo transformedTemps je niz podataka koji sam izvadio iz baze i koji je vratila pipe f-ja
evo ga i nacin da servis sam vrati podatak a da komponenta kasnije obradjuje subscribe
"ako nema query parametera , znaci da se radi o listanju kolekcija iz objekta"
"Ako postoji queryParams , dohvatamo sta zelimo da listamo"
TO DO : Greska jos neke za username i slicno
promeniti u posebnu kolekciju ?
dohvata sve zaposlene
dohvata studente po username
dohvata obavesttenja za predmete
dohvata informacije o predmetu
dodaje materijal za predavanja
dodaje studenta na spisak
* ruta za upload materiajala
ime fajla
provera da li je admin
provera da li je student
nista nije proslo dodati konacnu poruku !
ako je jednocifren
"Post zahtev - da azuriramo bazu , dohvatimo podatke"
iz konstruktora
Predmeti koje nastavnik drzi
Sve vesti od profesora
Na koje predmete je student prijavljen
pomocni niz za vesti
Sve vesti iz kolekcije
Dohvata sve nastavnike na predmetu iz koga je vest
za brisanje ( da prikaze )
Cuva trenutni ( izabrani ) predmet u kolekciji TrenutniSacuvaniPredmet
U Predmeti trazimo sve nastavnike na tom predmetu
Dohvatamo zbog ispisivanja
Komponenta za upravljanje kategorijama obaveštenja . Admin može da dodaje i uklanja kategorije . Dodate kategorije postaju dostupne zaposlenima pri dodavanju novog obaveštenja .
Komponenta za upravljanje predmetima . Admin može da dodaje i uklanja predmete .
Trenutno selektovana podstranica u okviru stranice predmeta
Početne vrednosti za novi predmet
Selektuje podstranicu u okviru stranice predmeta
Kreira predmet
Funkcija za dohvatanje spiska studenata u CSV formatu
Komponenta sa formom za ažuriranje ili brisanje studenta od strane Admina .
Komponenta za upravljanje zaposlenima . Admin može da dodaje i uklanja zaposlene iz sistema . Admin može da dodaje zaposlene na predmet ( plan angažovanja ) .
Čuva je u polje slika u formatu String | ArrayBuffer
Komponenta sa formom za ažuriranje ili brisanje zaposlenog od strane Admina . Sadrži i polje za dodavanje fotografije zaposlenog .
Metoda za Zaposlenog . Ažurira informacije o predmetu .
Pomoćna funkcija koja dohvata JWT token iz Local Storage-a ukoliko on postoji . JWT token se šalje u okviru headera radi autentifikacije ulogovanog korisnika .
Dohvata sva obaveštenja .
Metoda za Zaposlenog . Dohvata sva obaveštenja koja je postavio i obaveštenja na predmetima na kojima je angažovan .
Dohvata sva obaveštenja za neki predmet .
Metoda za Zaposlenog i Studenta . Za zaposlenog dohvata sve spiskove koja je postavio i spiskove za predmete na kojima je angažovan . Za studenta dohvata sve spiskove koji se ondose na predmete koji prati .
Metoda za Zaposlenog . Prisleđuje se id spiska . Otvara i zatvara spisak u zavisnosti od vrednosti parametra ' otvoren ' .
Metoda za Admina . Vraća celokupne informacije iz baze o svim predmetima .
Komponenta sa formom za login .
Dohvata sve predmete na masteru
Proverava da li je korisnik ulogovan da bi linkovi ka stranicama predmeta bili vidljivi
Komponenta za prikaz informacija o master studijama i spiska predmeta .
"Komponenta za navigaciju ka stranicama : / nauka-istrazivanja , / nauka-projekti"
3 meseca u milisekundama = 760
Dohvata listu predmeta za ostale odseke
Komponenta za prikaz liste predmeta na ostalim odsecima ( oni koji nisu SI ili RTI )
Dohvata listu predmeta za odsek RTI
"Komponenta za prikaz svih informacija o nekom predmetu . Sadrži podstranice za : Obaveštenja , Informacije , Predavanja , Vežbe , Ispitna pitanja , Laboratorija , Domaći ."
Osvežava podatke o predmetu
"Izvršava promenu lozinke Da bi promena lozinke bila uspešna , korisnik mora tačno da unese svoju staru lozinku"
Proverava da li su uneti svi obavezni podaci
Redirect ako nije Student
Da li je lista prijavljenih studenata trenutno vidljiva za spisak sa određenim indeksom
Da li je forma za prijavu trenutno vidljiva za spisak sa određenim indeksom
Provera da li student može da se prijavi na dati spisak
Komponenta za prikaz poruke o grešci u slučaju neautorizovanog pristupa nekoj stranici .
Metoda za Admina . Ažurira informacije o nekom studentu .
Metoda za Admina . Uklanja postojećeg studenta .
Metoda za Admina . Registruje novog zaposneog na sistem .
Metoda za Admina . Dohvata sve informacije o nekom zaposlenom .
"Login korisnika ( studenta , zaposlenog ili admina ) na sistem . Vraća JWT token koji služi za dalju autentifikaciju korisnika pri radu sa sistemom ."
Servis za upravljanje korisnicima . Osvaruje komunikaciju sa BackEnd delom sistema slanjem zahteva pomoću modula HttpClient .
Menja lozinku trenutnog korisnika . Stara lozinka mora da se poklapa da bi se ažuriranje uspešno izvršilo .
"Dohvata ulogu trenutnog korisnika ( Student , Administrator ili Zaposleni )"
Dohvata korisničko ime zaposlenog iz prosleđenog parametra
"Komponenta za prikaz detaljnih informacija o nekom Zaposlenom . Sadrži informacije o Zaposlenom koje su uneli Admin ili sam Zaposleni , kao i sliku koju je opciono dodao Admin ."
Dohvata listu predmeta na kojima je trenutno ulogovani Zaposleni angažovan
Obrađuje fajlove dodate na obaveštenje Moguće je dodavanje više od jednog fajla
Moguće je dodavanje više od jednog fajla
Izvršava kreiranje novog obaveštenja
Komponenta sa formom za dodavanje novog spiska od strane Zaposlenog .
Tajna šifra za enkripciju i dekripciju tokena
"Funkcija Authorize se izvršava pre obrade svakog zahteva . JWT token koji služi za autorizaciju se čita iz header-a svakog pristiglog zahteva Proverava se da li korisnikova uloga odgovara zadatom pravu pristupa U suprotnom se vraća 401 Unauthorized Uloge : Administrator , Zaposleni ili Student"
"Primer poziva : authorize ( [ "" Administrator "" , "" Zaposleni "" ] )"
Prelazak na obradu zahteva
Pronalaženje svih obaveštenja za te predmete
Čitanje korisničkog imena trenutno ulogovanog korisnika iz tokena
"type : obavezan , izborni"
"predavanja , vezbe , lab , projekat , ispit , obavestenja"
Uploading the image / n uupload . single uzima iz req . body . file i storuje
MENI ZA ZAPOSLENE
MENI ZA STUDENTE
* * Komponenta koja sluzi za navigaciju izmedju plana angazovanja i izmene podataka
izbrisi sve odseke iz kursa ( da bi dodao nove )
* * Metoda dohvata sve predmete zajedno sa nastavnicima koji su angazovani na njima * Povratna vrednost je greska iz StandardErrorResponses ili niz tipa CourseDataWithStaff *
jedan course objekat koji sadrzi staffData i basicCourseData
za svaki par course_id - user_id dohvati podatke za nastavnika
kraj obrade jednog podatka iz baze
* Filtriranje niza kao LIKE operator
* * Metoda kreira indeks grupe ovog tipa * u svrhu kreiranja imena grupe koja se dodaje * @param data
** * * Dohvata sve predmete zajedno sa grupama i nastavnicima angazovanim u tim grupama *
prodji kroz svaku grupu koja postoji za ovaj kurs
za svaki plan koji ukljucuje ovu grupu ( u sustini za svakog zaposlenog ) kreiraj podatke koji ce biti vraceni klijentu
vracanje rezultata klijentu
"* ime koje se definise na osnovu * tipa materijala kom pripada , * file_name iz requesta * i id-ja pod kojim je ubacen u bazu * ( ex . _notice_file_name_id ) *"
* * Registracija studenata sa potrebnim podacima za bazu
ukljuci podatke za kurs
* * * All info data
"* * Neuspesno azuriranje iz nepoznatog razloga ( prosle su sve ostale provere , ali se upit ne izvrsava ispravno ) UPDATE upit"
* * Greska u parametrima *
* * Objekat notice mora biti dohvacen iz baze uz include odgoarajucih tabela * @param notice
** * * Azuriranje podataka koji su dozvoljeni da budu azurirani od strane zaposlenog * *
* * * Brisanje obavestenja koje je postavio nastavnik * staff_id : nastavnik * notice_id : id obavestenja koje se brise * *
"izmeni naslov , opis i datum"
"console . log ( "" req . body . files Ok "" )"
* * * Dohvatanje obavestenja po id-ju * Parametri : * notice_id : id obavestenja
"* * Dohvatanje svih kurseva na kojima nastavnik predaje , zajedno sa * obavesetenjima , sekcijama i linkovima do materijala koji su postavljeni * *"
ko je postavio materijal
izbrisi ulaz iz baze
dodavanje materijala u bazu
* * Niz svih rutera koji se koriste *
PROMENA SLIKE -
OBAVESTENJA ADMIN -
Dodaj profesora na predmet
Proveri sta ide ovde
Obavezan ili ne obavezan
prelazak na stranicu sa listom predmeta
povratak na stranu sa opcijama koje ima admin
pomocna funkcija koja sluzi za plan angazovanja za vezbe
"funkcija koja dodaje postojanje aktivnosti laba , domaceg ili projekta iz tog predmeta"
brisanje korisnika - zaposlenog ili studenta u zavisnosti od toga da li je prikazana lista studenata ili ne funckija prihvata jednog korisnika - studenta ili zaposlenog
rutiranje na stranicu gde admin ima svoje opcije
"Funckija koja sluzi za login korisnika , najpre se pokusava sa dohvatanjem podataka koje je uneo admin , ukoliko se ne uspe , prelazi se na proveru tabele za zaposlene , ukoliko ni to ne uspe , prelazi se na pretragu tabele za studente i tu se zavrsava pretraga . Ukoliko nisu pronadjeni odgovarajuci podaci , metoda vraca gresku da su uneti pogresni podaci"
pretrazujem studenta
mora da promeni lozinku prvo
za cuvanje materijala na disku
"za studenta i da bih pratila predmete koje je prijavio - pomocni flagovi , ne postoje u bazi"
"o - otvoren , z-zakljucan"
naziv npr. Grupa 1 za Predmet X
"da li postoji limit 1-postoji , 0-ne postoji"
"ako postoji limit , max broj osoba na spisku"
profesor koji je okacio spisak
Postavljanje statusa spiska na zatvoreno i onemogucavanje studentima da se i dalje prijavljuju na spisak
ako nemamo u localStorage da se dohvata iz baze prilikom ucitavanja stranice
funkcija koja dohvata sva obavestenja koja je okacio taj zaposleni
izmena osnovnih informacija o zaposlenom
da omogucim dodavanje / uklananje zaposlenog iz grupe - ja se ne nalazim u svim grupama
dodavanje zaposlenog u neku grupu za predavanje
- DEO ZA DODAVANJE MATERIJALA -
Dodavanje nove lab vezbe na server i azuriranje trenutnog predmeta na frontu
Brisanje vezbi - funkcija prima te vezbe i indeks u nizu vezbi
Brisanje projekta - funkcija prima taj projekat i indeks u nizu projekata
funkcija koja je sluzila za proveru prilikom realizacije nekih funkcionalnosti
rutiranje na admin stranu
dodavanje informacija o novom projektu koji ce biti dostupan na sajtu
funkcija za logout - ciscenje celog localStorage
"Administratorova funkcija koja sluzi da studentu odobri pracenje odredjenog predmeta Nakon toga , student ima prava da pregleda predmete i skida materijale koji su dostupni kod tog predmeta"
dohvata naziv predmeta na osnovu id predmeta
dohvata sve studente iz baze
brisanje zaposlenog na osnovu id zaposlenog
dodavanje novog predmeta - funkcija prima objekat predmeta
dohvatanje predmeta na osnovu id predmeta
"azuiriranje obavestenja , salje se ceo objekat obavestenja"
pomocna funkcija
nije koriscenja
dohvata zvanje na osnovu id zvanja
dohvatanje svih projekata koji postoje u bazi
dohvatanje nastavnika na osnovu korisnickog imena
dohvata obavestenja koja postoje na predmetima
dohvatanje predmeta na osnovu tipa studija
"postavljanja zahteva za pracenje , prima se korime studenta koji salje zahtev i id predmeta za koji se salje zahtev"
funkcija za registraciju novog studenta
azuriranje svih neophodnih informacija o zaposlenom
dohvata sve nastavnike
dodavanje novog obavestenja
"Obavestenja za predmete , sadrzi naslov , sadrzaj , na koje predmete se odnosi obavestenje ( id predmeta ) , datum postavljanja obavestenja , korisnicko ime profesora koji je okacio to obavestenje , linkovi i naziv fajlova koje je okacio profesor uz obavestenje"
"Opsta obavestenja koja su dostupna na pocetnoj stranici sistema Sadrzi naslov obavestenja , sadrzaj obavestenja , datum postavljanja obavestenja i kategoriju obavestenja"
"Predmet sema - sadrzi naziv predemta , sifru predmeta , tip predmeta ( Obavezni ili Izborni ) , Fond casova ( 3 + 0 + 2 ) , broj ESPB poena , smer , semstar / semestri u kojima se odrzava predmet , cilj i ishod predmeta , termine vezbi , temine predavanja , informacije o tome da li postoje lab vezbe , domaci zadaci , projekti i ukoliko postoje , onda postoje i detalji o ovim aktivnostima . Postoji i raspodela broja poena po aktivnostima , linkove ka fajlovima koji se ticu predavanja , vezbi , ispitnih rokova , projekata , domacih zadataka . Sadrzi informacije o tome da li su dostupne stranice za pregled ispitnih rokova , projekata , lab vezbi . Sema predmet sadri i informacije o tome koji nastavnici su angazovani na kojoj grupi predavanja i kojoj grupi vezbi ( Plan angazovanja ) ."
"Termin sema - sadrzi dan i vreme termina za odrzavanje vezbi i predavanja , zamisljeno je da je moguce izabrati sve radne dane od Ponedeljka do Petka i vremena u periodu od 08 h - 22 h"
"Zahtev sema - sadrzi informacije o tome koji student je uputio zahtev ( korisnicko ime studenta ) , za koji predmet ( id predmeta ) , flag - na pocetku je 0 jer zahtev nije prihvacen , a administrator kada prihvati zahtev , flag postaje 1 i student dobija mogucnost da aktivno prati predmet"
Funkcija koja dodaje novo predavanje u folder podaci i podfolder za taj konkretan predmet Koristi se Multer biblioteka koja je namenjena za upload fajlova na server
"console . log ( "" Uspesno ucitao predavanje ! "" )"
"jako je bitno da se ovde stavi vracanje poruke kako bi postojala sinhronizacija izmedju fronta i backa i kako bih na frontu imala azurnu situaciju da sam igurno na backu uradila update . Desavalo se da mi , ako ne stavim povratnu poruku u okviru update metode , da ne dobijem azurnu informaciju na frontu"
Funkcija koja koja se koristi kod studenta . On sluzi da se posalje njegov rad prilikom dodavanja sebe na spisak Koristi se Multer biblioteka koja je namenjena za upload fajlova na server
Funkcija koju koristi student kako bi se prijavio na neki otvoreni spisak
Nije prisutno za ' admin ' korisnika .
Polja prisutna samo za ' student ' korisnike .
"Moguce vrednosti : ' admin ' , ' zaposleni ' ili ' student ' ."
spiskovi : [ ] ;
Proveri da li kesirani predmet odgovara predmetu koji je zatrazen ;
Stranica nije dozvoljena za prijavljene korisnike .
Stranica nije dozvoljena za zaposlene .
Stranica nije dozvoljena za studente .
Istekao JWT - idi na pocetnu .
Parsiranje datuma iz stringova .
"Prebroji koliko filtera je odabrano . Ako nije odabran nijedan , prikazi sva obavestenja ."
Dohvati trenutni url .
Dohvati trenutnu verziju predmeta .
Iteriraj kroz sve predmete koje je upit vratio .
Proveri da predmet vec nije dodat za ovaj semestar - moze se desiti ako 2 odseka imaju isti predmet u istom semestru .
Korisnicko ime je zauzeto .
Hesiraj lozinku .
jwt
TODO : Proveri da li student prati trazeni predmet .
Dohvati fajl .
TODO : cleanup upload / download routes
Ne radi
provera da li je uploadovani fajl slika
ako fajl nije null
dodati dijalog
dodati dijalog !
ne radi !
Poboljsati
Server vraca zaposlenog kome se poklapa kor ime sa parametrima
Server kreira studenta sa parametrima
Vracanje svih aktivnih studenata
obrisi predmet na osnovu id-ja
Server vraca sve predmete
Server kreira predmet sa parametrima
update lozinke i stavi prviPut = false
ovo samo admin poziva
* * resetovanje svih promenljivih
"* * registracija zaposlenog , uneti parametri se prosleđuju servisu * stdeta koji ih šalje http zahtevom gde se novi zaposleni unosi u bazu"
* * dohvatanje korisnika iz baze i setovanje promenjivih
* * funkcija koja napušta opciju ažuriranja
"* * potvrda azuriranja zaposlenog , podaci se šalju servisu zaposlenog i uređuje se baza"
* * dohvaanje odseka na odabranom predmetu
* * potvrda ažuriranja predmeta
Uslov da se predmet smatra položenim je da student ima preko 51 bod zbirno na svim aktivnostima . Da studentu bude lepo
* * postavljanje broja grupa koje administrator želi da postavi na predmet
* * selektovanje studenta i deselektovanje sudenta za dodavanje na predemta
* * funkcija kojom se vrši izbor opcije za dodavanje novog fajla
* * * funkcija koja omogućava sortiranje postavljenih fajlova na stanici
imena funcija su ista kao i http poziv
* * funcija kojom se bira opcija postavljanja novog obavestenja
* * * uklanjanje odabranog obaveštenja
* * dohvatanje predmeta koji su na smeri op
* * dohvatanje izabranog fajla iz baze
* * funkcija kojom se bira opvija postavljanja novog fajla
* * dohvatanje i stortiranje svih obavestenja vezanih za predmet
* * dohvatanje materijala postavljenog za ispitna pitanja
* * dohvatanje materijal apostavljenom za projekat
* * dohvatanje predmeta koji treba da se prikaže na stranici
* * odustajanje od ažuriranja predmeta
* * * funkcija kojom se obelezava predmet koji student zeli da sluša
* * * uklanjanje konkretne vesti u sistemu
* * funkcije koja dohvata predmet iz baze
* * izbor opcije za dodavanje nove vesti
* * * odabir opcije za ažuriranje postojeće vesti
* * * funkcija u kojo se menja redosled prikazivanja postavljenih vežbi
* * * funkcija koja otvara fajl u novom tabu
* * odustanjaje od opcije promena
* * odustajanje od promena
* * izbor opcije za ažuriranje
alert ( odabraniZaposleni . ime ) ;
* * dodavanje fajla vesti
* * čuvanje fajla na backend delu
* * uklanjanje fajla vezanog za vest
predavanja
pokreni FileReader
sacuvaj podatke
XLS i CSV ucitavanje studenata
"* * TextEditorComponent je dodat u aplikaciju posebnom instalacijom * * @kolkov / angular-editor * * Predstavlja uniformni prikaz namenske komponente za uredjivanje teksta * Poseduje vise opcija i pogodan je da se koristi kada se objavljuju neke informacije * koje pored informativnog karaktera , trebaju da imaju i zadatak da privuku korisnika , * a i da istaknu neke detalje i da dodaju neke , koje bi bilo mnogo komplikovanije * dodati koriscenjem obicnoe textview komponente"
ciscenje alerta
"* * @private * u zavisnosti od promene stanja ovog Subjecta , menja se stanje i * text Observable objekta koji svim svojim subscriberima javlja da se desila * promena , i time vrednosti koje se unose u custom komponentu su uvek dosledne * i spremne da se posalju u bazu"
"Kada se promeni ruta , vracamo se na prvu stranu predmeta Uvek se na pocetku prikazuje informacija sa obavestenjima"
INICIJALIZUJI SE KORISNIK I VRSI SE AUTORIZACIJA
DODAVANJE NOVOG TIPA
INICIJALIZACIJA KORISNIKA I AUTORIZACIJA
DODAVANJE NOVOG STUDENTA
ODBIJANJE STUDENTSKE PRIJAVE ZA PREDMET
DODAVANJE NOVOG ZAPOSLENOG
INICIJALIZACIJA SVIH STUDENATA
INICIJALIZACIJA KORISNIKA
INICIJALIZACIJA SVIH NOTIFIKACIJA
DODAVANJE PROFESORA ZA VEZBE U PLANU ANGAZMANA
INICIJALIZACIJA PREDMETA ZA PRIKAZIVANJE
SORTIRANJE OBAVESTENJA NA PREDMETU
PROMENA LOZINKE
CUVANJE ZAPOSLENOG KOJI CE SE PRIKAZATI NA NOVOJ STRANICI
DODAVANJE NOVOG LABA
BRISANJE ISPITA
PROMENA PROJEKTA ILI LABORATORIJA
DODAVANJE NOVOG ISPITA
DODAVANJE NOVOG PROJEKTA
- Servisi za rad sa korisnicima -
Korisnik sa korisnickim imenom vec postoji u sistemu
Obavestenja
ObavestenjePredmet
PlanPredmet
dodato za novi spisak zaposlenih
"nista on nije registrovan , ne moze da vidi detalje o predmetu"
formira sve potrebne nizove i sve za ubacivanje jednog plana angazovanj
na koju grupu se odnosi
imeiprezime
tip
za slucaj da se neka budala nije odjavila
postavljanje korisnika u localStorage
korisnicko ime nije ispravno
ne dohvatamo predmet iz baze vec iz localStorage-a
predmet ima vise obavestenja
dodatak u toku dizajna
funkcija koja prijavljuje studenta na spisak tako sto ga dodaje tamo u spisku i niz studenta i omogucava mu da uploaduje zip ili 7 z fajl
da se azurira prikaz na stranici
domaciPoPredmetu
dodato hardkodovano
id vesti u koju se dodaje
fajl imeiprezime tip datum velicina
kopirana funkcija za upload za dodavanje slike zaposlenom od strane admina
ovde imamo ime fajla
opsti podaci za sve
TODO regex sifra predmeta
TODO select za smer
* OBAVEŠTENJA *
AŽURIRANJE OBAVEŠTENjA
REGISTRACIJA KORISNIKA
KATEGORIJA ( TIP ) OBAVEŠTENJA
* ANGAŽOVANJE NA PREDMET ( ZAPOSLENI ) *
TODO napravi zasebnu stranicu za svako obavestenje
zajednicki parametri
TODO captcha za registraciju korisnika
/ PREDMET /
dodavanje predmeta
/ AZURIRANJE PREDMETA /
/ DODAVANJE PREDAVACA /
izmena korisnika za 2 way
dohvatanje fajlova u nizove sa materijalima
neregistrovan korisnik
u zavisnosti od parametra niz dodaj u odgovarajuci niz sa materijalima i azuriraj predmet
e sad nisu svi za dati smer
id obavestenja i moze da se koristi za sortiranje
"alert ( "" pravim "" ) ;"
dohvatis sve predmete te fino i onda mozes lepo radis ko covek
idi na pocetnu pa se loguj opet ;
to je mail polje zapravo
"multer za FormData format , ono djubre indijsko angular-file-uploader salje kao FormData i bodyparser to ne moze handluje pa se koristi multer"
zapravo naziv je sifra
Obavezan ili izborni
funkcija za promenu lozinke
provera da li je stara lozinka ispravno uneta za ulogovanog korisnika
"ovo je potrebno jer u istoj komponenti prikazujemo sva 4 tipa obavestenja ( takmicenja , konferencije , praksa i posao )"
"ovo je potrebno jer u istoj komponenti prikazujemo sva 4 plana nastave ( za si , rti , ostale i master )"
pomocna promenjiva koja odredjuje da li ce se prikazivati forma za logovanje ili username i dugme za logout
da bi smo znali sta sve treba da prikazemo u zaglavlju
Username od ulogovanog korisnika
Password od ulogovanog korisnika
provera da li su oba polja popunjena
administrator
cuvamo tip korisnika kako bi smo znali koje funkcionalnosti da mu omogucimo
ulogovani zaposleni je neaktivan - potrebno je izvrsiti promenu lozinke
azuriranje svih zaposlenih iz niza ( for petlja prolazi kroz niz )
pomocni meni - drugi nivo
dovlacenje svih angazovanja iz baze
cuvamo podatke iz forme za dodavanje
cuvamo sve iz baze
bool koji nam kaze da li je prikaz za brisanje ili azuriranje
provera da li su obavezna polja prazna
upload fajla za domaci
event koji okida kada se ucita fajl za lab
dodavanje obavestenja u bazu
dovlacenje plana angazovanja iz baze
pomocu ovih metoda simuliram podmeni za obavestenja
dovlacimo sve podatke za izabrani predmet iz baze
promena podataka o predmetu u bazi
filtrira samo obavestenja iz poslednja 3 meseca
dovlacenje plana nastave iz baze
"pozivamo ovu metodu na pocetku html komponente kako bi smo znali koji tip korisnika je ulogovan , njegov username i odsek za koji izlistavamo predmete"
kada korisnik pritisne slajd levo za sliku
kada korisnik pritisne slajd desno za sliku
proveri da li je obavestenje mladje od 7 dana
ugradjujemo http klijent kako bi smo mogli da saljemo http zahteve
metoda koja dohvata pracenje predmeta iz baze
metoda koja dohvata sve predemte iz baze
metoda koja dohvata zaposlenog po username-u
metoda za registraciju studenta
pakujemo username i password u jednu promenjivu ( data )
1. arg : naziv pod kojim eksportujemo objekat 2. arg : objekat 3. arg : ime kolekcije u bazi povezujemo se sa bazom
struktura objekata studenta u kolekciji reprezentuje jednog usera
trazimo sva obavestenja ( nema uslova u metodi find ) i on nam vraca ili gresku ili obavestenja
ako nema greske vratimo niz obavestenja u JSON formatu
ako nema greske vratimo niz u JSON formatu
kreiramo nasu aplikaciju
trazimo sve iz zaposlenih ( nema uslova u metodi find ) i on nam vraca ili gresku ili obavestenja
dohvatanje studenata
ova aplikacija moze da obezbedi i koristi cros origin shering i da cita podatke iz tela zahteva u JSON formatu
dohvatanje predmeta
obezbedjuje cors origin shering
ispisemo poruku ako je konekcija uspesno otvorena
podizemo jedan rest api uz pomoc jednog rutera
registracija - post zahtev
"mora prvo err pa user , nikako obrnuto"
promena sifre za studenta
dohvatam username i novu lozinku iz tela mog posta
dodaj niz u bazu
"exportuje pod imenom User ovaj objekat User , a iz baze gleda tabelu users"
gde ce da se smestaju fajlovi
kako se naziva fajl kada se uploaduje
STA JE BRE OVO
* * brisanje odabranih fajlova iz reda u uploaderu * @param i indeks koji iznacava na kojem odeljku stranice se vrsi azuriranje
* * download fajla * @param uploadName ime fajla na serveru
* * inicijalizacija fajl loadera koji se koriste pri uploadu fajlova
* * provera da li je trenutni datum pre zadatog datuma * @param date datum
radi se upload samo poslednjeg fajla
* * provera da li je student na spisku * @param usernames niz korisnickih imena koji se nalaze na spisku
* * filtriranje i sortiranje predmeta po semestrima i nazivu * @param coursesInfos niz sa informacijama o predmetima * @param semester semestar
* * brisanje zaposlenog * @param username korisnicko ime
redirekcija ako parametar nije pravi
* * @module * komponenta za prikaz profila zaposlenog
* * @module * komponenta za prikaz liste zaposlenih
* * @module * komponenta za prikaz pocetne stranice katedre
* * slajdovanje slika
* * dodavanje novog predmeta
* * azuriranje informacija o predmetu
radi se aploud svih fajlova
ako obavestenje sadrzi i fajlove salju se svi
obicno obavestenje bez fajlova
* * dohvatanje svih predmeta na kojima je nastavnik
* * @module * komponenta za prikaz bocnog menija
filtriranje obavestenja mladjih od 3 meseca i sortiranje po datumu
* * @module * komponenta za prikaz glavnih obavestenja kojima upravlja admin
* * @module * komponenta za prikaz projekata - radova i ponuda za zaposlenje i prakse
* * @module * komponenta za promenu lozinke
* * dohvatanje podataka iz csv fajla * @param csvRecordsArray niz podataka o studentima * @param headerLength broj kolona
* * registracija studenta ucitanih iz csv fajla
* * ispis imena odabranog fajla radi sto boljeg simuliranja input type file * @param fileInput html input
* * @module * guard kojim se omogucava pristup pojedinim stranicama samo adminu
* * brisanje predmeta i informacija * @param code sifra predmeta * @param coursename ime predmeta
* * dohvatanje svih predmeta za odredjeni modul * @param module modul
* * dohvatanje nastavnika koji su na predmetu * @param coursename ime predmeta
* * dohvatanje svih zaposlenih
* * dohvatanje zaposlenog * @param username korisnicko ime
* * @module * servis za zaposlene
* * dodavanje kategorije opsteg obavestenja * @param category kategorija
* * brisanje fajla sa sajta predmeta * @param uploadName ime fajla na serveru
* * azuriranje redosleda prikaza fajlova na sajtu predmeta * @param uploadNames imena fajlova na serveru * @param orders redosled
* * dodavanje obavestenja o predmetu * @param notice obavestenje
* * dohvatanje svih obavestenja za predmet * @param code sifra predmeta
* * prijava na sistem * @param username korisnicko ime * @param password lozinka
* * registrovanje novog korisnika * @param user korisnik
* * dohvatanje predmeta koje pohadja student * @param username korisnicko ime
* * @module * servis za studente
* * azuriranje podataka o korisniku * @param user korisnik
* * @module * komponenta za prikaz profila studenta
moraju svi podaci biti uneti
moraju biti uredu stara lozinka
da ne bi opet iste sumbitovao dok ne ucita novi fajl
kako bi se pocetna opet ucitala radi lepseg izgleda
provera da li je korisnik admin
provera da li je korisnik profesor
proslo proveru do sada
provera za tip studija u korisnickom imenu
atributi za registraciju profesora
inicijalizacija zbog provere
kada je udifined samo pedji na no_image . jpg
kraj
pocetno stanje forme
opciono
- ZAPOSLENI -
- OBAVESTENJA -
na rtiu
- PLAN ANGAZOVANJA -
poziv servisne f-je koja je vezana za bekend deo
* * Klasa za dodavanje korisnika koju poziva administrator
* * Funkcija za dohvatanje studenata na predmetu na promenu predmeta
* * Funkcija za dodavanje studenta na predmet
* * Funkcija za brisanje studenta s sa izabranog predmeta * @param s
* * Klasa za azuriranje korisnika koju poziva administrator
* * Klasa za prikazivanje pocetne stranice administratora
* * Klasa za azuriranje predmeta koju poziva administrator
* * Funkcija za brisanje predmeta p * @param p
* * Klasa za dodavanje predmeta koju poziva administrator
* * Funkcija za dodavanje predmeta
* * Funkcija za dohvatanje grupa na promenu predmeta
* * Funkcija za promenu lozinke
* * Funkcija za prikaz spiskova
* * Funkcija za prikaz mojih predmeta kod registrovanog korisnika
* * Funkcija za prikaz predmeta na RTI smeru
* * Klasa za prikaz hedera kod admina
* * Funkcija za klik na tab Korisnici
* * Funkcija za klik na tab Plan
* * Funkcija za klik na tab Plan-dodaj Studente
* * Funkcija za klik na tab Obavestenje
* * Klasa za prikaz hedera kod nastavnika
* * Funkcija za klik na tab Vesti
* * Funkcija za klik na tab Vesti-dodaj vesti
* * Funkcija za klik na tab Vesti-azuriraj veti
* * Funkcija za klik na tab Predmeti - projekat
* * Funkcija za klik na tab Profil
* * Klasa za login
* * Funkcija za brisanje vesti * @param v
* * Klasa za dodavanje vesti koju poziva nastavnik
* * Funkcija za promenu predmeta
* * Klasa za prikaz ispita koje poziva nastavnik
this . novafja ( ) ;
* * Klasa za lab koju poziva nastavnik ( slicno kao i za ispit )
* * Funkcija za dohvatanje obavestenja na promenu kategorije
mladje od 3 meseca ~ 90 dana
* * Klasa za prikaz detalja predmeta
* * Funkcija za prikaz obavestenja
* * Funkcija za prikaz predavanja
* * Funkcija za prikaz ispita
* * Klasa za listu mojih predmeta
* * Klasa za ispite na predmetu
* * Funkcija za skidanje fajla * @param fajl
* * Klasa za prikaz obavestenja ( vesti ) na predemtu
* * Klasa za registraciju korisnika
za studente
* * Funkcija za dohvatanje grupa na osnovu sifre predemta * @param sifra
* * Funkcija za dohvatanje svih nastavnika
* * Funkcija za cuvanje obavestenje
* * Funkcija za brisanje obavestenja
* * Funkcija za registrovanje korisnika k * @param k
* * Funkcija za cuvanje grupe g * @param g
* * Funkcija za cuvanje veze Student-Predmet * @param korime * @param sifraPredmeta
* * Servisna klasa za nastavnika
"* * Funkcija za prikaz profilne slike ako postoji , tj default slike u suprotnom"
= ZAPOSLENI
post ili patch u zavisnosti da li je insert ili update
USPELO
"this . ims . addErrorMessage ( this . translation . translate ( ' error . coreErrorMessage ' ) , this . translation . translate ( "" error . coreErrorMessageDescription "" )) ;"
console . log ( this . loginForm ) ;
console . log ( this . loginForm . get ( ' broj ' ) . value ) ;
ako naletimo na menuItem koji ima url ! = null onda je to sigurno list . uzimamo iz niza roditelja element na poziciji nivo-1 i njemu dodajemo ovaj list osim u slucaju da je sam list na nivou 0.
dodaj direktno u osnovni nivo
ako naletimo na item koji ima naziv null to je separator
dodajemo ga u submenus
"pukao prvi poziv get metode , access token nevalidan"
uspesno osvezen token
DELETE METODE
"ako je status 401 pokusavamo osvezavanje refresh tokenom pri cemu koristimo ugnjezdjavanje zahteva tj kada pozovemo post za dohvatanje novog rokena , odmah u flatMap call back-u pozivamo ponovo dohvatanje resursa rekurzivno"
nepredvidjena greska
POTREBNO JE SKROZ ISKLJUCITI HEDERE !
PUT METODE
"samo ako ponovo dodje status 401 nije prosao ni refresh tokena , u ostalim slucajevima pukao je rekurzivni poziv"
AKO JE SEPARATOR ( onda se zatvaraju zagrade
jsonValue [ i ] [ valueKey ] ;
sekect itemi za pretragu arhivirano
parametri pretrage
arhiviranje
reset selekcije
this . xsysPravnoLiceSysKorisnikTransferService . transfer . next ( -100 ) ;
this . unosKorisnikForm . get ( ' datumVazenjaNaloga ' ) . setValidators ( [ Validators . required ] ) ;
Zaposleni dodaje gosta sa trajanjem naloga od 2 h
this . selectedSysKorisnik = null ;
prima niz od search komponente
za vracanje na spisak zaposlenih ako se zove od strane admina
za izabrani predmet iz liste ucitava podatke koje zaposleni moze da menja
read file as data url
called once readAsDataURL is completed
names je niz korisnickih imena ili sifri predmeta ( zavisi sta je input array )
provera obrasca indeksa
generisanje korisnickog imena na osnovu prikupljenih licnih podataka
ako je indeks za dat tip studija jedinstven -> azuriranje inace : greska
nije jedinstven indeks za tip studija
- Insert predmet -
ako je sifra jedinstvena -> azuriranje inace : greska
provera da li korisnicko ime ima razmak u sebi
ako je korisnicko ime jedinstveno -> azuriranje inace : greska
- Ang grupa -
da li postoji student
login
lozinka
svi podaci o svim nastavnicima
materijali za predavanja i vezbe
materijali za ispite
"ne saljem ceo indeks , jer ' / ' pravi problem pri rutiranju"
req
ako je true znaci da si kliknuo dugme azuriraj
staro korisnicko ime da bismo znali koji da updateujemo jer ako se ime promijeni vise nece biti isto korisnicko ime izracunato
pocetna
login stranica
ne mora ili mora zbog logout ?
dohvatim onoga koji mi se trazi
ako sam ulogovan
SVE FUNKCIJE ZA ADMINISTRATORI KOLEKCIJU
na pocetku poruka greske je prazna
provera ispravnosti podataka
slanje zahteva ka serveru
korime
slanje zahteva za izmenu podataka studenta
slanje zahteva za registraciju zaposlenog ka serveru
slanje zahteva ka serveru za dohvatanje korisnika po korisnickom imenu
slanje zahteva - brisanje vesti
salnje zahteva - izmena vesti
slanje zahteva ka serveru za dohvatanje svih predmeta zadate grupe
slanje zahteva ka serveru za dohvatanje svih predmeta koje drzi nastavnik
slanje zahteva za registraciju studenta ka serveru
slanje zahteva za uklanjanje predmeta zadate sifrom
ako postoji fajl dodeli ga promenljivoj this . file
"mozda je izabran isti predmet , u tom slucaju nema potrebe za dohvatanjem iz baze podataka"
na pocetku poruka greske ne postoji
proveravamo da li je neki podatak ostao nepopunjen
zato treba dohvatiti nove sifre za angazovanje
podrazumevani tab
izabrani tab od stane korisnika ( o-predmetu / predavanja / vezbe / laboratorija .. )
dohvatimo i sortiramo predmete tog odseka po semestru
pretpostavimo da predmet ne postoji
u suprotnom treba dohvatiti sve predmete koji pripadaju toj grupi
postavi trenutne licne podatke korisnika
u buducnosti dodati i opciju za promenu i ostalih licnih podataka ( npr. prezimena )
proveravamo ispravnost unetih podataka
saljemo zahtev serveru za promenu lozinke
uspesna akcija - po uslovu zadatka saljemo korisnika na pocetnu stranicu
poruka o uspesnom ili neuspesnom zahtevu za registraciju
proveravamo sve sto mozemo bez slanja zahteva ka serveru
broj indeksa je broj u rasponu 1 - 9
postavljamo poruku uspeha ili neuspeha
moram da prepisem niz kako ne bih uticao na roditeljsku komponentu
ako je mapiran na drugi predmet izbaci ga
u suprotnom dohvati sve vesti tekuceg predmeta
mozda predmet jos uvek nema nijednu vest
dodatna provera da li je korisnik zaposleni
dohvatimo podatak iz URL-a koji je zaposleni u pitanju
jedino sto moze da ugrozi druge predmete je vec postojeca sifra
izmena zaposlenog
dodaj vest zadatom predmetu
jedino sto moze da ugrozi druge korisnike je registracija sa korisnickim imenom nekog drugog korisnika
menjanje informacija o zadatom predmetu
ako je promenjena i sifra treba azurirati kolekciju za termine nastave
jedino sto se smatra greskom je da je student vec prikljucen zadatom predmetu
ovde uocavamo tu gresku i saljemo poruku o gresci
"zalio se da tr nema atribut ngFor , proradilo tek kad sam isla ctr c i ponovo build frontend i backend"
bez ovoga se javljala greska cannot read property obavestenje of undefined i na kraju ispisa te greske nesto change detect i ja dodala ovo i proradilo ali kad obrisem i dalje radi tako da ne znam sta se desava ..
this . submitted = true ;
"VEC SI IMALA TO IME , ZATO NE ULAZI U TU FJU !"
"username ce se promeniti u zavisnosti od prvog slova imena prezimena , kao i tipa studija ."
za brisanje predmeta
za azuriranje studenata
zaposleni za dodavanje
za azuriranje zaposlenih
provera jedinstvenosti korisnickog imena
provera da li je korisnik u sistemu
brisemo iz angazovanja
brisemo sa spiska studenata koji su bili prijavljeni da ga prate
menjamo status spiska na zatvoren ili otvoren
dohvati nastavnike dodeljene predmetu
napravimo novu listu nastavnika za predmet
dohvatiSvePredmete ( ) dohvata listu svih predmeta na master studijama
Stranica na kojoj nastavnici modu kreirati i azurirati podatke obavestenja na predmetima na kojima su angazovani
Omogucava administratoru brisanje predmeta
Prikaz predmeta sa RTI katedre koji se nude na ostalim odsecima
Komponenta za reset passworda
- Promeni pass zaposleni -
Stranica studenta za prikaz laboratorijskih vezbis na predmetu
Stranica studenta za prikaz materijala za vezbe na predmetu
Stranica za prikaz projekata
Stranica na kojoj administrator moze predlegadi i azurirati podatke studenta
Stranica na kojoj administrator moze predlegadi i azurirati podatke zaposlenih
to show image preview
Prikaz predmeta na RTI studijama
Prikaz detalja nastavnika
popunjavamo ih sada po novom redosledu u bazu
nadamo se da ih je ubacio u bazu
ovde radi profesor
dohavtiti objekat predmeta koji cemo da menjamo
kada prikazujemo predmet sa drugih strana
uzmi name nastavnika
sacuvaj objekat u localStorage
imamo naziv fajla i imamo studenta koji ga postavlja
otvori upload formu
postavi odgovarajuci
ukljuci odg
dodavanje u
promena lozinke-end
registracija zaposlenog - end
svi SI predmeti
ostali odseci
cuvanje u bazi
prezime
mogu da vide samo oni studenti koji prate taj predmet
dodaj da je tip lab
fajlovi za stranicu predmeta
dodavanje fajla uz vest
registrovanje studenta
prijava studenta na predmet
dodavanje zaposlenog - admin
brise fajl
obrisi studenta - admin
vesti profesora
"{ } nema parametre , kao find all"
zaposleni po prezimenu za stranicu zaposlenog
dodavanje teksta lab-a za predmet
dodaj tekst za projekat predmeta
promena vidljivosti
azuriraj studenta-admin
